{"code":"(this.webpackJsonpfrontend=this.webpackJsonpfrontend||[]).push([[120],{402:function(e,t,n){!function(e){\"use strict\";e.defineMode(\"xquery\",(function(){var e=function(){function e(e){return{type:e,style:\"keyword\"}}for(var t=e(\"operator\"),n={type:\"atom\",style:\"atom\"},r={type:\"axis_specifier\",style:\"qualifier\"},a={\",\":{type:\"punctuation\",style:null}},i=[\"after\",\"all\",\"allowing\",\"ancestor\",\"ancestor-or-self\",\"any\",\"array\",\"as\",\"ascending\",\"at\",\"attribute\",\"base-uri\",\"before\",\"boundary-space\",\"by\",\"case\",\"cast\",\"castable\",\"catch\",\"child\",\"collation\",\"comment\",\"construction\",\"contains\",\"content\",\"context\",\"copy\",\"copy-namespaces\",\"count\",\"decimal-format\",\"declare\",\"default\",\"delete\",\"descendant\",\"descendant-or-self\",\"descending\",\"diacritics\",\"different\",\"distance\",\"document\",\"document-node\",\"element\",\"else\",\"empty\",\"empty-sequence\",\"encoding\",\"end\",\"entire\",\"every\",\"exactly\",\"except\",\"external\",\"first\",\"following\",\"following-sibling\",\"for\",\"from\",\"ftand\",\"ftnot\",\"ft-option\",\"ftor\",\"function\",\"fuzzy\",\"greatest\",\"group\",\"if\",\"import\",\"in\",\"inherit\",\"insensitive\",\"insert\",\"instance\",\"intersect\",\"into\",\"invoke\",\"is\",\"item\",\"language\",\"last\",\"lax\",\"least\",\"let\",\"levels\",\"lowercase\",\"map\",\"modify\",\"module\",\"most\",\"namespace\",\"next\",\"no\",\"node\",\"nodes\",\"no-inherit\",\"no-preserve\",\"not\",\"occurs\",\"of\",\"only\",\"option\",\"order\",\"ordered\",\"ordering\",\"paragraph\",\"paragraphs\",\"parent\",\"phrase\",\"preceding\",\"preceding-sibling\",\"preserve\",\"previous\",\"processing-instruction\",\"relationship\",\"rename\",\"replace\",\"return\",\"revalidation\",\"same\",\"satisfies\",\"schema\",\"schema-attribute\",\"schema-element\",\"score\",\"self\",\"sensitive\",\"sentence\",\"sentences\",\"sequence\",\"skip\",\"sliding\",\"some\",\"stable\",\"start\",\"stemming\",\"stop\",\"strict\",\"strip\",\"switch\",\"text\",\"then\",\"thesaurus\",\"times\",\"to\",\"transform\",\"treat\",\"try\",\"tumbling\",\"type\",\"typeswitch\",\"union\",\"unordered\",\"update\",\"updating\",\"uppercase\",\"using\",\"validate\",\"value\",\"variable\",\"version\",\"weight\",\"when\",\"where\",\"wildcards\",\"window\",\"with\",\"without\",\"word\",\"words\",\"xquery\"],o=0,s=i.length;o<s;o++)a[i[o]]=e(i[o]);var c=[\"xs:anyAtomicType\",\"xs:anySimpleType\",\"xs:anyType\",\"xs:anyURI\",\"xs:base64Binary\",\"xs:boolean\",\"xs:byte\",\"xs:date\",\"xs:dateTime\",\"xs:dateTimeStamp\",\"xs:dayTimeDuration\",\"xs:decimal\",\"xs:double\",\"xs:duration\",\"xs:ENTITIES\",\"xs:ENTITY\",\"xs:float\",\"xs:gDay\",\"xs:gMonth\",\"xs:gMonthDay\",\"xs:gYear\",\"xs:gYearMonth\",\"xs:hexBinary\",\"xs:ID\",\"xs:IDREF\",\"xs:IDREFS\",\"xs:int\",\"xs:integer\",\"xs:item\",\"xs:java\",\"xs:language\",\"xs:long\",\"xs:Name\",\"xs:NCName\",\"xs:negativeInteger\",\"xs:NMTOKEN\",\"xs:NMTOKENS\",\"xs:nonNegativeInteger\",\"xs:nonPositiveInteger\",\"xs:normalizedString\",\"xs:NOTATION\",\"xs:numeric\",\"xs:positiveInteger\",\"xs:precisionDecimal\",\"xs:QName\",\"xs:short\",\"xs:string\",\"xs:time\",\"xs:token\",\"xs:unsignedByte\",\"xs:unsignedInt\",\"xs:unsignedLong\",\"xs:unsignedShort\",\"xs:untyped\",\"xs:untypedAtomic\",\"xs:yearMonthDuration\"];for(o=0,s=c.length;o<s;o++)a[c[o]]=n;var u=[\"eq\",\"ne\",\"lt\",\"le\",\"gt\",\"ge\",\":=\",\"=\",\">\",\">=\",\"<\",\"<=\",\".\",\"|\",\"?\",\"and\",\"or\",\"div\",\"idiv\",\"mod\",\"*\",\"/\",\"+\",\"-\"];for(o=0,s=u.length;o<s;o++)a[u[o]]=t;var l=[\"self::\",\"attribute::\",\"child::\",\"descendant::\",\"descendant-or-self::\",\"parent::\",\"ancestor::\",\"ancestor-or-self::\",\"following::\",\"preceding::\",\"following-sibling::\",\"preceding-sibling::\"];for(o=0,s=l.length;o<s;o++)a[l[o]]=r;return a}();function t(e,t,n){return t.tokenize=n,n(e,t)}function n(n,s){var m=n.next(),d=!1,g=x(n);if(\"<\"==m){if(n.match(\"!--\",!0))return t(n,s,c);if(n.match(\"![CDATA\",!1))return s.tokenize=u,\"tag\";if(n.match(\"?\",!1))return t(n,s,l);var k=n.eat(\"/\");n.eatSpace();for(var v,b=\"\";v=n.eat(/[^\\s\\u00a0=<>\\\"\\'\\/?]/);)b+=v;return t(n,s,o(b,k))}if(\"{\"==m)return y(s,{type:\"codeblock\"}),null;if(\"}\"==m)return h(s),null;if(f(s))return\">\"==m?\"tag\":\"/\"==m&&n.eat(\">\")?(h(s),\"tag\"):\"variable\";if(/\\d/.test(m))return n.match(/^\\d*(?:\\.\\d*)?(?:E[+\\-]?\\d+)?/),\"atom\";if(\"(\"===m&&n.eat(\":\"))return y(s,{type:\"comment\"}),t(n,s,r);if(g||'\"'!==m&&\"'\"!==m){if(\"$\"===m)return t(n,s,i);if(\":\"===m&&n.eat(\"=\"))return\"keyword\";if(\"(\"===m)return y(s,{type:\"paren\"}),null;if(\")\"===m)return h(s),null;if(\"[\"===m)return y(s,{type:\"bracket\"}),null;if(\"]\"===m)return h(s),null;var z=e.propertyIsEnumerable(m)&&e[m];if(g&&'\"'===m)for(;'\"'!==n.next(););if(g&&\"'\"===m)for(;\"'\"!==n.next(););z||n.eatWhile(/[\\w\\$_-]/);var w=n.eat(\":\");!n.eat(\":\")&&w&&n.eatWhile(/[\\w\\$_-]/),n.match(/^[ \\t]*\\(/,!1)&&(d=!0);var I=n.current();return z=e.propertyIsEnumerable(I)&&e[I],d&&!z&&(z={type:\"function_call\",style:\"variable def\"}),p(s)?(h(s),\"variable\"):(\"element\"!=I&&\"attribute\"!=I&&\"axis_specifier\"!=z.type||y(s,{type:\"xmlconstructor\"}),z?z.style:\"variable\")}return t(n,s,a(m))}function r(e,t){for(var n,r=!1,a=!1,i=0;n=e.next();){if(\")\"==n&&r){if(!(i>0)){h(t);break}i--}else\":\"==n&&a&&i++;r=\":\"==n,a=\"(\"==n}return\"comment\"}function a(e,t){return function(r,i){var o;if(d(i)&&r.current()==e)return h(i),t&&(i.tokenize=t),\"string\";if(y(i,{type:\"string\",name:e,tokenize:a(e,t)}),r.match(\"{\",!1)&&m(i))return i.tokenize=n,\"string\";for(;o=r.next();){if(o==e){h(i),t&&(i.tokenize=t);break}if(r.match(\"{\",!1)&&m(i))return i.tokenize=n,\"string\"}return\"string\"}}function i(e,t){var r=/[\\w\\$_-]/;if(e.eat('\"')){for(;'\"'!==e.next(););e.eat(\":\")}else e.eatWhile(r),e.match(\":=\",!1)||e.eat(\":\");return e.eatWhile(r),t.tokenize=n,\"variable\"}function o(e,t){return function(r,a){return r.eatSpace(),t&&r.eat(\">\")?(h(a),a.tokenize=n,\"tag\"):(r.eat(\"/\")||y(a,{type:\"tag\",name:e,tokenize:n}),r.eat(\">\")?(a.tokenize=n,\"tag\"):(a.tokenize=s,\"tag\"))}}function s(e,r){var i=e.next();return\"/\"==i&&e.eat(\">\")?(m(r)&&h(r),f(r)&&h(r),\"tag\"):\">\"==i?(m(r)&&h(r),\"tag\"):\"=\"==i?null:'\"'==i||\"'\"==i?t(e,r,a(i,s)):(m(r)||y(r,{type:\"attribute\",tokenize:s}),e.eat(/[a-zA-Z_:]/),e.eatWhile(/[-a-zA-Z0-9_:.]/),e.eatSpace(),(e.match(\">\",!1)||e.match(\"/\",!1))&&(h(r),r.tokenize=n),\"attribute\")}function c(e,t){for(var r;r=e.next();)if(\"-\"==r&&e.match(\"->\",!0))return t.tokenize=n,\"comment\"}function u(e,t){for(var r;r=e.next();)if(\"]\"==r&&e.match(\"]\",!0))return t.tokenize=n,\"comment\"}function l(e,t){for(var r;r=e.next();)if(\"?\"==r&&e.match(\">\",!0))return t.tokenize=n,\"comment meta\"}function f(e){return g(e,\"tag\")}function m(e){return g(e,\"attribute\")}function p(e){return g(e,\"xmlconstructor\")}function d(e){return g(e,\"string\")}function x(e){return'\"'===e.current()?e.match(/^[^\\\"]+\\\"\\:/,!1):\"'\"===e.current()&&e.match(/^[^\\\"]+\\'\\:/,!1)}function g(e,t){return e.stack.length&&e.stack[e.stack.length-1].type==t}function y(e,t){e.stack.push(t)}function h(e){e.stack.pop();var t=e.stack.length&&e.stack[e.stack.length-1].tokenize;e.tokenize=t||n}return{startState:function(){return{tokenize:n,cc:[],stack:[]}},token:function(e,t){return e.eatSpace()?null:t.tokenize(e,t)},blockCommentStart:\"(:\",blockCommentEnd:\":)\"}})),e.defineMIME(\"application/xquery\",\"xquery\")}(n(108))}}]);","name":"static/js/120.64c4778f.chunk.js","map":{"version":3,"sources":["static/js/120.64c4778f.chunk.js"],"names":["this","push","module","exports","__webpack_require__","CodeMirror","defineMode","keywords","kw","type","style","operator","atom","qualifier","kwObj","basic","i","l","length","types","operators","axis_specifiers","chain","stream","state","f","tokenize","tokenBase","ch","next","mightBeFunction","isEQName","isEQNameAhead","match","tokenXMLComment","tokenCDATA","tokenPreProcessing","isclose","eat","eatSpace","c","tagName","tokenTag","pushStateStack","popStateStack","isInXmlBlock","test","tokenComment","tokenVariable","known","propertyIsEnumerable","eatWhile","foundColon","word","current","isInXmlConstructor","tokenString","maybeEnd","maybeNested","nestedCount","quote","isInString","name","isInXmlAttributeBlock","isVariableChar","tokenAttribute","isIn","stack","newState","pop","reinstateTokenize","startState","cc","token","blockCommentStart","blockCommentEnd","defineMIME","mod"],"mappings":"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"},"input":"(this[\"webpackJsonpfrontend\"] = this[\"webpackJsonpfrontend\"] || []).push([[120],{\n\n/***/ 402:\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(108));else {}\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"xquery\", function () {\n    // The keywords object is set to the result of this self executing\n    // function. Each keyword is a property of the keywords object whose\n    // value is {type: atype, style: astyle}\n    var keywords = function () {\n      // convenience functions used to build keywords object\n      function kw(type) {\n        return {\n          type: type,\n          style: \"keyword\"\n        };\n      }\n\n      var operator = kw(\"operator\"),\n          atom = {\n        type: \"atom\",\n        style: \"atom\"\n      },\n          punctuation = {\n        type: \"punctuation\",\n        style: null\n      },\n          qualifier = {\n        type: \"axis_specifier\",\n        style: \"qualifier\"\n      }; // kwObj is what is return from this function at the end\n\n      var kwObj = {\n        ',': punctuation\n      }; // a list of 'basic' keywords. For each add a property to kwObj with the value of\n      // {type: basic[i], style: \"keyword\"} e.g. 'after' --> {type: \"after\", style: \"keyword\"}\n\n      var basic = ['after', 'all', 'allowing', 'ancestor', 'ancestor-or-self', 'any', 'array', 'as', 'ascending', 'at', 'attribute', 'base-uri', 'before', 'boundary-space', 'by', 'case', 'cast', 'castable', 'catch', 'child', 'collation', 'comment', 'construction', 'contains', 'content', 'context', 'copy', 'copy-namespaces', 'count', 'decimal-format', 'declare', 'default', 'delete', 'descendant', 'descendant-or-self', 'descending', 'diacritics', 'different', 'distance', 'document', 'document-node', 'element', 'else', 'empty', 'empty-sequence', 'encoding', 'end', 'entire', 'every', 'exactly', 'except', 'external', 'first', 'following', 'following-sibling', 'for', 'from', 'ftand', 'ftnot', 'ft-option', 'ftor', 'function', 'fuzzy', 'greatest', 'group', 'if', 'import', 'in', 'inherit', 'insensitive', 'insert', 'instance', 'intersect', 'into', 'invoke', 'is', 'item', 'language', 'last', 'lax', 'least', 'let', 'levels', 'lowercase', 'map', 'modify', 'module', 'most', 'namespace', 'next', 'no', 'node', 'nodes', 'no-inherit', 'no-preserve', 'not', 'occurs', 'of', 'only', 'option', 'order', 'ordered', 'ordering', 'paragraph', 'paragraphs', 'parent', 'phrase', 'preceding', 'preceding-sibling', 'preserve', 'previous', 'processing-instruction', 'relationship', 'rename', 'replace', 'return', 'revalidation', 'same', 'satisfies', 'schema', 'schema-attribute', 'schema-element', 'score', 'self', 'sensitive', 'sentence', 'sentences', 'sequence', 'skip', 'sliding', 'some', 'stable', 'start', 'stemming', 'stop', 'strict', 'strip', 'switch', 'text', 'then', 'thesaurus', 'times', 'to', 'transform', 'treat', 'try', 'tumbling', 'type', 'typeswitch', 'union', 'unordered', 'update', 'updating', 'uppercase', 'using', 'validate', 'value', 'variable', 'version', 'weight', 'when', 'where', 'wildcards', 'window', 'with', 'without', 'word', 'words', 'xquery'];\n\n      for (var i = 0, l = basic.length; i < l; i++) {\n        kwObj[basic[i]] = kw(basic[i]);\n      }\n\n      ; // a list of types. For each add a property to kwObj with the value of\n      // {type: \"atom\", style: \"atom\"}\n\n      var types = ['xs:anyAtomicType', 'xs:anySimpleType', 'xs:anyType', 'xs:anyURI', 'xs:base64Binary', 'xs:boolean', 'xs:byte', 'xs:date', 'xs:dateTime', 'xs:dateTimeStamp', 'xs:dayTimeDuration', 'xs:decimal', 'xs:double', 'xs:duration', 'xs:ENTITIES', 'xs:ENTITY', 'xs:float', 'xs:gDay', 'xs:gMonth', 'xs:gMonthDay', 'xs:gYear', 'xs:gYearMonth', 'xs:hexBinary', 'xs:ID', 'xs:IDREF', 'xs:IDREFS', 'xs:int', 'xs:integer', 'xs:item', 'xs:java', 'xs:language', 'xs:long', 'xs:Name', 'xs:NCName', 'xs:negativeInteger', 'xs:NMTOKEN', 'xs:NMTOKENS', 'xs:nonNegativeInteger', 'xs:nonPositiveInteger', 'xs:normalizedString', 'xs:NOTATION', 'xs:numeric', 'xs:positiveInteger', 'xs:precisionDecimal', 'xs:QName', 'xs:short', 'xs:string', 'xs:time', 'xs:token', 'xs:unsignedByte', 'xs:unsignedInt', 'xs:unsignedLong', 'xs:unsignedShort', 'xs:untyped', 'xs:untypedAtomic', 'xs:yearMonthDuration'];\n\n      for (var i = 0, l = types.length; i < l; i++) {\n        kwObj[types[i]] = atom;\n      }\n\n      ; // each operator will add a property to kwObj with value of {type: \"operator\", style: \"keyword\"}\n\n      var operators = ['eq', 'ne', 'lt', 'le', 'gt', 'ge', ':=', '=', '>', '>=', '<', '<=', '.', '|', '?', 'and', 'or', 'div', 'idiv', 'mod', '*', '/', '+', '-'];\n\n      for (var i = 0, l = operators.length; i < l; i++) {\n        kwObj[operators[i]] = operator;\n      }\n\n      ; // each axis_specifiers will add a property to kwObj with value of {type: \"axis_specifier\", style: \"qualifier\"}\n\n      var axis_specifiers = [\"self::\", \"attribute::\", \"child::\", \"descendant::\", \"descendant-or-self::\", \"parent::\", \"ancestor::\", \"ancestor-or-self::\", \"following::\", \"preceding::\", \"following-sibling::\", \"preceding-sibling::\"];\n\n      for (var i = 0, l = axis_specifiers.length; i < l; i++) {\n        kwObj[axis_specifiers[i]] = qualifier;\n      }\n\n      ;\n      return kwObj;\n    }();\n\n    function chain(stream, state, f) {\n      state.tokenize = f;\n      return f(stream, state);\n    } // the primary mode tokenizer\n\n\n    function tokenBase(stream, state) {\n      var ch = stream.next(),\n          mightBeFunction = false,\n          isEQName = isEQNameAhead(stream); // an XML tag (if not in some sub, chained tokenizer)\n\n      if (ch == \"<\") {\n        if (stream.match(\"!--\", true)) return chain(stream, state, tokenXMLComment);\n\n        if (stream.match(\"![CDATA\", false)) {\n          state.tokenize = tokenCDATA;\n          return \"tag\";\n        }\n\n        if (stream.match(\"?\", false)) {\n          return chain(stream, state, tokenPreProcessing);\n        }\n\n        var isclose = stream.eat(\"/\");\n        stream.eatSpace();\n        var tagName = \"\",\n            c;\n\n        while (c = stream.eat(/[^\\s\\u00a0=<>\\\"\\'\\/?]/)) {\n          tagName += c;\n        }\n\n        return chain(stream, state, tokenTag(tagName, isclose));\n      } // start code block\n      else if (ch == \"{\") {\n        pushStateStack(state, {\n          type: \"codeblock\"\n        });\n        return null;\n      } // end code block\n      else if (ch == \"}\") {\n        popStateStack(state);\n        return null;\n      } // if we're in an XML block\n      else if (isInXmlBlock(state)) {\n        if (ch == \">\") return \"tag\";else if (ch == \"/\" && stream.eat(\">\")) {\n          popStateStack(state);\n          return \"tag\";\n        } else return \"variable\";\n      } // if a number\n      else if (/\\d/.test(ch)) {\n        stream.match(/^\\d*(?:\\.\\d*)?(?:E[+\\-]?\\d+)?/);\n        return \"atom\";\n      } // comment start\n      else if (ch === \"(\" && stream.eat(\":\")) {\n        pushStateStack(state, {\n          type: \"comment\"\n        });\n        return chain(stream, state, tokenComment);\n      } // quoted string\n      else if (!isEQName && (ch === '\"' || ch === \"'\")) return chain(stream, state, tokenString(ch)); // variable\n      else if (ch === \"$\") {\n        return chain(stream, state, tokenVariable);\n      } // assignment\n      else if (ch === \":\" && stream.eat(\"=\")) {\n        return \"keyword\";\n      } // open paren\n      else if (ch === \"(\") {\n        pushStateStack(state, {\n          type: \"paren\"\n        });\n        return null;\n      } // close paren\n      else if (ch === \")\") {\n        popStateStack(state);\n        return null;\n      } // open paren\n      else if (ch === \"[\") {\n        pushStateStack(state, {\n          type: \"bracket\"\n        });\n        return null;\n      } // close paren\n      else if (ch === \"]\") {\n        popStateStack(state);\n        return null;\n      } else {\n        var known = keywords.propertyIsEnumerable(ch) && keywords[ch]; // if there's a EQName ahead, consume the rest of the string portion, it's likely a function\n\n        if (isEQName && ch === '\\\"') while (stream.next() !== '\"') {}\n        if (isEQName && ch === '\\'') while (stream.next() !== '\\'') {} // gobble up a word if the character is not known\n\n        if (!known) stream.eatWhile(/[\\w\\$_-]/); // gobble a colon in the case that is a lib func type call fn:doc\n\n        var foundColon = stream.eat(\":\"); // if there's not a second colon, gobble another word. Otherwise, it's probably an axis specifier\n        // which should get matched as a keyword\n\n        if (!stream.eat(\":\") && foundColon) {\n          stream.eatWhile(/[\\w\\$_-]/);\n        } // if the next non whitespace character is an open paren, this is probably a function (if not a keyword of other sort)\n\n\n        if (stream.match(/^[ \\t]*\\(/, false)) {\n          mightBeFunction = true;\n        } // is the word a keyword?\n\n\n        var word = stream.current();\n        known = keywords.propertyIsEnumerable(word) && keywords[word]; // if we think it's a function call but not yet known,\n        // set style to variable for now for lack of something better\n\n        if (mightBeFunction && !known) known = {\n          type: \"function_call\",\n          style: \"variable def\"\n        }; // if the previous word was element, attribute, axis specifier, this word should be the name of that\n\n        if (isInXmlConstructor(state)) {\n          popStateStack(state);\n          return \"variable\";\n        } // as previously checked, if the word is element,attribute, axis specifier, call it an \"xmlconstructor\" and\n        // push the stack so we know to look for it on the next word\n\n\n        if (word == \"element\" || word == \"attribute\" || known.type == \"axis_specifier\") pushStateStack(state, {\n          type: \"xmlconstructor\"\n        }); // if the word is known, return the details of that else just call this a generic 'word'\n\n        return known ? known.style : \"variable\";\n      }\n    } // handle comments, including nested\n\n\n    function tokenComment(stream, state) {\n      var maybeEnd = false,\n          maybeNested = false,\n          nestedCount = 0,\n          ch;\n\n      while (ch = stream.next()) {\n        if (ch == \")\" && maybeEnd) {\n          if (nestedCount > 0) nestedCount--;else {\n            popStateStack(state);\n            break;\n          }\n        } else if (ch == \":\" && maybeNested) {\n          nestedCount++;\n        }\n\n        maybeEnd = ch == \":\";\n        maybeNested = ch == \"(\";\n      }\n\n      return \"comment\";\n    } // tokenizer for string literals\n    // optionally pass a tokenizer function to set state.tokenize back to when finished\n\n\n    function tokenString(quote, f) {\n      return function (stream, state) {\n        var ch;\n\n        if (isInString(state) && stream.current() == quote) {\n          popStateStack(state);\n          if (f) state.tokenize = f;\n          return \"string\";\n        }\n\n        pushStateStack(state, {\n          type: \"string\",\n          name: quote,\n          tokenize: tokenString(quote, f)\n        }); // if we're in a string and in an XML block, allow an embedded code block\n\n        if (stream.match(\"{\", false) && isInXmlAttributeBlock(state)) {\n          state.tokenize = tokenBase;\n          return \"string\";\n        }\n\n        while (ch = stream.next()) {\n          if (ch == quote) {\n            popStateStack(state);\n            if (f) state.tokenize = f;\n            break;\n          } else {\n            // if we're in a string and in an XML block, allow an embedded code block in an attribute\n            if (stream.match(\"{\", false) && isInXmlAttributeBlock(state)) {\n              state.tokenize = tokenBase;\n              return \"string\";\n            }\n          }\n        }\n\n        return \"string\";\n      };\n    } // tokenizer for variables\n\n\n    function tokenVariable(stream, state) {\n      var isVariableChar = /[\\w\\$_-]/; // a variable may start with a quoted EQName so if the next character is quote, consume to the next quote\n\n      if (stream.eat(\"\\\"\")) {\n        while (stream.next() !== '\\\"') {}\n\n        ;\n        stream.eat(\":\");\n      } else {\n        stream.eatWhile(isVariableChar);\n        if (!stream.match(\":=\", false)) stream.eat(\":\");\n      }\n\n      stream.eatWhile(isVariableChar);\n      state.tokenize = tokenBase;\n      return \"variable\";\n    } // tokenizer for XML tags\n\n\n    function tokenTag(name, isclose) {\n      return function (stream, state) {\n        stream.eatSpace();\n\n        if (isclose && stream.eat(\">\")) {\n          popStateStack(state);\n          state.tokenize = tokenBase;\n          return \"tag\";\n        } // self closing tag without attributes?\n\n\n        if (!stream.eat(\"/\")) pushStateStack(state, {\n          type: \"tag\",\n          name: name,\n          tokenize: tokenBase\n        });\n\n        if (!stream.eat(\">\")) {\n          state.tokenize = tokenAttribute;\n          return \"tag\";\n        } else {\n          state.tokenize = tokenBase;\n        }\n\n        return \"tag\";\n      };\n    } // tokenizer for XML attributes\n\n\n    function tokenAttribute(stream, state) {\n      var ch = stream.next();\n\n      if (ch == \"/\" && stream.eat(\">\")) {\n        if (isInXmlAttributeBlock(state)) popStateStack(state);\n        if (isInXmlBlock(state)) popStateStack(state);\n        return \"tag\";\n      }\n\n      if (ch == \">\") {\n        if (isInXmlAttributeBlock(state)) popStateStack(state);\n        return \"tag\";\n      }\n\n      if (ch == \"=\") return null; // quoted string\n\n      if (ch == '\"' || ch == \"'\") return chain(stream, state, tokenString(ch, tokenAttribute));\n      if (!isInXmlAttributeBlock(state)) pushStateStack(state, {\n        type: \"attribute\",\n        tokenize: tokenAttribute\n      });\n      stream.eat(/[a-zA-Z_:]/);\n      stream.eatWhile(/[-a-zA-Z0-9_:.]/);\n      stream.eatSpace(); // the case where the attribute has not value and the tag was closed\n\n      if (stream.match(\">\", false) || stream.match(\"/\", false)) {\n        popStateStack(state);\n        state.tokenize = tokenBase;\n      }\n\n      return \"attribute\";\n    } // handle comments, including nested\n\n\n    function tokenXMLComment(stream, state) {\n      var ch;\n\n      while (ch = stream.next()) {\n        if (ch == \"-\" && stream.match(\"->\", true)) {\n          state.tokenize = tokenBase;\n          return \"comment\";\n        }\n      }\n    } // handle CDATA\n\n\n    function tokenCDATA(stream, state) {\n      var ch;\n\n      while (ch = stream.next()) {\n        if (ch == \"]\" && stream.match(\"]\", true)) {\n          state.tokenize = tokenBase;\n          return \"comment\";\n        }\n      }\n    } // handle preprocessing instructions\n\n\n    function tokenPreProcessing(stream, state) {\n      var ch;\n\n      while (ch = stream.next()) {\n        if (ch == \"?\" && stream.match(\">\", true)) {\n          state.tokenize = tokenBase;\n          return \"comment meta\";\n        }\n      }\n    } // functions to test the current context of the state\n\n\n    function isInXmlBlock(state) {\n      return isIn(state, \"tag\");\n    }\n\n    function isInXmlAttributeBlock(state) {\n      return isIn(state, \"attribute\");\n    }\n\n    function isInXmlConstructor(state) {\n      return isIn(state, \"xmlconstructor\");\n    }\n\n    function isInString(state) {\n      return isIn(state, \"string\");\n    }\n\n    function isEQNameAhead(stream) {\n      // assume we've already eaten a quote (\")\n      if (stream.current() === '\"') return stream.match(/^[^\\\"]+\\\"\\:/, false);else if (stream.current() === '\\'') return stream.match(/^[^\\\"]+\\'\\:/, false);else return false;\n    }\n\n    function isIn(state, type) {\n      return state.stack.length && state.stack[state.stack.length - 1].type == type;\n    }\n\n    function pushStateStack(state, newState) {\n      state.stack.push(newState);\n    }\n\n    function popStateStack(state) {\n      state.stack.pop();\n      var reinstateTokenize = state.stack.length && state.stack[state.stack.length - 1].tokenize;\n      state.tokenize = reinstateTokenize || tokenBase;\n    } // the interface for the mode API\n\n\n    return {\n      startState: function startState() {\n        return {\n          tokenize: tokenBase,\n          cc: [],\n          stack: []\n        };\n      },\n      token: function token(stream, state) {\n        if (stream.eatSpace()) return null;\n        var style = state.tokenize(stream, state);\n        return style;\n      },\n      blockCommentStart: \"(:\",\n      blockCommentEnd: \":)\"\n    };\n  });\n  CodeMirror.defineMIME(\"application/xquery\", \"xquery\");\n});\n\n/***/ })\n\n}]);","inputSourceMap":{"version":3,"sources":["/mnt/Datengrab/python/Zero-tier/frontend/node_modules/codemirror/mode/xquery/xquery.js"],"names":["mod","require","CodeMirror","defineMode","keywords","kw","type","style","operator","atom","punctuation","qualifier","kwObj","basic","i","l","length","types","operators","axis_specifiers","chain","stream","state","f","tokenize","tokenBase","ch","next","mightBeFunction","isEQName","isEQNameAhead","match","tokenXMLComment","tokenCDATA","tokenPreProcessing","isclose","eat","eatSpace","tagName","c","tokenTag","pushStateStack","popStateStack","isInXmlBlock","test","tokenComment","tokenString","tokenVariable","known","propertyIsEnumerable","eatWhile","foundColon","word","current","isInXmlConstructor","maybeEnd","maybeNested","nestedCount","quote","isInString","name","isInXmlAttributeBlock","isVariableChar","tokenAttribute","isIn","stack","newState","push","pop","reinstateTokenize","startState","cc","token","blockCommentStart","blockCommentEnd","defineMIME"],"mappings":"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","file":"x","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"xquery\", function() {\n\n  // The keywords object is set to the result of this self executing\n  // function. Each keyword is a property of the keywords object whose\n  // value is {type: atype, style: astyle}\n  var keywords = function(){\n    // convenience functions used to build keywords object\n    function kw(type) {return {type: type, style: \"keyword\"};}\n    var operator = kw(\"operator\")\n      , atom = {type: \"atom\", style: \"atom\"}\n      , punctuation = {type: \"punctuation\", style: null}\n      , qualifier = {type: \"axis_specifier\", style: \"qualifier\"};\n\n    // kwObj is what is return from this function at the end\n    var kwObj = {\n      ',': punctuation\n    };\n\n    // a list of 'basic' keywords. For each add a property to kwObj with the value of\n    // {type: basic[i], style: \"keyword\"} e.g. 'after' --> {type: \"after\", style: \"keyword\"}\n    var basic = ['after', 'all', 'allowing', 'ancestor', 'ancestor-or-self', 'any', 'array', 'as',\n    'ascending', 'at', 'attribute', 'base-uri', 'before', 'boundary-space', 'by', 'case', 'cast',\n    'castable', 'catch', 'child', 'collation', 'comment', 'construction', 'contains', 'content',\n    'context', 'copy', 'copy-namespaces', 'count', 'decimal-format', 'declare', 'default', 'delete',\n    'descendant', 'descendant-or-self', 'descending', 'diacritics', 'different', 'distance',\n    'document', 'document-node', 'element', 'else', 'empty', 'empty-sequence', 'encoding', 'end',\n    'entire', 'every', 'exactly', 'except', 'external', 'first', 'following', 'following-sibling',\n    'for', 'from', 'ftand', 'ftnot', 'ft-option', 'ftor', 'function', 'fuzzy', 'greatest', 'group',\n    'if', 'import', 'in', 'inherit', 'insensitive', 'insert', 'instance', 'intersect', 'into',\n    'invoke', 'is', 'item', 'language', 'last', 'lax', 'least', 'let', 'levels', 'lowercase', 'map',\n    'modify', 'module', 'most', 'namespace', 'next', 'no', 'node', 'nodes', 'no-inherit',\n    'no-preserve', 'not', 'occurs', 'of', 'only', 'option', 'order', 'ordered', 'ordering',\n    'paragraph', 'paragraphs', 'parent', 'phrase', 'preceding', 'preceding-sibling', 'preserve',\n    'previous', 'processing-instruction', 'relationship', 'rename', 'replace', 'return',\n    'revalidation', 'same', 'satisfies', 'schema', 'schema-attribute', 'schema-element', 'score',\n    'self', 'sensitive', 'sentence', 'sentences', 'sequence', 'skip', 'sliding', 'some', 'stable',\n    'start', 'stemming', 'stop', 'strict', 'strip', 'switch', 'text', 'then', 'thesaurus', 'times',\n    'to', 'transform', 'treat', 'try', 'tumbling', 'type', 'typeswitch', 'union', 'unordered',\n    'update', 'updating', 'uppercase', 'using', 'validate', 'value', 'variable', 'version',\n    'weight', 'when', 'where', 'wildcards', 'window', 'with', 'without', 'word', 'words', 'xquery'];\n    for(var i=0, l=basic.length; i < l; i++) { kwObj[basic[i]] = kw(basic[i]);};\n\n    // a list of types. For each add a property to kwObj with the value of\n    // {type: \"atom\", style: \"atom\"}\n    var types = ['xs:anyAtomicType', 'xs:anySimpleType', 'xs:anyType', 'xs:anyURI',\n    'xs:base64Binary', 'xs:boolean', 'xs:byte', 'xs:date', 'xs:dateTime', 'xs:dateTimeStamp',\n    'xs:dayTimeDuration', 'xs:decimal', 'xs:double', 'xs:duration', 'xs:ENTITIES', 'xs:ENTITY',\n    'xs:float', 'xs:gDay', 'xs:gMonth', 'xs:gMonthDay', 'xs:gYear', 'xs:gYearMonth', 'xs:hexBinary',\n    'xs:ID', 'xs:IDREF', 'xs:IDREFS', 'xs:int', 'xs:integer', 'xs:item', 'xs:java', 'xs:language',\n    'xs:long', 'xs:Name', 'xs:NCName', 'xs:negativeInteger', 'xs:NMTOKEN', 'xs:NMTOKENS',\n    'xs:nonNegativeInteger', 'xs:nonPositiveInteger', 'xs:normalizedString', 'xs:NOTATION',\n    'xs:numeric', 'xs:positiveInteger', 'xs:precisionDecimal', 'xs:QName', 'xs:short', 'xs:string',\n    'xs:time', 'xs:token', 'xs:unsignedByte', 'xs:unsignedInt', 'xs:unsignedLong',\n    'xs:unsignedShort', 'xs:untyped', 'xs:untypedAtomic', 'xs:yearMonthDuration'];\n    for(var i=0, l=types.length; i < l; i++) { kwObj[types[i]] = atom;};\n\n    // each operator will add a property to kwObj with value of {type: \"operator\", style: \"keyword\"}\n    var operators = ['eq', 'ne', 'lt', 'le', 'gt', 'ge', ':=', '=', '>', '>=', '<', '<=', '.', '|', '?', 'and', 'or', 'div', 'idiv', 'mod', '*', '/', '+', '-'];\n    for(var i=0, l=operators.length; i < l; i++) { kwObj[operators[i]] = operator;};\n\n    // each axis_specifiers will add a property to kwObj with value of {type: \"axis_specifier\", style: \"qualifier\"}\n    var axis_specifiers = [\"self::\", \"attribute::\", \"child::\", \"descendant::\", \"descendant-or-self::\", \"parent::\",\n    \"ancestor::\", \"ancestor-or-self::\", \"following::\", \"preceding::\", \"following-sibling::\", \"preceding-sibling::\"];\n    for(var i=0, l=axis_specifiers.length; i < l; i++) { kwObj[axis_specifiers[i]] = qualifier; };\n\n    return kwObj;\n  }();\n\n  function chain(stream, state, f) {\n    state.tokenize = f;\n    return f(stream, state);\n  }\n\n  // the primary mode tokenizer\n  function tokenBase(stream, state) {\n    var ch = stream.next(),\n        mightBeFunction = false,\n        isEQName = isEQNameAhead(stream);\n\n    // an XML tag (if not in some sub, chained tokenizer)\n    if (ch == \"<\") {\n      if(stream.match(\"!--\", true))\n        return chain(stream, state, tokenXMLComment);\n\n      if(stream.match(\"![CDATA\", false)) {\n        state.tokenize = tokenCDATA;\n        return \"tag\";\n      }\n\n      if(stream.match(\"?\", false)) {\n        return chain(stream, state, tokenPreProcessing);\n      }\n\n      var isclose = stream.eat(\"/\");\n      stream.eatSpace();\n      var tagName = \"\", c;\n      while ((c = stream.eat(/[^\\s\\u00a0=<>\\\"\\'\\/?]/))) tagName += c;\n\n      return chain(stream, state, tokenTag(tagName, isclose));\n    }\n    // start code block\n    else if(ch == \"{\") {\n      pushStateStack(state, { type: \"codeblock\"});\n      return null;\n    }\n    // end code block\n    else if(ch == \"}\") {\n      popStateStack(state);\n      return null;\n    }\n    // if we're in an XML block\n    else if(isInXmlBlock(state)) {\n      if(ch == \">\")\n        return \"tag\";\n      else if(ch == \"/\" && stream.eat(\">\")) {\n        popStateStack(state);\n        return \"tag\";\n      }\n      else\n        return \"variable\";\n    }\n    // if a number\n    else if (/\\d/.test(ch)) {\n      stream.match(/^\\d*(?:\\.\\d*)?(?:E[+\\-]?\\d+)?/);\n      return \"atom\";\n    }\n    // comment start\n    else if (ch === \"(\" && stream.eat(\":\")) {\n      pushStateStack(state, { type: \"comment\"});\n      return chain(stream, state, tokenComment);\n    }\n    // quoted string\n    else if (!isEQName && (ch === '\"' || ch === \"'\"))\n      return chain(stream, state, tokenString(ch));\n    // variable\n    else if(ch === \"$\") {\n      return chain(stream, state, tokenVariable);\n    }\n    // assignment\n    else if(ch ===\":\" && stream.eat(\"=\")) {\n      return \"keyword\";\n    }\n    // open paren\n    else if(ch === \"(\") {\n      pushStateStack(state, { type: \"paren\"});\n      return null;\n    }\n    // close paren\n    else if(ch === \")\") {\n      popStateStack(state);\n      return null;\n    }\n    // open paren\n    else if(ch === \"[\") {\n      pushStateStack(state, { type: \"bracket\"});\n      return null;\n    }\n    // close paren\n    else if(ch === \"]\") {\n      popStateStack(state);\n      return null;\n    }\n    else {\n      var known = keywords.propertyIsEnumerable(ch) && keywords[ch];\n\n      // if there's a EQName ahead, consume the rest of the string portion, it's likely a function\n      if(isEQName && ch === '\\\"') while(stream.next() !== '\"'){}\n      if(isEQName && ch === '\\'') while(stream.next() !== '\\''){}\n\n      // gobble up a word if the character is not known\n      if(!known) stream.eatWhile(/[\\w\\$_-]/);\n\n      // gobble a colon in the case that is a lib func type call fn:doc\n      var foundColon = stream.eat(\":\");\n\n      // if there's not a second colon, gobble another word. Otherwise, it's probably an axis specifier\n      // which should get matched as a keyword\n      if(!stream.eat(\":\") && foundColon) {\n        stream.eatWhile(/[\\w\\$_-]/);\n      }\n      // if the next non whitespace character is an open paren, this is probably a function (if not a keyword of other sort)\n      if(stream.match(/^[ \\t]*\\(/, false)) {\n        mightBeFunction = true;\n      }\n      // is the word a keyword?\n      var word = stream.current();\n      known = keywords.propertyIsEnumerable(word) && keywords[word];\n\n      // if we think it's a function call but not yet known,\n      // set style to variable for now for lack of something better\n      if(mightBeFunction && !known) known = {type: \"function_call\", style: \"variable def\"};\n\n      // if the previous word was element, attribute, axis specifier, this word should be the name of that\n      if(isInXmlConstructor(state)) {\n        popStateStack(state);\n        return \"variable\";\n      }\n      // as previously checked, if the word is element,attribute, axis specifier, call it an \"xmlconstructor\" and\n      // push the stack so we know to look for it on the next word\n      if(word == \"element\" || word == \"attribute\" || known.type == \"axis_specifier\") pushStateStack(state, {type: \"xmlconstructor\"});\n\n      // if the word is known, return the details of that else just call this a generic 'word'\n      return known ? known.style : \"variable\";\n    }\n  }\n\n  // handle comments, including nested\n  function tokenComment(stream, state) {\n    var maybeEnd = false, maybeNested = false, nestedCount = 0, ch;\n    while (ch = stream.next()) {\n      if (ch == \")\" && maybeEnd) {\n        if(nestedCount > 0)\n          nestedCount--;\n        else {\n          popStateStack(state);\n          break;\n        }\n      }\n      else if(ch == \":\" && maybeNested) {\n        nestedCount++;\n      }\n      maybeEnd = (ch == \":\");\n      maybeNested = (ch == \"(\");\n    }\n\n    return \"comment\";\n  }\n\n  // tokenizer for string literals\n  // optionally pass a tokenizer function to set state.tokenize back to when finished\n  function tokenString(quote, f) {\n    return function(stream, state) {\n      var ch;\n\n      if(isInString(state) && stream.current() == quote) {\n        popStateStack(state);\n        if(f) state.tokenize = f;\n        return \"string\";\n      }\n\n      pushStateStack(state, { type: \"string\", name: quote, tokenize: tokenString(quote, f) });\n\n      // if we're in a string and in an XML block, allow an embedded code block\n      if(stream.match(\"{\", false) && isInXmlAttributeBlock(state)) {\n        state.tokenize = tokenBase;\n        return \"string\";\n      }\n\n\n      while (ch = stream.next()) {\n        if (ch ==  quote) {\n          popStateStack(state);\n          if(f) state.tokenize = f;\n          break;\n        }\n        else {\n          // if we're in a string and in an XML block, allow an embedded code block in an attribute\n          if(stream.match(\"{\", false) && isInXmlAttributeBlock(state)) {\n            state.tokenize = tokenBase;\n            return \"string\";\n          }\n\n        }\n      }\n\n      return \"string\";\n    };\n  }\n\n  // tokenizer for variables\n  function tokenVariable(stream, state) {\n    var isVariableChar = /[\\w\\$_-]/;\n\n    // a variable may start with a quoted EQName so if the next character is quote, consume to the next quote\n    if(stream.eat(\"\\\"\")) {\n      while(stream.next() !== '\\\"'){};\n      stream.eat(\":\");\n    } else {\n      stream.eatWhile(isVariableChar);\n      if(!stream.match(\":=\", false)) stream.eat(\":\");\n    }\n    stream.eatWhile(isVariableChar);\n    state.tokenize = tokenBase;\n    return \"variable\";\n  }\n\n  // tokenizer for XML tags\n  function tokenTag(name, isclose) {\n    return function(stream, state) {\n      stream.eatSpace();\n      if(isclose && stream.eat(\">\")) {\n        popStateStack(state);\n        state.tokenize = tokenBase;\n        return \"tag\";\n      }\n      // self closing tag without attributes?\n      if(!stream.eat(\"/\"))\n        pushStateStack(state, { type: \"tag\", name: name, tokenize: tokenBase});\n      if(!stream.eat(\">\")) {\n        state.tokenize = tokenAttribute;\n        return \"tag\";\n      }\n      else {\n        state.tokenize = tokenBase;\n      }\n      return \"tag\";\n    };\n  }\n\n  // tokenizer for XML attributes\n  function tokenAttribute(stream, state) {\n    var ch = stream.next();\n\n    if(ch == \"/\" && stream.eat(\">\")) {\n      if(isInXmlAttributeBlock(state)) popStateStack(state);\n      if(isInXmlBlock(state)) popStateStack(state);\n      return \"tag\";\n    }\n    if(ch == \">\") {\n      if(isInXmlAttributeBlock(state)) popStateStack(state);\n      return \"tag\";\n    }\n    if(ch == \"=\")\n      return null;\n    // quoted string\n    if (ch == '\"' || ch == \"'\")\n      return chain(stream, state, tokenString(ch, tokenAttribute));\n\n    if(!isInXmlAttributeBlock(state))\n      pushStateStack(state, { type: \"attribute\", tokenize: tokenAttribute});\n\n    stream.eat(/[a-zA-Z_:]/);\n    stream.eatWhile(/[-a-zA-Z0-9_:.]/);\n    stream.eatSpace();\n\n    // the case where the attribute has not value and the tag was closed\n    if(stream.match(\">\", false) || stream.match(\"/\", false)) {\n      popStateStack(state);\n      state.tokenize = tokenBase;\n    }\n\n    return \"attribute\";\n  }\n\n  // handle comments, including nested\n  function tokenXMLComment(stream, state) {\n    var ch;\n    while (ch = stream.next()) {\n      if (ch == \"-\" && stream.match(\"->\", true)) {\n        state.tokenize = tokenBase;\n        return \"comment\";\n      }\n    }\n  }\n\n\n  // handle CDATA\n  function tokenCDATA(stream, state) {\n    var ch;\n    while (ch = stream.next()) {\n      if (ch == \"]\" && stream.match(\"]\", true)) {\n        state.tokenize = tokenBase;\n        return \"comment\";\n      }\n    }\n  }\n\n  // handle preprocessing instructions\n  function tokenPreProcessing(stream, state) {\n    var ch;\n    while (ch = stream.next()) {\n      if (ch == \"?\" && stream.match(\">\", true)) {\n        state.tokenize = tokenBase;\n        return \"comment meta\";\n      }\n    }\n  }\n\n\n  // functions to test the current context of the state\n  function isInXmlBlock(state) { return isIn(state, \"tag\"); }\n  function isInXmlAttributeBlock(state) { return isIn(state, \"attribute\"); }\n  function isInXmlConstructor(state) { return isIn(state, \"xmlconstructor\"); }\n  function isInString(state) { return isIn(state, \"string\"); }\n\n  function isEQNameAhead(stream) {\n    // assume we've already eaten a quote (\")\n    if(stream.current() === '\"')\n      return stream.match(/^[^\\\"]+\\\"\\:/, false);\n    else if(stream.current() === '\\'')\n      return stream.match(/^[^\\\"]+\\'\\:/, false);\n    else\n      return false;\n  }\n\n  function isIn(state, type) {\n    return (state.stack.length && state.stack[state.stack.length - 1].type == type);\n  }\n\n  function pushStateStack(state, newState) {\n    state.stack.push(newState);\n  }\n\n  function popStateStack(state) {\n    state.stack.pop();\n    var reinstateTokenize = state.stack.length && state.stack[state.stack.length-1].tokenize;\n    state.tokenize = reinstateTokenize || tokenBase;\n  }\n\n  // the interface for the mode API\n  return {\n    startState: function() {\n      return {\n        tokenize: tokenBase,\n        cc: [],\n        stack: []\n      };\n    },\n\n    token: function(stream, state) {\n      if (stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      return style;\n    },\n\n    blockCommentStart: \"(:\",\n    blockCommentEnd: \":)\"\n\n  };\n\n});\n\nCodeMirror.defineMIME(\"application/xquery\", \"xquery\");\n\n});\n"]}}