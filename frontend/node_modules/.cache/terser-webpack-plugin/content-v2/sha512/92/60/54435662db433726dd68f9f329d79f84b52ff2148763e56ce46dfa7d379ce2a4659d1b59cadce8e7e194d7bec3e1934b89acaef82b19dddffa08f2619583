{"code":"(this.webpackJsonpfrontend=this.webpackJsonpfrontend||[]).push([[93],{371:function(e,t,n){!function(e){\"use strict\";e.defineMode(\"scheme\",(function(){var e=\"builtin\",t=\"comment\",n=\"string\",r=\"symbol\",i=\"atom\",a=\"number\",s=\"bracket\",c=2;function o(e){for(var t={},n=e.split(\" \"),r=0;r<n.length;++r)t[n[r]]=!0;return t}var l=o(\"\\u03bb case-lambda call/cc class cond-expand define-class define-values exit-handler field import inherit init-field interface let*-values let-values let/ec mixin opt-lambda override protect provide public rename require require-for-syntax syntax syntax-case syntax-error unit/sig unless when with-syntax and begin call-with-current-continuation call-with-input-file call-with-output-file case cond define define-syntax define-macro defmacro delay do dynamic-wind else for-each if lambda let let* let-syntax letrec letrec-syntax map or syntax-rules abs acos angle append apply asin assoc assq assv atan boolean? caar cadr call-with-input-file call-with-output-file call-with-values car cdddar cddddr cdr ceiling char->integer char-alphabetic? char-ci<=? char-ci<? char-ci=? char-ci>=? char-ci>? char-downcase char-lower-case? char-numeric? char-ready? char-upcase char-upper-case? char-whitespace? char<=? char<? char=? char>=? char>? char? close-input-port close-output-port complex? cons cos current-input-port current-output-port denominator display eof-object? eq? equal? eqv? eval even? exact->inexact exact? exp expt #f floor force gcd imag-part inexact->exact inexact? input-port? integer->char integer? interaction-environment lcm length list list->string list->vector list-ref list-tail list? load log magnitude make-polar make-rectangular make-string make-vector max member memq memv min modulo negative? newline not null-environment null? number->string number? numerator odd? open-input-file open-output-file output-port? pair? peek-char port? positive? procedure? quasiquote quote quotient rational? rationalize read read-char real-part real? remainder reverse round scheme-report-environment set! set-car! set-cdr! sin sqrt string string->list string->number string->symbol string-append string-ci<=? string-ci<? string-ci=? string-ci>=? string-ci>? string-copy string-fill! string-length string-ref string-set! string<=? string<? string=? string>=? string>? string? substring symbol->string symbol? #t tan transcript-off transcript-on truncate values vector vector->list vector-fill! vector-length vector-ref vector-set! with-input-from-file with-output-to-file write write-char zero?\"),d=o(\"define let letrec let* lambda define-macro defmacro let-syntax letrec-syntax let-values let*-values define-syntax syntax-rules define-values when unless\");function u(e,t,n){this.indent=e,this.type=t,this.prev=n}function p(e,t,n){e.indentStack=new u(t,n,e.indentStack)}function m(e){e.indentStack=e.indentStack.prev}var f=new RegExp(/^(?:[-+]i|[-+][01]+#*(?:\\/[01]+#*)?i|[-+]?[01]+#*(?:\\/[01]+#*)?@[-+]?[01]+#*(?:\\/[01]+#*)?|[-+]?[01]+#*(?:\\/[01]+#*)?[-+](?:[01]+#*(?:\\/[01]+#*)?)?i|[-+]?[01]+#*(?:\\/[01]+#*)?)(?=[()\\s;\"]|$)/i),h=new RegExp(/^(?:[-+]i|[-+][0-7]+#*(?:\\/[0-7]+#*)?i|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?@[-+]?[0-7]+#*(?:\\/[0-7]+#*)?|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?[-+](?:[0-7]+#*(?:\\/[0-7]+#*)?)?i|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?)(?=[()\\s;\"]|$)/i),x=new RegExp(/^(?:[-+]i|[-+][\\da-f]+#*(?:\\/[\\da-f]+#*)?i|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?@[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?[-+](?:[\\da-f]+#*(?:\\/[\\da-f]+#*)?)?i|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?)(?=[()\\s;\"]|$)/i),g=new RegExp(/^(?:[-+]i|[-+](?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)i|[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)@[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)|[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)[-+](?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)?i|(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*))(?=[()\\s;\"]|$)/i);function b(e){return e.match(f)}function v(e){return e.match(h)}function k(e,t){return!0===t&&e.backUp(1),e.match(g)}function y(e){return e.match(x)}function w(e,t){for(var n,r=!1;null!=(n=e.next());){if(n==t.token&&!r){t.state.mode=!1;break}r=!r&&\"\\\\\"==n}}return{startState:function(){return{indentStack:null,indentation:0,mode:!1,sExprComment:!1,sExprQuote:!1}},token:function(o,u){if(null==u.indentStack&&o.sol()&&(u.indentation=o.indentation()),o.eatSpace())return null;var f=null;switch(u.mode){case\"string\":w(o,{token:'\"',state:u}),f=n;break;case\"symbol\":w(o,{token:\"|\",state:u}),f=r;break;case\"comment\":for(var h,x=!1;null!=(h=o.next());){if(\"#\"==h&&x){u.mode=!1;break}x=\"|\"==h}f=t;break;case\"s-expr-comment\":if(u.mode=!1,\"(\"!=o.peek()&&\"[\"!=o.peek()){o.eatWhile(/[^\\s\\(\\)\\[\\]]/),f=t;break}u.sExprComment=0;default:var g=o.next();if('\"'==g)u.mode=\"string\",f=n;else if(\"'\"==g)\"(\"==o.peek()||\"[\"==o.peek()?(\"number\"!=typeof u.sExprQuote&&(u.sExprQuote=0),f=i):(o.eatWhile(/[\\w_\\-!$%&*+\\.\\/:<=>?@\\^~]/),f=i);else if(\"|\"==g)u.mode=\"symbol\",f=r;else if(\"#\"==g)if(o.eat(\"|\"))u.mode=\"comment\",f=t;else if(o.eat(/[tf]/i))f=i;else if(o.eat(\";\"))u.mode=\"s-expr-comment\",f=t;else{var E=null,S=!1,q=!0;o.eat(/[ei]/i)?S=!0:o.backUp(1),o.match(/^#b/i)?E=b:o.match(/^#o/i)?E=v:o.match(/^#x/i)?E=y:o.match(/^#d/i)?E=k:o.match(/^[-+0-9.]/,!1)?(q=!1,E=k):S||o.eat(\"#\"),null!=E&&(q&&!S&&o.match(/^#[ei]/i),E(o)&&(f=a))}else if(/^[-+0-9.]/.test(g)&&k(o,!0))f=a;else if(\";\"==g)o.skipToEnd(),f=t;else if(\"(\"==g||\"[\"==g){for(var C,Q=\"\",$=o.column();null!=(C=o.eat(/[^\\s\\(\\[\\;\\)\\]]/));)Q+=C;Q.length>0&&d.propertyIsEnumerable(Q)?p(u,$+c,g):(o.eatSpace(),o.eol()||\";\"==o.peek()?p(u,$+1,g):p(u,$+o.current().length,g)),o.backUp(o.current().length-1),\"number\"==typeof u.sExprComment&&u.sExprComment++,\"number\"==typeof u.sExprQuote&&u.sExprQuote++,f=s}else\")\"==g||\"]\"==g?(f=s,null!=u.indentStack&&u.indentStack.type==(\")\"==g?\"(\":\"[\")&&(m(u),\"number\"==typeof u.sExprComment&&0==--u.sExprComment&&(f=t,u.sExprComment=!1),\"number\"==typeof u.sExprQuote&&0==--u.sExprQuote&&(f=i,u.sExprQuote=!1))):(o.eatWhile(/[\\w_\\-!$%&*+\\.\\/:<=>?@\\^~]/),f=l&&l.propertyIsEnumerable(o.current())?e:\"variable\")}return\"number\"==typeof u.sExprComment?t:\"number\"==typeof u.sExprQuote?i:f},indent:function(e){return null==e.indentStack?e.indentation:e.indentStack.indent},fold:\"brace-paren\",closeBrackets:{pairs:'()[]{}\"\"'},lineComment:\";;\"}})),e.defineMIME(\"text/x-scheme\",\"scheme\")}(n(108))}}]);","name":"static/js/93.0f8a6ee8.chunk.js","map":{"version":3,"sources":["static/js/93.0f8a6ee8.chunk.js"],"names":["this","push","module","exports","__webpack_require__","CodeMirror","defineMode","BUILTIN","COMMENT","STRING","SYMBOL","ATOM","NUMBER","BRACKET","INDENT_WORD_SKIP","makeKeywords","str","obj","words","split","i","length","keywords","indentKeys","stateStack","indent","type","prev","pushStack","state","indentStack","popStack","binaryMatcher","RegExp","octalMatcher","hexMatcher","decimalMatcher","isBinaryNumber","stream","match","isOctalNumber","isDecimalNumber","backup","backUp","isHexNumber","processEscapedSequence","options","next","escaped","token","mode","startState","indentation","sExprComment","sExprQuote","sol","eatSpace","returnType","maybeEnd","peek","eatWhile","ch","eat","numTest","hasExactness","hasRadix","test","skipToEnd","letter","keyWord","indentTemp","column","propertyIsEnumerable","eol","current","fold","closeBrackets","pairs","lineComment","defineMIME","mod"],"mappings":"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"},"input":"(this[\"webpackJsonpfrontend\"] = this[\"webpackJsonpfrontend\"] || []).push([[93],{\n\n/***/ 371:\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n/**\n * Author: Koh Zi Han, based on implementation by Koh Zi Chun\n * Improved by: Jakub T. Jankiewicz\n */\n(function (mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(108));else {}\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"scheme\", function () {\n    var BUILTIN = \"builtin\",\n        COMMENT = \"comment\",\n        STRING = \"string\",\n        SYMBOL = \"symbol\",\n        ATOM = \"atom\",\n        NUMBER = \"number\",\n        BRACKET = \"bracket\";\n    var INDENT_WORD_SKIP = 2;\n\n    function makeKeywords(str) {\n      var obj = {},\n          words = str.split(\" \");\n\n      for (var i = 0; i < words.length; ++i) {\n        obj[words[i]] = true;\n      }\n\n      return obj;\n    }\n\n    var keywords = makeKeywords(\"λ case-lambda call/cc class cond-expand define-class define-values exit-handler field import inherit init-field interface let*-values let-values let/ec mixin opt-lambda override protect provide public rename require require-for-syntax syntax syntax-case syntax-error unit/sig unless when with-syntax and begin call-with-current-continuation call-with-input-file call-with-output-file case cond define define-syntax define-macro defmacro delay do dynamic-wind else for-each if lambda let let* let-syntax letrec letrec-syntax map or syntax-rules abs acos angle append apply asin assoc assq assv atan boolean? caar cadr call-with-input-file call-with-output-file call-with-values car cdddar cddddr cdr ceiling char->integer char-alphabetic? char-ci<=? char-ci<? char-ci=? char-ci>=? char-ci>? char-downcase char-lower-case? char-numeric? char-ready? char-upcase char-upper-case? char-whitespace? char<=? char<? char=? char>=? char>? char? close-input-port close-output-port complex? cons cos current-input-port current-output-port denominator display eof-object? eq? equal? eqv? eval even? exact->inexact exact? exp expt #f floor force gcd imag-part inexact->exact inexact? input-port? integer->char integer? interaction-environment lcm length list list->string list->vector list-ref list-tail list? load log magnitude make-polar make-rectangular make-string make-vector max member memq memv min modulo negative? newline not null-environment null? number->string number? numerator odd? open-input-file open-output-file output-port? pair? peek-char port? positive? procedure? quasiquote quote quotient rational? rationalize read read-char real-part real? remainder reverse round scheme-report-environment set! set-car! set-cdr! sin sqrt string string->list string->number string->symbol string-append string-ci<=? string-ci<? string-ci=? string-ci>=? string-ci>? string-copy string-fill! string-length string-ref string-set! string<=? string<? string=? string>=? string>? string? substring symbol->string symbol? #t tan transcript-off transcript-on truncate values vector vector->list vector-fill! vector-length vector-ref vector-set! with-input-from-file with-output-to-file write write-char zero?\");\n    var indentKeys = makeKeywords(\"define let letrec let* lambda define-macro defmacro let-syntax letrec-syntax let-values let*-values define-syntax syntax-rules define-values when unless\");\n\n    function stateStack(indent, type, prev) {\n      // represents a state stack object\n      this.indent = indent;\n      this.type = type;\n      this.prev = prev;\n    }\n\n    function pushStack(state, indent, type) {\n      state.indentStack = new stateStack(indent, type, state.indentStack);\n    }\n\n    function popStack(state) {\n      state.indentStack = state.indentStack.prev;\n    }\n\n    var binaryMatcher = new RegExp(/^(?:[-+]i|[-+][01]+#*(?:\\/[01]+#*)?i|[-+]?[01]+#*(?:\\/[01]+#*)?@[-+]?[01]+#*(?:\\/[01]+#*)?|[-+]?[01]+#*(?:\\/[01]+#*)?[-+](?:[01]+#*(?:\\/[01]+#*)?)?i|[-+]?[01]+#*(?:\\/[01]+#*)?)(?=[()\\s;\"]|$)/i);\n    var octalMatcher = new RegExp(/^(?:[-+]i|[-+][0-7]+#*(?:\\/[0-7]+#*)?i|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?@[-+]?[0-7]+#*(?:\\/[0-7]+#*)?|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?[-+](?:[0-7]+#*(?:\\/[0-7]+#*)?)?i|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?)(?=[()\\s;\"]|$)/i);\n    var hexMatcher = new RegExp(/^(?:[-+]i|[-+][\\da-f]+#*(?:\\/[\\da-f]+#*)?i|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?@[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?[-+](?:[\\da-f]+#*(?:\\/[\\da-f]+#*)?)?i|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?)(?=[()\\s;\"]|$)/i);\n    var decimalMatcher = new RegExp(/^(?:[-+]i|[-+](?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)i|[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)@[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)|[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)[-+](?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)?i|(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*))(?=[()\\s;\"]|$)/i);\n\n    function isBinaryNumber(stream) {\n      return stream.match(binaryMatcher);\n    }\n\n    function isOctalNumber(stream) {\n      return stream.match(octalMatcher);\n    }\n\n    function isDecimalNumber(stream, backup) {\n      if (backup === true) {\n        stream.backUp(1);\n      }\n\n      return stream.match(decimalMatcher);\n    }\n\n    function isHexNumber(stream) {\n      return stream.match(hexMatcher);\n    }\n\n    function processEscapedSequence(stream, options) {\n      var next,\n          escaped = false;\n\n      while ((next = stream.next()) != null) {\n        if (next == options.token && !escaped) {\n          options.state.mode = false;\n          break;\n        }\n\n        escaped = !escaped && next == \"\\\\\";\n      }\n    }\n\n    return {\n      startState: function startState() {\n        return {\n          indentStack: null,\n          indentation: 0,\n          mode: false,\n          sExprComment: false,\n          sExprQuote: false\n        };\n      },\n      token: function token(stream, state) {\n        if (state.indentStack == null && stream.sol()) {\n          // update indentation, but only if indentStack is empty\n          state.indentation = stream.indentation();\n        } // skip spaces\n\n\n        if (stream.eatSpace()) {\n          return null;\n        }\n\n        var returnType = null;\n\n        switch (state.mode) {\n          case \"string\":\n            // multi-line string parsing mode\n            processEscapedSequence(stream, {\n              token: \"\\\"\",\n              state: state\n            });\n            returnType = STRING; // continue on in scheme-string mode\n\n            break;\n\n          case \"symbol\":\n            // escape symbol\n            processEscapedSequence(stream, {\n              token: \"|\",\n              state: state\n            });\n            returnType = SYMBOL; // continue on in scheme-symbol mode\n\n            break;\n\n          case \"comment\":\n            // comment parsing mode\n            var next,\n                maybeEnd = false;\n\n            while ((next = stream.next()) != null) {\n              if (next == \"#\" && maybeEnd) {\n                state.mode = false;\n                break;\n              }\n\n              maybeEnd = next == \"|\";\n            }\n\n            returnType = COMMENT;\n            break;\n\n          case \"s-expr-comment\":\n            // s-expr commenting mode\n            state.mode = false;\n\n            if (stream.peek() == \"(\" || stream.peek() == \"[\") {\n              // actually start scheme s-expr commenting mode\n              state.sExprComment = 0;\n            } else {\n              // if not we just comment the entire of the next token\n              stream.eatWhile(/[^\\s\\(\\)\\[\\]]/); // eat symbol atom\n\n              returnType = COMMENT;\n              break;\n            }\n\n          default:\n            // default parsing mode\n            var ch = stream.next();\n\n            if (ch == \"\\\"\") {\n              state.mode = \"string\";\n              returnType = STRING;\n            } else if (ch == \"'\") {\n              if (stream.peek() == \"(\" || stream.peek() == \"[\") {\n                if (typeof state.sExprQuote != \"number\") {\n                  state.sExprQuote = 0;\n                } // else already in a quoted expression\n\n\n                returnType = ATOM;\n              } else {\n                stream.eatWhile(/[\\w_\\-!$%&*+\\.\\/:<=>?@\\^~]/);\n                returnType = ATOM;\n              }\n            } else if (ch == '|') {\n              state.mode = \"symbol\";\n              returnType = SYMBOL;\n            } else if (ch == '#') {\n              if (stream.eat(\"|\")) {\n                // Multi-line comment\n                state.mode = \"comment\"; // toggle to comment mode\n\n                returnType = COMMENT;\n              } else if (stream.eat(/[tf]/i)) {\n                // #t/#f (atom)\n                returnType = ATOM;\n              } else if (stream.eat(';')) {\n                // S-Expr comment\n                state.mode = \"s-expr-comment\";\n                returnType = COMMENT;\n              } else {\n                var numTest = null,\n                    hasExactness = false,\n                    hasRadix = true;\n\n                if (stream.eat(/[ei]/i)) {\n                  hasExactness = true;\n                } else {\n                  stream.backUp(1); // must be radix specifier\n                }\n\n                if (stream.match(/^#b/i)) {\n                  numTest = isBinaryNumber;\n                } else if (stream.match(/^#o/i)) {\n                  numTest = isOctalNumber;\n                } else if (stream.match(/^#x/i)) {\n                  numTest = isHexNumber;\n                } else if (stream.match(/^#d/i)) {\n                  numTest = isDecimalNumber;\n                } else if (stream.match(/^[-+0-9.]/, false)) {\n                  hasRadix = false;\n                  numTest = isDecimalNumber; // re-consume the initial # if all matches failed\n                } else if (!hasExactness) {\n                  stream.eat('#');\n                }\n\n                if (numTest != null) {\n                  if (hasRadix && !hasExactness) {\n                    // consume optional exactness after radix\n                    stream.match(/^#[ei]/i);\n                  }\n\n                  if (numTest(stream)) returnType = NUMBER;\n                }\n              }\n            } else if (/^[-+0-9.]/.test(ch) && isDecimalNumber(stream, true)) {\n              // match non-prefixed number, must be decimal\n              returnType = NUMBER;\n            } else if (ch == \";\") {\n              // comment\n              stream.skipToEnd(); // rest of the line is a comment\n\n              returnType = COMMENT;\n            } else if (ch == \"(\" || ch == \"[\") {\n              var keyWord = '';\n              var indentTemp = stream.column(),\n                  letter;\n              /**\n              Either\n              (indent-word ..\n              (non-indent-word ..\n              (;something else, bracket, etc.\n              */\n\n              while ((letter = stream.eat(/[^\\s\\(\\[\\;\\)\\]]/)) != null) {\n                keyWord += letter;\n              }\n\n              if (keyWord.length > 0 && indentKeys.propertyIsEnumerable(keyWord)) {\n                // indent-word\n                pushStack(state, indentTemp + INDENT_WORD_SKIP, ch);\n              } else {\n                // non-indent word\n                // we continue eating the spaces\n                stream.eatSpace();\n\n                if (stream.eol() || stream.peek() == \";\") {\n                  // nothing significant after\n                  // we restart indentation 1 space after\n                  pushStack(state, indentTemp + 1, ch);\n                } else {\n                  pushStack(state, indentTemp + stream.current().length, ch); // else we match\n                }\n              }\n\n              stream.backUp(stream.current().length - 1); // undo all the eating\n\n              if (typeof state.sExprComment == \"number\") state.sExprComment++;\n              if (typeof state.sExprQuote == \"number\") state.sExprQuote++;\n              returnType = BRACKET;\n            } else if (ch == \")\" || ch == \"]\") {\n              returnType = BRACKET;\n\n              if (state.indentStack != null && state.indentStack.type == (ch == \")\" ? \"(\" : \"[\")) {\n                popStack(state);\n\n                if (typeof state.sExprComment == \"number\") {\n                  if (--state.sExprComment == 0) {\n                    returnType = COMMENT; // final closing bracket\n\n                    state.sExprComment = false; // turn off s-expr commenting mode\n                  }\n                }\n\n                if (typeof state.sExprQuote == \"number\") {\n                  if (--state.sExprQuote == 0) {\n                    returnType = ATOM; // final closing bracket\n\n                    state.sExprQuote = false; // turn off s-expr quote mode\n                  }\n                }\n              }\n            } else {\n              stream.eatWhile(/[\\w_\\-!$%&*+\\.\\/:<=>?@\\^~]/);\n\n              if (keywords && keywords.propertyIsEnumerable(stream.current())) {\n                returnType = BUILTIN;\n              } else returnType = \"variable\";\n            }\n\n        }\n\n        return typeof state.sExprComment == \"number\" ? COMMENT : typeof state.sExprQuote == \"number\" ? ATOM : returnType;\n      },\n      indent: function indent(state) {\n        if (state.indentStack == null) return state.indentation;\n        return state.indentStack.indent;\n      },\n      fold: \"brace-paren\",\n      closeBrackets: {\n        pairs: \"()[]{}\\\"\\\"\"\n      },\n      lineComment: \";;\"\n    };\n  });\n  CodeMirror.defineMIME(\"text/x-scheme\", \"scheme\");\n});\n\n/***/ })\n\n}]);","inputSourceMap":{"version":3,"sources":["/mnt/Datengrab/python/Zero-tier/frontend/node_modules/codemirror/mode/scheme/scheme.js"],"names":["mod","require","CodeMirror","defineMode","BUILTIN","COMMENT","STRING","SYMBOL","ATOM","NUMBER","BRACKET","INDENT_WORD_SKIP","makeKeywords","str","obj","words","split","i","length","keywords","indentKeys","stateStack","indent","type","prev","pushStack","state","indentStack","popStack","binaryMatcher","RegExp","octalMatcher","hexMatcher","decimalMatcher","isBinaryNumber","stream","match","isOctalNumber","isDecimalNumber","backup","backUp","isHexNumber","processEscapedSequence","options","next","escaped","token","mode","startState","indentation","sExprComment","sExprQuote","sol","eatSpace","returnType","maybeEnd","peek","eatWhile","ch","eat","numTest","hasExactness","hasRadix","test","skipToEnd","keyWord","indentTemp","column","letter","propertyIsEnumerable","eol","current","fold","closeBrackets","pairs","lineComment","defineMIME"],"mappings":";;;;;AAAA;AACA;;AAEA;AACA;AACA;AACA;AAEA,CAAC,UAASA,GAAT,EAAc;EACb,IAAI,IAAJ,EAA6D;IAC3DA,GAAG,CAACC,mBAAO,CAAC,GAAD,CAAR,CAAH,CADF,KAEK,EAGH;AACH,CAPD,EAOG,UAASC,UAAT,EAAqB;EACxB;;EAEAA,UAAU,CAACC,UAAX,CAAsB,QAAtB,EAAgC,YAAY;IACxC,IAAIC,OAAO,GAAG,SAAd;IAAA,IAAyBC,OAAO,GAAG,SAAnC;IAAA,IAA8CC,MAAM,GAAG,QAAvD;IAAA,IACIC,MAAM,GAAG,QADb;IAAA,IACuBC,IAAI,GAAG,MAD9B;IAAA,IACsCC,MAAM,GAAG,QAD/C;IAAA,IACyDC,OAAO,GAAG,SADnE;IAEA,IAAIC,gBAAgB,GAAG,CAAvB;;IAEA,SAASC,YAAT,CAAsBC,GAAtB,EAA2B;MACvB,IAAIC,GAAG,GAAG,EAAV;MAAA,IAAcC,KAAK,GAAGF,GAAG,CAACG,KAAJ,CAAU,GAAV,CAAtB;;MACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,KAAK,CAACG,MAA1B,EAAkC,EAAED,CAApC;QAAuCH,GAAG,CAACC,KAAK,CAACE,CAAD,CAAN,CAAH,GAAgB,IAAhB;MAAvC;;MACA,OAAOH,GAAP;IACH;;IAED,IAAIK,QAAQ,GAAGP,YAAY,CAAC,opEAAD,CAA3B;IACA,IAAIQ,UAAU,GAAGR,YAAY,CAAC,0JAAD,CAA7B;;IAEA,SAASS,UAAT,CAAoBC,MAApB,EAA4BC,IAA5B,EAAkCC,IAAlC,EAAwC;MAAE;MACtC,KAAKF,MAAL,GAAcA,MAAd;MACA,KAAKC,IAAL,GAAYA,IAAZ;MACA,KAAKC,IAAL,GAAYA,IAAZ;IACH;;IAED,SAASC,SAAT,CAAmBC,KAAnB,EAA0BJ,MAA1B,EAAkCC,IAAlC,EAAwC;MACpCG,KAAK,CAACC,WAAN,GAAoB,IAAIN,UAAJ,CAAeC,MAAf,EAAuBC,IAAvB,EAA6BG,KAAK,CAACC,WAAnC,CAApB;IACH;;IAED,SAASC,QAAT,CAAkBF,KAAlB,EAAyB;MACrBA,KAAK,CAACC,WAAN,GAAoBD,KAAK,CAACC,WAAN,CAAkBH,IAAtC;IACH;;IAED,IAAIK,aAAa,GAAG,IAAIC,MAAJ,CAAW,iMAAX,CAApB;IACA,IAAIC,YAAY,GAAG,IAAID,MAAJ,CAAW,6MAAX,CAAnB;IACA,IAAIE,UAAU,GAAG,IAAIF,MAAJ,CAAW,qOAAX,CAAjB;IACA,IAAIG,cAAc,GAAG,IAAIH,MAAJ,CAAW,8gBAAX,CAArB;;IAEA,SAASI,cAAT,CAAyBC,MAAzB,EAAiC;MAC7B,OAAOA,MAAM,CAACC,KAAP,CAAaP,aAAb,CAAP;IACH;;IAED,SAASQ,aAAT,CAAwBF,MAAxB,EAAgC;MAC5B,OAAOA,MAAM,CAACC,KAAP,CAAaL,YAAb,CAAP;IACH;;IAED,SAASO,eAAT,CAA0BH,MAA1B,EAAkCI,MAAlC,EAA0C;MACtC,IAAIA,MAAM,KAAK,IAAf,EAAqB;QACjBJ,MAAM,CAACK,MAAP,CAAc,CAAd;MACH;;MACD,OAAOL,MAAM,CAACC,KAAP,CAAaH,cAAb,CAAP;IACH;;IAED,SAASQ,WAAT,CAAsBN,MAAtB,EAA8B;MAC1B,OAAOA,MAAM,CAACC,KAAP,CAAaJ,UAAb,CAAP;IACH;;IAED,SAASU,sBAAT,CAAgCP,MAAhC,EAAwCQ,OAAxC,EAAiD;MAC7C,IAAIC,IAAJ;MAAA,IAAUC,OAAO,GAAG,KAApB;;MACA,OAAO,CAACD,IAAI,GAAGT,MAAM,CAACS,IAAP,EAAR,KAA0B,IAAjC,EAAuC;QACnC,IAAIA,IAAI,IAAID,OAAO,CAACG,KAAhB,IAAyB,CAACD,OAA9B,EAAuC;UAEnCF,OAAO,CAACjB,KAAR,CAAcqB,IAAd,GAAqB,KAArB;UACA;QACH;;QACDF,OAAO,GAAG,CAACA,OAAD,IAAYD,IAAI,IAAI,IAA9B;MACH;IACJ;;IAED,OAAO;MACHI,UAAU,EAAE,sBAAY;QACpB,OAAO;UACHrB,WAAW,EAAE,IADV;UAEHsB,WAAW,EAAE,CAFV;UAGHF,IAAI,EAAE,KAHH;UAIHG,YAAY,EAAE,KAJX;UAKHC,UAAU,EAAE;QALT,CAAP;MAOH,CATE;MAWHL,KAAK,EAAE,eAAUX,MAAV,EAAkBT,KAAlB,EAAyB;QAC5B,IAAIA,KAAK,CAACC,WAAN,IAAqB,IAArB,IAA6BQ,MAAM,CAACiB,GAAP,EAAjC,EAA+C;UAC3C;UACA1B,KAAK,CAACuB,WAAN,GAAoBd,MAAM,CAACc,WAAP,EAApB;QACH,CAJ2B,CAM5B;;;QACA,IAAId,MAAM,CAACkB,QAAP,EAAJ,EAAuB;UACnB,OAAO,IAAP;QACH;;QACD,IAAIC,UAAU,GAAG,IAAjB;;QAEA,QAAO5B,KAAK,CAACqB,IAAb;UACI,KAAK,QAAL;YAAe;YACXL,sBAAsB,CAACP,MAAD,EAAS;cAC3BW,KAAK,EAAE,IADoB;cAE3BpB,KAAK,EAAEA;YAFoB,CAAT,CAAtB;YAIA4B,UAAU,GAAGhD,MAAb,CALJ,CAKyB;;YACrB;;UACJ,KAAK,QAAL;YAAe;YACXoC,sBAAsB,CAACP,MAAD,EAAS;cAC3BW,KAAK,EAAE,GADoB;cAE3BpB,KAAK,EAAEA;YAFoB,CAAT,CAAtB;YAIA4B,UAAU,GAAG/C,MAAb,CALJ,CAKyB;;YACrB;;UACJ,KAAK,SAAL;YAAgB;YACZ,IAAIqC,IAAJ;YAAA,IAAUW,QAAQ,GAAG,KAArB;;YACA,OAAO,CAACX,IAAI,GAAGT,MAAM,CAACS,IAAP,EAAR,KAA0B,IAAjC,EAAuC;cACnC,IAAIA,IAAI,IAAI,GAAR,IAAeW,QAAnB,EAA6B;gBAEzB7B,KAAK,CAACqB,IAAN,GAAa,KAAb;gBACA;cACH;;cACDQ,QAAQ,GAAIX,IAAI,IAAI,GAApB;YACH;;YACDU,UAAU,GAAGjD,OAAb;YACA;;UACJ,KAAK,gBAAL;YAAuB;YACnBqB,KAAK,CAACqB,IAAN,GAAa,KAAb;;YACA,IAAGZ,MAAM,CAACqB,IAAP,MAAiB,GAAjB,IAAwBrB,MAAM,CAACqB,IAAP,MAAiB,GAA5C,EAAgD;cAC5C;cACA9B,KAAK,CAACwB,YAAN,GAAqB,CAArB;YACH,CAHD,MAGK;cACD;cACAf,MAAM,CAACsB,QAAP,CAAgB,eAAhB,EAFC,CAEiC;;cAClCH,UAAU,GAAGjD,OAAb;cACA;YACH;;UACL;YAAS;YACL,IAAIqD,EAAE,GAAGvB,MAAM,CAACS,IAAP,EAAT;;YAEA,IAAIc,EAAE,IAAI,IAAV,EAAgB;cACZhC,KAAK,CAACqB,IAAN,GAAa,QAAb;cACAO,UAAU,GAAGhD,MAAb;YAEH,CAJD,MAIO,IAAIoD,EAAE,IAAI,GAAV,EAAe;cAClB,IAAIvB,MAAM,CAACqB,IAAP,MAAiB,GAAjB,IAAwBrB,MAAM,CAACqB,IAAP,MAAiB,GAA7C,EAAiD;gBAC7C,IAAI,OAAO9B,KAAK,CAACyB,UAAb,IAA2B,QAA/B,EAAyC;kBACrCzB,KAAK,CAACyB,UAAN,GAAmB,CAAnB;gBACH,CAH4C,CAG3C;;;gBACFG,UAAU,GAAG9C,IAAb;cACH,CALD,MAKO;gBACH2B,MAAM,CAACsB,QAAP,CAAgB,4BAAhB;gBACAH,UAAU,GAAG9C,IAAb;cACH;YACJ,CAVM,MAUA,IAAIkD,EAAE,IAAI,GAAV,EAAe;cAClBhC,KAAK,CAACqB,IAAN,GAAa,QAAb;cACAO,UAAU,GAAG/C,MAAb;YACH,CAHM,MAGA,IAAImD,EAAE,IAAI,GAAV,EAAe;cAClB,IAAIvB,MAAM,CAACwB,GAAP,CAAW,GAAX,CAAJ,EAAqB;gBAAqB;gBACtCjC,KAAK,CAACqB,IAAN,GAAa,SAAb,CADiB,CACO;;gBACxBO,UAAU,GAAGjD,OAAb;cACH,CAHD,MAGO,IAAI8B,MAAM,CAACwB,GAAP,CAAW,OAAX,CAAJ,EAAyB;gBAAa;gBACzCL,UAAU,GAAG9C,IAAb;cACH,CAFM,MAEA,IAAI2B,MAAM,CAACwB,GAAP,CAAW,GAAX,CAAJ,EAAqB;gBAAiB;gBACzCjC,KAAK,CAACqB,IAAN,GAAa,gBAAb;gBACAO,UAAU,GAAGjD,OAAb;cACH,CAHM,MAGA;gBACH,IAAIuD,OAAO,GAAG,IAAd;gBAAA,IAAoBC,YAAY,GAAG,KAAnC;gBAAA,IAA0CC,QAAQ,GAAG,IAArD;;gBACA,IAAI3B,MAAM,CAACwB,GAAP,CAAW,OAAX,CAAJ,EAAyB;kBACrBE,YAAY,GAAG,IAAf;gBACH,CAFD,MAEO;kBACH1B,MAAM,CAACK,MAAP,CAAc,CAAd,EADG,CACqB;gBAC3B;;gBACD,IAAIL,MAAM,CAACC,KAAP,CAAa,MAAb,CAAJ,EAA0B;kBACtBwB,OAAO,GAAG1B,cAAV;gBACH,CAFD,MAEO,IAAIC,MAAM,CAACC,KAAP,CAAa,MAAb,CAAJ,EAA0B;kBAC7BwB,OAAO,GAAGvB,aAAV;gBACH,CAFM,MAEA,IAAIF,MAAM,CAACC,KAAP,CAAa,MAAb,CAAJ,EAA0B;kBAC7BwB,OAAO,GAAGnB,WAAV;gBACH,CAFM,MAEA,IAAIN,MAAM,CAACC,KAAP,CAAa,MAAb,CAAJ,EAA0B;kBAC7BwB,OAAO,GAAGtB,eAAV;gBACH,CAFM,MAEA,IAAIH,MAAM,CAACC,KAAP,CAAa,WAAb,EAA0B,KAA1B,CAAJ,EAAsC;kBACzC0B,QAAQ,GAAG,KAAX;kBACAF,OAAO,GAAGtB,eAAV,CAFyC,CAG7C;gBACC,CAJM,MAIA,IAAI,CAACuB,YAAL,EAAmB;kBACtB1B,MAAM,CAACwB,GAAP,CAAW,GAAX;gBACH;;gBACD,IAAIC,OAAO,IAAI,IAAf,EAAqB;kBACjB,IAAIE,QAAQ,IAAI,CAACD,YAAjB,EAA+B;oBAC3B;oBACA1B,MAAM,CAACC,KAAP,CAAa,SAAb;kBACH;;kBACD,IAAIwB,OAAO,CAACzB,MAAD,CAAX,EACImB,UAAU,GAAG7C,MAAb;gBACP;cACJ;YACJ,CAxCM,MAwCA,IAAI,YAAYsD,IAAZ,CAAiBL,EAAjB,KAAwBpB,eAAe,CAACH,MAAD,EAAS,IAAT,CAA3C,EAA2D;cAAE;cAChEmB,UAAU,GAAG7C,MAAb;YACH,CAFM,MAEA,IAAIiD,EAAE,IAAI,GAAV,EAAe;cAAE;cACpBvB,MAAM,CAAC6B,SAAP,GADkB,CACE;;cACpBV,UAAU,GAAGjD,OAAb;YACH,CAHM,MAGA,IAAIqD,EAAE,IAAI,GAAN,IAAaA,EAAE,IAAI,GAAvB,EAA4B;cACjC,IAAIO,OAAO,GAAG,EAAd;cAAkB,IAAIC,UAAU,GAAG/B,MAAM,CAACgC,MAAP,EAAjB;cAAA,IAAkCC,MAAlC;cAChB;AACxB;AACA;AACA;AACA;AACA;;cAEwB,OAAO,CAACA,MAAM,GAAGjC,MAAM,CAACwB,GAAP,CAAW,iBAAX,CAAV,KAA4C,IAAnD,EAAyD;gBACrDM,OAAO,IAAIG,MAAX;cACH;;cAED,IAAIH,OAAO,CAAC/C,MAAR,GAAiB,CAAjB,IAAsBE,UAAU,CAACiD,oBAAX,CAAgCJ,OAAhC,CAA1B,EAAoE;gBAAE;gBAElExC,SAAS,CAACC,KAAD,EAAQwC,UAAU,GAAGvD,gBAArB,EAAuC+C,EAAvC,CAAT;cACH,CAHD,MAGO;gBAAE;gBACL;gBACAvB,MAAM,CAACkB,QAAP;;gBACA,IAAIlB,MAAM,CAACmC,GAAP,MAAgBnC,MAAM,CAACqB,IAAP,MAAiB,GAArC,EAA0C;kBACtC;kBACA;kBACA/B,SAAS,CAACC,KAAD,EAAQwC,UAAU,GAAG,CAArB,EAAwBR,EAAxB,CAAT;gBACH,CAJD,MAIO;kBACHjC,SAAS,CAACC,KAAD,EAAQwC,UAAU,GAAG/B,MAAM,CAACoC,OAAP,GAAiBrD,MAAtC,EAA8CwC,EAA9C,CAAT,CADG,CACyD;gBAC/D;cACJ;;cACDvB,MAAM,CAACK,MAAP,CAAcL,MAAM,CAACoC,OAAP,GAAiBrD,MAAjB,GAA0B,CAAxC,EA3B+B,CA2Ba;;cAE5C,IAAG,OAAOQ,KAAK,CAACwB,YAAb,IAA6B,QAAhC,EAA0CxB,KAAK,CAACwB,YAAN;cAC1C,IAAG,OAAOxB,KAAK,CAACyB,UAAb,IAA2B,QAA9B,EAAwCzB,KAAK,CAACyB,UAAN;cAExCG,UAAU,GAAG5C,OAAb;YACH,CAjCM,MAiCA,IAAIgD,EAAE,IAAI,GAAN,IAAaA,EAAE,IAAI,GAAvB,EAA4B;cAC/BJ,UAAU,GAAG5C,OAAb;;cACA,IAAIgB,KAAK,CAACC,WAAN,IAAqB,IAArB,IAA6BD,KAAK,CAACC,WAAN,CAAkBJ,IAAlB,KAA2BmC,EAAE,IAAI,GAAN,GAAY,GAAZ,GAAkB,GAA7C,CAAjC,EAAoF;gBAChF9B,QAAQ,CAACF,KAAD,CAAR;;gBAEA,IAAG,OAAOA,KAAK,CAACwB,YAAb,IAA6B,QAAhC,EAAyC;kBACrC,IAAG,EAAExB,KAAK,CAACwB,YAAR,IAAwB,CAA3B,EAA6B;oBACzBI,UAAU,GAAGjD,OAAb,CADyB,CACH;;oBACtBqB,KAAK,CAACwB,YAAN,GAAqB,KAArB,CAFyB,CAEG;kBAC/B;gBACJ;;gBACD,IAAG,OAAOxB,KAAK,CAACyB,UAAb,IAA2B,QAA9B,EAAuC;kBACnC,IAAG,EAAEzB,KAAK,CAACyB,UAAR,IAAsB,CAAzB,EAA2B;oBACvBG,UAAU,GAAG9C,IAAb,CADuB,CACJ;;oBACnBkB,KAAK,CAACyB,UAAN,GAAmB,KAAnB,CAFuB,CAEG;kBAC7B;gBACJ;cACJ;YACJ,CAlBM,MAkBA;cACHhB,MAAM,CAACsB,QAAP,CAAgB,4BAAhB;;cAEA,IAAItC,QAAQ,IAAIA,QAAQ,CAACkD,oBAAT,CAA8BlC,MAAM,CAACoC,OAAP,EAA9B,CAAhB,EAAiE;gBAC7DjB,UAAU,GAAGlD,OAAb;cACH,CAFD,MAEOkD,UAAU,GAAG,UAAb;YACV;;QAhKT;;QAkKA,OAAQ,OAAO5B,KAAK,CAACwB,YAAb,IAA6B,QAA9B,GAA0C7C,OAA1C,GAAsD,OAAOqB,KAAK,CAACyB,UAAb,IAA2B,QAA5B,GAAwC3C,IAAxC,GAA+C8C,UAA3G;MACH,CA1LE;MA4LHhC,MAAM,EAAE,gBAAUI,KAAV,EAAiB;QACrB,IAAIA,KAAK,CAACC,WAAN,IAAqB,IAAzB,EAA+B,OAAOD,KAAK,CAACuB,WAAb;QAC/B,OAAOvB,KAAK,CAACC,WAAN,CAAkBL,MAAzB;MACH,CA/LE;MAiMHkD,IAAI,EAAE,aAjMH;MAkMHC,aAAa,EAAE;QAACC,KAAK,EAAE;MAAR,CAlMZ;MAmMHC,WAAW,EAAE;IAnMV,CAAP;EAqMH,CArQD;EAuQAzE,UAAU,CAAC0E,UAAX,CAAsB,eAAtB,EAAuC,QAAvC;AAEC,CAnRD,E","file":"x","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n/**\n * Author: Koh Zi Han, based on implementation by Koh Zi Chun\n * Improved by: Jakub T. Jankiewicz\n */\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"scheme\", function () {\n    var BUILTIN = \"builtin\", COMMENT = \"comment\", STRING = \"string\",\n        SYMBOL = \"symbol\", ATOM = \"atom\", NUMBER = \"number\", BRACKET = \"bracket\";\n    var INDENT_WORD_SKIP = 2;\n\n    function makeKeywords(str) {\n        var obj = {}, words = str.split(\" \");\n        for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n        return obj;\n    }\n\n    var keywords = makeKeywords(\"λ case-lambda call/cc class cond-expand define-class define-values exit-handler field import inherit init-field interface let*-values let-values let/ec mixin opt-lambda override protect provide public rename require require-for-syntax syntax syntax-case syntax-error unit/sig unless when with-syntax and begin call-with-current-continuation call-with-input-file call-with-output-file case cond define define-syntax define-macro defmacro delay do dynamic-wind else for-each if lambda let let* let-syntax letrec letrec-syntax map or syntax-rules abs acos angle append apply asin assoc assq assv atan boolean? caar cadr call-with-input-file call-with-output-file call-with-values car cdddar cddddr cdr ceiling char->integer char-alphabetic? char-ci<=? char-ci<? char-ci=? char-ci>=? char-ci>? char-downcase char-lower-case? char-numeric? char-ready? char-upcase char-upper-case? char-whitespace? char<=? char<? char=? char>=? char>? char? close-input-port close-output-port complex? cons cos current-input-port current-output-port denominator display eof-object? eq? equal? eqv? eval even? exact->inexact exact? exp expt #f floor force gcd imag-part inexact->exact inexact? input-port? integer->char integer? interaction-environment lcm length list list->string list->vector list-ref list-tail list? load log magnitude make-polar make-rectangular make-string make-vector max member memq memv min modulo negative? newline not null-environment null? number->string number? numerator odd? open-input-file open-output-file output-port? pair? peek-char port? positive? procedure? quasiquote quote quotient rational? rationalize read read-char real-part real? remainder reverse round scheme-report-environment set! set-car! set-cdr! sin sqrt string string->list string->number string->symbol string-append string-ci<=? string-ci<? string-ci=? string-ci>=? string-ci>? string-copy string-fill! string-length string-ref string-set! string<=? string<? string=? string>=? string>? string? substring symbol->string symbol? #t tan transcript-off transcript-on truncate values vector vector->list vector-fill! vector-length vector-ref vector-set! with-input-from-file with-output-to-file write write-char zero?\");\n    var indentKeys = makeKeywords(\"define let letrec let* lambda define-macro defmacro let-syntax letrec-syntax let-values let*-values define-syntax syntax-rules define-values when unless\");\n\n    function stateStack(indent, type, prev) { // represents a state stack object\n        this.indent = indent;\n        this.type = type;\n        this.prev = prev;\n    }\n\n    function pushStack(state, indent, type) {\n        state.indentStack = new stateStack(indent, type, state.indentStack);\n    }\n\n    function popStack(state) {\n        state.indentStack = state.indentStack.prev;\n    }\n\n    var binaryMatcher = new RegExp(/^(?:[-+]i|[-+][01]+#*(?:\\/[01]+#*)?i|[-+]?[01]+#*(?:\\/[01]+#*)?@[-+]?[01]+#*(?:\\/[01]+#*)?|[-+]?[01]+#*(?:\\/[01]+#*)?[-+](?:[01]+#*(?:\\/[01]+#*)?)?i|[-+]?[01]+#*(?:\\/[01]+#*)?)(?=[()\\s;\"]|$)/i);\n    var octalMatcher = new RegExp(/^(?:[-+]i|[-+][0-7]+#*(?:\\/[0-7]+#*)?i|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?@[-+]?[0-7]+#*(?:\\/[0-7]+#*)?|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?[-+](?:[0-7]+#*(?:\\/[0-7]+#*)?)?i|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?)(?=[()\\s;\"]|$)/i);\n    var hexMatcher = new RegExp(/^(?:[-+]i|[-+][\\da-f]+#*(?:\\/[\\da-f]+#*)?i|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?@[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?[-+](?:[\\da-f]+#*(?:\\/[\\da-f]+#*)?)?i|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?)(?=[()\\s;\"]|$)/i);\n    var decimalMatcher = new RegExp(/^(?:[-+]i|[-+](?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)i|[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)@[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)|[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)[-+](?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)?i|(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*))(?=[()\\s;\"]|$)/i);\n\n    function isBinaryNumber (stream) {\n        return stream.match(binaryMatcher);\n    }\n\n    function isOctalNumber (stream) {\n        return stream.match(octalMatcher);\n    }\n\n    function isDecimalNumber (stream, backup) {\n        if (backup === true) {\n            stream.backUp(1);\n        }\n        return stream.match(decimalMatcher);\n    }\n\n    function isHexNumber (stream) {\n        return stream.match(hexMatcher);\n    }\n\n    function processEscapedSequence(stream, options) {\n        var next, escaped = false;\n        while ((next = stream.next()) != null) {\n            if (next == options.token && !escaped) {\n\n                options.state.mode = false;\n                break;\n            }\n            escaped = !escaped && next == \"\\\\\";\n        }\n    }\n\n    return {\n        startState: function () {\n            return {\n                indentStack: null,\n                indentation: 0,\n                mode: false,\n                sExprComment: false,\n                sExprQuote: false\n            };\n        },\n\n        token: function (stream, state) {\n            if (state.indentStack == null && stream.sol()) {\n                // update indentation, but only if indentStack is empty\n                state.indentation = stream.indentation();\n            }\n\n            // skip spaces\n            if (stream.eatSpace()) {\n                return null;\n            }\n            var returnType = null;\n\n            switch(state.mode){\n                case \"string\": // multi-line string parsing mode\n                    processEscapedSequence(stream, {\n                        token: \"\\\"\",\n                        state: state\n                    });\n                    returnType = STRING; // continue on in scheme-string mode\n                    break;\n                case \"symbol\": // escape symbol\n                    processEscapedSequence(stream, {\n                        token: \"|\",\n                        state: state\n                    });\n                    returnType = SYMBOL; // continue on in scheme-symbol mode\n                    break;\n                case \"comment\": // comment parsing mode\n                    var next, maybeEnd = false;\n                    while ((next = stream.next()) != null) {\n                        if (next == \"#\" && maybeEnd) {\n\n                            state.mode = false;\n                            break;\n                        }\n                        maybeEnd = (next == \"|\");\n                    }\n                    returnType = COMMENT;\n                    break;\n                case \"s-expr-comment\": // s-expr commenting mode\n                    state.mode = false;\n                    if(stream.peek() == \"(\" || stream.peek() == \"[\"){\n                        // actually start scheme s-expr commenting mode\n                        state.sExprComment = 0;\n                    }else{\n                        // if not we just comment the entire of the next token\n                        stream.eatWhile(/[^\\s\\(\\)\\[\\]]/); // eat symbol atom\n                        returnType = COMMENT;\n                        break;\n                    }\n                default: // default parsing mode\n                    var ch = stream.next();\n\n                    if (ch == \"\\\"\") {\n                        state.mode = \"string\";\n                        returnType = STRING;\n\n                    } else if (ch == \"'\") {\n                        if (stream.peek() == \"(\" || stream.peek() == \"[\"){\n                            if (typeof state.sExprQuote != \"number\") {\n                                state.sExprQuote = 0;\n                            } // else already in a quoted expression\n                            returnType = ATOM;\n                        } else {\n                            stream.eatWhile(/[\\w_\\-!$%&*+\\.\\/:<=>?@\\^~]/);\n                            returnType = ATOM;\n                        }\n                    } else if (ch == '|') {\n                        state.mode = \"symbol\";\n                        returnType = SYMBOL;\n                    } else if (ch == '#') {\n                        if (stream.eat(\"|\")) {                    // Multi-line comment\n                            state.mode = \"comment\"; // toggle to comment mode\n                            returnType = COMMENT;\n                        } else if (stream.eat(/[tf]/i)) {            // #t/#f (atom)\n                            returnType = ATOM;\n                        } else if (stream.eat(';')) {                // S-Expr comment\n                            state.mode = \"s-expr-comment\";\n                            returnType = COMMENT;\n                        } else {\n                            var numTest = null, hasExactness = false, hasRadix = true;\n                            if (stream.eat(/[ei]/i)) {\n                                hasExactness = true;\n                            } else {\n                                stream.backUp(1);       // must be radix specifier\n                            }\n                            if (stream.match(/^#b/i)) {\n                                numTest = isBinaryNumber;\n                            } else if (stream.match(/^#o/i)) {\n                                numTest = isOctalNumber;\n                            } else if (stream.match(/^#x/i)) {\n                                numTest = isHexNumber;\n                            } else if (stream.match(/^#d/i)) {\n                                numTest = isDecimalNumber;\n                            } else if (stream.match(/^[-+0-9.]/, false)) {\n                                hasRadix = false;\n                                numTest = isDecimalNumber;\n                            // re-consume the initial # if all matches failed\n                            } else if (!hasExactness) {\n                                stream.eat('#');\n                            }\n                            if (numTest != null) {\n                                if (hasRadix && !hasExactness) {\n                                    // consume optional exactness after radix\n                                    stream.match(/^#[ei]/i);\n                                }\n                                if (numTest(stream))\n                                    returnType = NUMBER;\n                            }\n                        }\n                    } else if (/^[-+0-9.]/.test(ch) && isDecimalNumber(stream, true)) { // match non-prefixed number, must be decimal\n                        returnType = NUMBER;\n                    } else if (ch == \";\") { // comment\n                        stream.skipToEnd(); // rest of the line is a comment\n                        returnType = COMMENT;\n                    } else if (ch == \"(\" || ch == \"[\") {\n                      var keyWord = ''; var indentTemp = stream.column(), letter;\n                        /**\n                        Either\n                        (indent-word ..\n                        (non-indent-word ..\n                        (;something else, bracket, etc.\n                        */\n\n                        while ((letter = stream.eat(/[^\\s\\(\\[\\;\\)\\]]/)) != null) {\n                            keyWord += letter;\n                        }\n\n                        if (keyWord.length > 0 && indentKeys.propertyIsEnumerable(keyWord)) { // indent-word\n\n                            pushStack(state, indentTemp + INDENT_WORD_SKIP, ch);\n                        } else { // non-indent word\n                            // we continue eating the spaces\n                            stream.eatSpace();\n                            if (stream.eol() || stream.peek() == \";\") {\n                                // nothing significant after\n                                // we restart indentation 1 space after\n                                pushStack(state, indentTemp + 1, ch);\n                            } else {\n                                pushStack(state, indentTemp + stream.current().length, ch); // else we match\n                            }\n                        }\n                        stream.backUp(stream.current().length - 1); // undo all the eating\n\n                        if(typeof state.sExprComment == \"number\") state.sExprComment++;\n                        if(typeof state.sExprQuote == \"number\") state.sExprQuote++;\n\n                        returnType = BRACKET;\n                    } else if (ch == \")\" || ch == \"]\") {\n                        returnType = BRACKET;\n                        if (state.indentStack != null && state.indentStack.type == (ch == \")\" ? \"(\" : \"[\")) {\n                            popStack(state);\n\n                            if(typeof state.sExprComment == \"number\"){\n                                if(--state.sExprComment == 0){\n                                    returnType = COMMENT; // final closing bracket\n                                    state.sExprComment = false; // turn off s-expr commenting mode\n                                }\n                            }\n                            if(typeof state.sExprQuote == \"number\"){\n                                if(--state.sExprQuote == 0){\n                                    returnType = ATOM; // final closing bracket\n                                    state.sExprQuote = false; // turn off s-expr quote mode\n                                }\n                            }\n                        }\n                    } else {\n                        stream.eatWhile(/[\\w_\\-!$%&*+\\.\\/:<=>?@\\^~]/);\n\n                        if (keywords && keywords.propertyIsEnumerable(stream.current())) {\n                            returnType = BUILTIN;\n                        } else returnType = \"variable\";\n                    }\n            }\n            return (typeof state.sExprComment == \"number\") ? COMMENT : ((typeof state.sExprQuote == \"number\") ? ATOM : returnType);\n        },\n\n        indent: function (state) {\n            if (state.indentStack == null) return state.indentation;\n            return state.indentStack.indent;\n        },\n\n        fold: \"brace-paren\",\n        closeBrackets: {pairs: \"()[]{}\\\"\\\"\"},\n        lineComment: \";;\"\n    };\n});\n\nCodeMirror.defineMIME(\"text/x-scheme\", \"scheme\");\n\n});\n"]}}