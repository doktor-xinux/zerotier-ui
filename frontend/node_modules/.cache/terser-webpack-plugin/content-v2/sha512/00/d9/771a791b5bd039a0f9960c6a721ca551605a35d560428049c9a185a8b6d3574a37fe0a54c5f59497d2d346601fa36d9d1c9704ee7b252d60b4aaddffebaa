{"code":"(this.webpackJsonpfrontend=this.webpackJsonpfrontend||[]).push([[77],{355:function(e,t,n){!function(e){\"use strict\";e.defineMode(\"oz\",(function(e){function t(e){return new RegExp(\"^((\"+e.join(\")|(\")+\"))\\\\b\")}var n=/[\\^@!\\|<>#~\\.\\*\\-\\+\\\\/,=]/,r=/(<-)|(:=)|(=<)|(>=)|(<=)|(<:)|(>:)|(=:)|(\\\\=)|(\\\\=:)|(!!)|(==)|(::)/,a=/(:::)|(\\.\\.\\.)|(=<:)|(>=:)/,o=[\"in\",\"then\",\"else\",\"of\",\"elseof\",\"elsecase\",\"elseif\",\"catch\",\"finally\",\"with\",\"require\",\"prepare\",\"import\",\"export\",\"define\",\"do\"],i=[\"end\"],c=t([\"true\",\"false\",\"nil\",\"unit\"]),u=t([\"andthen\",\"at\",\"attr\",\"declare\",\"feat\",\"from\",\"lex\",\"mod\",\"div\",\"mode\",\"orelse\",\"parser\",\"prod\",\"prop\",\"scanner\",\"self\",\"syn\",\"token\"]),f=t([\"local\",\"proc\",\"fun\",\"case\",\"class\",\"if\",\"cond\",\"or\",\"dis\",\"choice\",\"not\",\"thread\",\"try\",\"raise\",\"lock\",\"for\",\"suchthat\",\"meth\",\"functor\"]),s=t(o),d=t(i);function l(e,t){if(e.eatSpace())return null;if(e.match(/[{}]/))return\"bracket\";if(e.match(\"[]\"))return\"keyword\";if(e.match(a)||e.match(r))return\"operator\";if(e.match(c))return\"atom\";var o=e.match(f);if(o)return t.doInCurrentLine?t.doInCurrentLine=!1:t.currentIndent++,\"proc\"==o[0]||\"fun\"==o[0]?t.tokenize=k:\"class\"==o[0]?t.tokenize=h:\"meth\"==o[0]&&(t.tokenize=m),\"keyword\";if(e.match(s)||e.match(u))return\"keyword\";if(e.match(d))return t.currentIndent--,\"keyword\";var i=e.next();if('\"'==i||\"'\"==i)return t.tokenize=z(i),t.tokenize(e,t);if(/[~\\d]/.test(i)){if(\"~\"==i){if(!/^[0-9]/.test(e.peek()))return null;if(\"0\"==e.next()&&e.match(/^[xX][0-9a-fA-F]+/)||e.match(/^[0-9]*(\\.[0-9]+)?([eE][~+]?[0-9]+)?/))return\"number\"}return\"0\"==i&&e.match(/^[xX][0-9a-fA-F]+/)||e.match(/^[0-9]*(\\.[0-9]+)?([eE][~+]?[0-9]+)?/)?\"number\":null}return\"%\"==i?(e.skipToEnd(),\"comment\"):\"/\"==i&&e.eat(\"*\")?(t.tokenize=p,p(e,t)):n.test(i)?\"operator\":(e.eatWhile(/\\w/),\"variable\")}function h(e,t){return e.eatSpace()?null:(e.match(/([A-Z][A-Za-z0-9_]*)|(`.+`)/),t.tokenize=l,\"variable-3\")}function m(e,t){return e.eatSpace()?null:(e.match(/([a-zA-Z][A-Za-z0-9_]*)|(`.+`)/),t.tokenize=l,\"def\")}function k(e,t){return e.eatSpace()?null:!t.hasPassedFirstStage&&e.eat(\"{\")?(t.hasPassedFirstStage=!0,\"bracket\"):t.hasPassedFirstStage?(e.match(/([A-Z][A-Za-z0-9_]*)|(`.+`)|\\$/),t.hasPassedFirstStage=!1,t.tokenize=l,\"def\"):(t.tokenize=l,null)}function p(e,t){for(var n,r=!1;n=e.next();){if(\"/\"==n&&r){t.tokenize=l;break}r=\"*\"==n}return\"comment\"}function z(e){return function(t,n){for(var r,a=!1,o=!1;null!=(r=t.next());){if(r==e&&!a){o=!0;break}a=!a&&\"\\\\\"==r}return!o&&a||(n.tokenize=l),\"string\"}}function b(){var e=o.concat(i);return new RegExp(\"[\\\\[\\\\]]|(\"+e.join(\"|\")+\")$\")}return{startState:function(){return{tokenize:l,currentIndent:0,doInCurrentLine:!1,hasPassedFirstStage:!1}},token:function(e,t){return e.sol()&&(t.doInCurrentLine=0),t.tokenize(e,t)},indent:function(t,n){var r=n.replace(/^\\s+|\\s+$/g,\"\");return r.match(d)||r.match(s)||r.match(/(\\[])/)?e.indentUnit*(t.currentIndent-1):t.currentIndent<0?0:t.currentIndent*e.indentUnit},fold:\"indent\",electricInput:b(),lineComment:\"%\",blockCommentStart:\"/*\",blockCommentEnd:\"*/\"}})),e.defineMIME(\"text/x-oz\",\"oz\")}(n(108))}}]);","name":"static/js/77.fa14ce37.chunk.js","map":{"version":3,"sources":["static/js/77.fa14ce37.chunk.js"],"names":["this","push","module","exports","__webpack_require__","CodeMirror","defineMode","conf","wordRegexp","words","RegExp","join","singleOperators","doubleOperators","tripleOperators","middle","end","atoms","commonKeywords","openingKeywords","middleKeywords","endKeywords","tokenBase","stream","state","eatSpace","match","matched","doInCurrentLine","currentIndent","tokenize","tokenFunProc","tokenClass","tokenMeth","ch","next","tokenString","test","peek","skipToEnd","eat","tokenComment","eatWhile","hasPassedFirstStage","maybeEnd","quote","escaped","buildElectricInputRegEx","allClosings","concat","startState","token","sol","indent","textAfter","trueText","replace","indentUnit","fold","electricInput","lineComment","blockCommentStart","blockCommentEnd","defineMIME","mod"],"mappings":"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"},"input":"(this[\"webpackJsonpfrontend\"] = this[\"webpackJsonpfrontend\"] || []).push([[77],{\n\n/***/ 355:\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(108));else {}\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"oz\", function (conf) {\n    function wordRegexp(words) {\n      return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n    }\n\n    var singleOperators = /[\\^@!\\|<>#~\\.\\*\\-\\+\\\\/,=]/;\n    var doubleOperators = /(<-)|(:=)|(=<)|(>=)|(<=)|(<:)|(>:)|(=:)|(\\\\=)|(\\\\=:)|(!!)|(==)|(::)/;\n    var tripleOperators = /(:::)|(\\.\\.\\.)|(=<:)|(>=:)/;\n    var middle = [\"in\", \"then\", \"else\", \"of\", \"elseof\", \"elsecase\", \"elseif\", \"catch\", \"finally\", \"with\", \"require\", \"prepare\", \"import\", \"export\", \"define\", \"do\"];\n    var end = [\"end\"];\n    var atoms = wordRegexp([\"true\", \"false\", \"nil\", \"unit\"]);\n    var commonKeywords = wordRegexp([\"andthen\", \"at\", \"attr\", \"declare\", \"feat\", \"from\", \"lex\", \"mod\", \"div\", \"mode\", \"orelse\", \"parser\", \"prod\", \"prop\", \"scanner\", \"self\", \"syn\", \"token\"]);\n    var openingKeywords = wordRegexp([\"local\", \"proc\", \"fun\", \"case\", \"class\", \"if\", \"cond\", \"or\", \"dis\", \"choice\", \"not\", \"thread\", \"try\", \"raise\", \"lock\", \"for\", \"suchthat\", \"meth\", \"functor\"]);\n    var middleKeywords = wordRegexp(middle);\n    var endKeywords = wordRegexp(end); // Tokenizers\n\n    function tokenBase(stream, state) {\n      if (stream.eatSpace()) {\n        return null;\n      } // Brackets\n\n\n      if (stream.match(/[{}]/)) {\n        return \"bracket\";\n      } // Special [] keyword\n\n\n      if (stream.match('[]')) {\n        return \"keyword\";\n      } // Operators\n\n\n      if (stream.match(tripleOperators) || stream.match(doubleOperators)) {\n        return \"operator\";\n      } // Atoms\n\n\n      if (stream.match(atoms)) {\n        return 'atom';\n      } // Opening keywords\n\n\n      var matched = stream.match(openingKeywords);\n\n      if (matched) {\n        if (!state.doInCurrentLine) state.currentIndent++;else state.doInCurrentLine = false; // Special matching for signatures\n\n        if (matched[0] == \"proc\" || matched[0] == \"fun\") state.tokenize = tokenFunProc;else if (matched[0] == \"class\") state.tokenize = tokenClass;else if (matched[0] == \"meth\") state.tokenize = tokenMeth;\n        return 'keyword';\n      } // Middle and other keywords\n\n\n      if (stream.match(middleKeywords) || stream.match(commonKeywords)) {\n        return \"keyword\";\n      } // End keywords\n\n\n      if (stream.match(endKeywords)) {\n        state.currentIndent--;\n        return 'keyword';\n      } // Eat the next char for next comparisons\n\n\n      var ch = stream.next(); // Strings\n\n      if (ch == '\"' || ch == \"'\") {\n        state.tokenize = tokenString(ch);\n        return state.tokenize(stream, state);\n      } // Numbers\n\n\n      if (/[~\\d]/.test(ch)) {\n        if (ch == \"~\") {\n          if (!/^[0-9]/.test(stream.peek())) return null;else if (stream.next() == \"0\" && stream.match(/^[xX][0-9a-fA-F]+/) || stream.match(/^[0-9]*(\\.[0-9]+)?([eE][~+]?[0-9]+)?/)) return \"number\";\n        }\n\n        if (ch == \"0\" && stream.match(/^[xX][0-9a-fA-F]+/) || stream.match(/^[0-9]*(\\.[0-9]+)?([eE][~+]?[0-9]+)?/)) return \"number\";\n        return null;\n      } // Comments\n\n\n      if (ch == \"%\") {\n        stream.skipToEnd();\n        return 'comment';\n      } else if (ch == \"/\") {\n        if (stream.eat(\"*\")) {\n          state.tokenize = tokenComment;\n          return tokenComment(stream, state);\n        }\n      } // Single operators\n\n\n      if (singleOperators.test(ch)) {\n        return \"operator\";\n      } // If nothing match, we skip the entire alphanumeric block\n\n\n      stream.eatWhile(/\\w/);\n      return \"variable\";\n    }\n\n    function tokenClass(stream, state) {\n      if (stream.eatSpace()) {\n        return null;\n      }\n\n      stream.match(/([A-Z][A-Za-z0-9_]*)|(`.+`)/);\n      state.tokenize = tokenBase;\n      return \"variable-3\";\n    }\n\n    function tokenMeth(stream, state) {\n      if (stream.eatSpace()) {\n        return null;\n      }\n\n      stream.match(/([a-zA-Z][A-Za-z0-9_]*)|(`.+`)/);\n      state.tokenize = tokenBase;\n      return \"def\";\n    }\n\n    function tokenFunProc(stream, state) {\n      if (stream.eatSpace()) {\n        return null;\n      }\n\n      if (!state.hasPassedFirstStage && stream.eat(\"{\")) {\n        state.hasPassedFirstStage = true;\n        return \"bracket\";\n      } else if (state.hasPassedFirstStage) {\n        stream.match(/([A-Z][A-Za-z0-9_]*)|(`.+`)|\\$/);\n        state.hasPassedFirstStage = false;\n        state.tokenize = tokenBase;\n        return \"def\";\n      } else {\n        state.tokenize = tokenBase;\n        return null;\n      }\n    }\n\n    function tokenComment(stream, state) {\n      var maybeEnd = false,\n          ch;\n\n      while (ch = stream.next()) {\n        if (ch == \"/\" && maybeEnd) {\n          state.tokenize = tokenBase;\n          break;\n        }\n\n        maybeEnd = ch == \"*\";\n      }\n\n      return \"comment\";\n    }\n\n    function tokenString(quote) {\n      return function (stream, state) {\n        var escaped = false,\n            next,\n            end = false;\n\n        while ((next = stream.next()) != null) {\n          if (next == quote && !escaped) {\n            end = true;\n            break;\n          }\n\n          escaped = !escaped && next == \"\\\\\";\n        }\n\n        if (end || !escaped) state.tokenize = tokenBase;\n        return \"string\";\n      };\n    }\n\n    function buildElectricInputRegEx() {\n      // Reindentation should occur on [] or on a match of any of\n      // the block closing keywords, at the end of a line.\n      var allClosings = middle.concat(end);\n      return new RegExp(\"[\\\\[\\\\]]|(\" + allClosings.join(\"|\") + \")$\");\n    }\n\n    return {\n      startState: function startState() {\n        return {\n          tokenize: tokenBase,\n          currentIndent: 0,\n          doInCurrentLine: false,\n          hasPassedFirstStage: false\n        };\n      },\n      token: function token(stream, state) {\n        if (stream.sol()) state.doInCurrentLine = 0;\n        return state.tokenize(stream, state);\n      },\n      indent: function indent(state, textAfter) {\n        var trueText = textAfter.replace(/^\\s+|\\s+$/g, '');\n        if (trueText.match(endKeywords) || trueText.match(middleKeywords) || trueText.match(/(\\[])/)) return conf.indentUnit * (state.currentIndent - 1);\n        if (state.currentIndent < 0) return 0;\n        return state.currentIndent * conf.indentUnit;\n      },\n      fold: \"indent\",\n      electricInput: buildElectricInputRegEx(),\n      lineComment: \"%\",\n      blockCommentStart: \"/*\",\n      blockCommentEnd: \"*/\"\n    };\n  });\n  CodeMirror.defineMIME(\"text/x-oz\", \"oz\");\n});\n\n/***/ })\n\n}]);","inputSourceMap":{"version":3,"sources":["/mnt/Datengrab/python/Zero-tier/frontend/node_modules/codemirror/mode/oz/oz.js"],"names":["mod","require","CodeMirror","defineMode","conf","wordRegexp","words","RegExp","join","singleOperators","doubleOperators","tripleOperators","middle","end","atoms","commonKeywords","openingKeywords","middleKeywords","endKeywords","tokenBase","stream","state","eatSpace","match","matched","doInCurrentLine","currentIndent","tokenize","tokenFunProc","tokenClass","tokenMeth","ch","next","tokenString","test","peek","skipToEnd","eat","tokenComment","eatWhile","hasPassedFirstStage","maybeEnd","quote","escaped","buildElectricInputRegEx","allClosings","concat","startState","token","sol","indent","textAfter","trueText","replace","indentUnit","fold","electricInput","lineComment","blockCommentStart","blockCommentEnd","defineMIME"],"mappings":"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","file":"x","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"oz\", function (conf) {\n\n  function wordRegexp(words) {\n    return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n  }\n\n  var singleOperators = /[\\^@!\\|<>#~\\.\\*\\-\\+\\\\/,=]/;\n  var doubleOperators = /(<-)|(:=)|(=<)|(>=)|(<=)|(<:)|(>:)|(=:)|(\\\\=)|(\\\\=:)|(!!)|(==)|(::)/;\n  var tripleOperators = /(:::)|(\\.\\.\\.)|(=<:)|(>=:)/;\n\n  var middle = [\"in\", \"then\", \"else\", \"of\", \"elseof\", \"elsecase\", \"elseif\", \"catch\",\n    \"finally\", \"with\", \"require\", \"prepare\", \"import\", \"export\", \"define\", \"do\"];\n  var end = [\"end\"];\n\n  var atoms = wordRegexp([\"true\", \"false\", \"nil\", \"unit\"]);\n  var commonKeywords = wordRegexp([\"andthen\", \"at\", \"attr\", \"declare\", \"feat\", \"from\", \"lex\",\n    \"mod\", \"div\", \"mode\", \"orelse\", \"parser\", \"prod\", \"prop\", \"scanner\", \"self\", \"syn\", \"token\"]);\n  var openingKeywords = wordRegexp([\"local\", \"proc\", \"fun\", \"case\", \"class\", \"if\", \"cond\", \"or\", \"dis\",\n    \"choice\", \"not\", \"thread\", \"try\", \"raise\", \"lock\", \"for\", \"suchthat\", \"meth\", \"functor\"]);\n  var middleKeywords = wordRegexp(middle);\n  var endKeywords = wordRegexp(end);\n\n  // Tokenizers\n  function tokenBase(stream, state) {\n    if (stream.eatSpace()) {\n      return null;\n    }\n\n    // Brackets\n    if(stream.match(/[{}]/)) {\n      return \"bracket\";\n    }\n\n    // Special [] keyword\n    if (stream.match('[]')) {\n        return \"keyword\"\n    }\n\n    // Operators\n    if (stream.match(tripleOperators) || stream.match(doubleOperators)) {\n      return \"operator\";\n    }\n\n    // Atoms\n    if(stream.match(atoms)) {\n      return 'atom';\n    }\n\n    // Opening keywords\n    var matched = stream.match(openingKeywords);\n    if (matched) {\n      if (!state.doInCurrentLine)\n        state.currentIndent++;\n      else\n        state.doInCurrentLine = false;\n\n      // Special matching for signatures\n      if(matched[0] == \"proc\" || matched[0] == \"fun\")\n        state.tokenize = tokenFunProc;\n      else if(matched[0] == \"class\")\n        state.tokenize = tokenClass;\n      else if(matched[0] == \"meth\")\n        state.tokenize = tokenMeth;\n\n      return 'keyword';\n    }\n\n    // Middle and other keywords\n    if (stream.match(middleKeywords) || stream.match(commonKeywords)) {\n      return \"keyword\"\n    }\n\n    // End keywords\n    if (stream.match(endKeywords)) {\n      state.currentIndent--;\n      return 'keyword';\n    }\n\n    // Eat the next char for next comparisons\n    var ch = stream.next();\n\n    // Strings\n    if (ch == '\"' || ch == \"'\") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    }\n\n    // Numbers\n    if (/[~\\d]/.test(ch)) {\n      if (ch == \"~\") {\n        if(! /^[0-9]/.test(stream.peek()))\n          return null;\n        else if (( stream.next() == \"0\" && stream.match(/^[xX][0-9a-fA-F]+/)) || stream.match(/^[0-9]*(\\.[0-9]+)?([eE][~+]?[0-9]+)?/))\n          return \"number\";\n      }\n\n      if ((ch == \"0\" && stream.match(/^[xX][0-9a-fA-F]+/)) || stream.match(/^[0-9]*(\\.[0-9]+)?([eE][~+]?[0-9]+)?/))\n        return \"number\";\n\n      return null;\n    }\n\n    // Comments\n    if (ch == \"%\") {\n      stream.skipToEnd();\n      return 'comment';\n    }\n    else if (ch == \"/\") {\n      if (stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      }\n    }\n\n    // Single operators\n    if(singleOperators.test(ch)) {\n      return \"operator\";\n    }\n\n    // If nothing match, we skip the entire alphanumeric block\n    stream.eatWhile(/\\w/);\n\n    return \"variable\";\n  }\n\n  function tokenClass(stream, state) {\n    if (stream.eatSpace()) {\n      return null;\n    }\n    stream.match(/([A-Z][A-Za-z0-9_]*)|(`.+`)/);\n    state.tokenize = tokenBase;\n    return \"variable-3\"\n  }\n\n  function tokenMeth(stream, state) {\n    if (stream.eatSpace()) {\n      return null;\n    }\n    stream.match(/([a-zA-Z][A-Za-z0-9_]*)|(`.+`)/);\n    state.tokenize = tokenBase;\n    return \"def\"\n  }\n\n  function tokenFunProc(stream, state) {\n    if (stream.eatSpace()) {\n      return null;\n    }\n\n    if(!state.hasPassedFirstStage && stream.eat(\"{\")) {\n      state.hasPassedFirstStage = true;\n      return \"bracket\";\n    }\n    else if(state.hasPassedFirstStage) {\n      stream.match(/([A-Z][A-Za-z0-9_]*)|(`.+`)|\\$/);\n      state.hasPassedFirstStage = false;\n      state.tokenize = tokenBase;\n      return \"def\"\n    }\n    else {\n      state.tokenize = tokenBase;\n      return null;\n    }\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return \"comment\";\n  }\n\n  function tokenString(quote) {\n    return function (stream, state) {\n      var escaped = false, next, end = false;\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) {\n          end = true;\n          break;\n        }\n        escaped = !escaped && next == \"\\\\\";\n      }\n      if (end || !escaped)\n        state.tokenize = tokenBase;\n      return \"string\";\n    };\n  }\n\n  function buildElectricInputRegEx() {\n    // Reindentation should occur on [] or on a match of any of\n    // the block closing keywords, at the end of a line.\n    var allClosings = middle.concat(end);\n    return new RegExp(\"[\\\\[\\\\]]|(\" + allClosings.join(\"|\") + \")$\");\n  }\n\n  return {\n\n    startState: function () {\n      return {\n        tokenize: tokenBase,\n        currentIndent: 0,\n        doInCurrentLine: false,\n        hasPassedFirstStage: false\n      };\n    },\n\n    token: function (stream, state) {\n      if (stream.sol())\n        state.doInCurrentLine = 0;\n\n      return state.tokenize(stream, state);\n    },\n\n    indent: function (state, textAfter) {\n      var trueText = textAfter.replace(/^\\s+|\\s+$/g, '');\n\n      if (trueText.match(endKeywords) || trueText.match(middleKeywords) || trueText.match(/(\\[])/))\n        return conf.indentUnit * (state.currentIndent - 1);\n\n      if (state.currentIndent < 0)\n        return 0;\n\n      return state.currentIndent * conf.indentUnit;\n    },\n    fold: \"indent\",\n    electricInput: buildElectricInputRegEx(),\n    lineComment: \"%\",\n    blockCommentStart: \"/*\",\n    blockCommentEnd: \"*/\"\n  };\n});\n\nCodeMirror.defineMIME(\"text/x-oz\", \"oz\");\n\n});\n"]}}