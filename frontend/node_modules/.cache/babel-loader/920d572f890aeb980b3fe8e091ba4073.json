{"ast":null,"code":"// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  var rfc2822 = [\"From\", \"Sender\", \"Reply-To\", \"To\", \"Cc\", \"Bcc\", \"Message-ID\", \"In-Reply-To\", \"References\", \"Resent-From\", \"Resent-Sender\", \"Resent-To\", \"Resent-Cc\", \"Resent-Bcc\", \"Resent-Message-ID\", \"Return-Path\", \"Received\"];\n  var rfc2822NoEmail = [\"Date\", \"Subject\", \"Comments\", \"Keywords\", \"Resent-Date\"];\n  CodeMirror.registerHelper(\"hintWords\", \"mbox\", rfc2822.concat(rfc2822NoEmail));\n  var whitespace = /^[ \\t]/;\n  var separator = /^From /; // See RFC 4155\n\n  var rfc2822Header = new RegExp(\"^(\" + rfc2822.join(\"|\") + \"): \");\n  var rfc2822HeaderNoEmail = new RegExp(\"^(\" + rfc2822NoEmail.join(\"|\") + \"): \");\n  var header = /^[^:]+:/; // Optional fields defined in RFC 2822\n\n  var email = /^[^ ]+@[^ ]+/;\n  var untilEmail = /^.*?(?=[^ ]+?@[^ ]+)/;\n  var bracketedEmail = /^<.*?>/;\n  var untilBracketedEmail = /^.*?(?=<.*>)/;\n\n  function styleForHeader(header) {\n    if (header === \"Subject\") return \"header\";\n    return \"string\";\n  }\n\n  function readToken(stream, state) {\n    if (stream.sol()) {\n      // From last line\n      state.inSeparator = false;\n\n      if (state.inHeader && stream.match(whitespace)) {\n        // Header folding\n        return null;\n      } else {\n        state.inHeader = false;\n        state.header = null;\n      }\n\n      if (stream.match(separator)) {\n        state.inHeaders = true;\n        state.inSeparator = true;\n        return \"atom\";\n      }\n\n      var match;\n      var emailPermitted = false;\n\n      if ((match = stream.match(rfc2822HeaderNoEmail)) || (emailPermitted = true) && (match = stream.match(rfc2822Header))) {\n        state.inHeaders = true;\n        state.inHeader = true;\n        state.emailPermitted = emailPermitted;\n        state.header = match[1];\n        return \"atom\";\n      } // Use vim's heuristics: recognize custom headers only if the line is in a\n      // block of legitimate headers.\n\n\n      if (state.inHeaders && (match = stream.match(header))) {\n        state.inHeader = true;\n        state.emailPermitted = true;\n        state.header = match[1];\n        return \"atom\";\n      }\n\n      state.inHeaders = false;\n      stream.skipToEnd();\n      return null;\n    }\n\n    if (state.inSeparator) {\n      if (stream.match(email)) return \"link\";\n      if (stream.match(untilEmail)) return \"atom\";\n      stream.skipToEnd();\n      return \"atom\";\n    }\n\n    if (state.inHeader) {\n      var style = styleForHeader(state.header);\n\n      if (state.emailPermitted) {\n        if (stream.match(bracketedEmail)) return style + \" link\";\n        if (stream.match(untilBracketedEmail)) return style;\n      }\n\n      stream.skipToEnd();\n      return style;\n    }\n\n    stream.skipToEnd();\n    return null;\n  }\n\n  ;\n  CodeMirror.defineMode(\"mbox\", function () {\n    return {\n      startState: function startState() {\n        return {\n          // Is in a mbox separator\n          inSeparator: false,\n          // Is in a mail header\n          inHeader: false,\n          // If bracketed email is permitted. Only applicable when inHeader\n          emailPermitted: false,\n          // Name of current header\n          header: null,\n          // Is in a region of mail headers\n          inHeaders: false\n        };\n      },\n      token: readToken,\n      blankLine: function blankLine(state) {\n        state.inHeaders = state.inSeparator = state.inHeader = false;\n      }\n    };\n  });\n  CodeMirror.defineMIME(\"application/mbox\", \"mbox\");\n});","map":{"version":3,"names":["mod","exports","module","require","define","amd","CodeMirror","rfc2822","rfc2822NoEmail","registerHelper","concat","whitespace","separator","rfc2822Header","RegExp","join","rfc2822HeaderNoEmail","header","email","untilEmail","bracketedEmail","untilBracketedEmail","styleForHeader","readToken","stream","state","sol","inSeparator","inHeader","match","inHeaders","emailPermitted","skipToEnd","style","defineMode","startState","token","blankLine","defineMIME"],"sources":["/mnt/Datengrab/python/Zero-tier/frontend/node_modules/codemirror/mode/mbox/mbox.js"],"sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nvar rfc2822 = [\n  \"From\", \"Sender\", \"Reply-To\", \"To\", \"Cc\", \"Bcc\", \"Message-ID\",\n  \"In-Reply-To\", \"References\", \"Resent-From\", \"Resent-Sender\", \"Resent-To\",\n  \"Resent-Cc\", \"Resent-Bcc\", \"Resent-Message-ID\", \"Return-Path\", \"Received\"\n];\nvar rfc2822NoEmail = [\n  \"Date\", \"Subject\", \"Comments\", \"Keywords\", \"Resent-Date\"\n];\n\nCodeMirror.registerHelper(\"hintWords\", \"mbox\", rfc2822.concat(rfc2822NoEmail));\n\nvar whitespace = /^[ \\t]/;\nvar separator = /^From /; // See RFC 4155\nvar rfc2822Header = new RegExp(\"^(\" + rfc2822.join(\"|\") + \"): \");\nvar rfc2822HeaderNoEmail = new RegExp(\"^(\" + rfc2822NoEmail.join(\"|\") + \"): \");\nvar header = /^[^:]+:/; // Optional fields defined in RFC 2822\nvar email = /^[^ ]+@[^ ]+/;\nvar untilEmail = /^.*?(?=[^ ]+?@[^ ]+)/;\nvar bracketedEmail = /^<.*?>/;\nvar untilBracketedEmail = /^.*?(?=<.*>)/;\n\nfunction styleForHeader(header) {\n  if (header === \"Subject\") return \"header\";\n  return \"string\";\n}\n\nfunction readToken(stream, state) {\n  if (stream.sol()) {\n    // From last line\n    state.inSeparator = false;\n    if (state.inHeader && stream.match(whitespace)) {\n      // Header folding\n      return null;\n    } else {\n      state.inHeader = false;\n      state.header = null;\n    }\n\n    if (stream.match(separator)) {\n      state.inHeaders = true;\n      state.inSeparator = true;\n      return \"atom\";\n    }\n\n    var match;\n    var emailPermitted = false;\n    if ((match = stream.match(rfc2822HeaderNoEmail)) ||\n        (emailPermitted = true) && (match = stream.match(rfc2822Header))) {\n      state.inHeaders = true;\n      state.inHeader = true;\n      state.emailPermitted = emailPermitted;\n      state.header = match[1];\n      return \"atom\";\n    }\n\n    // Use vim's heuristics: recognize custom headers only if the line is in a\n    // block of legitimate headers.\n    if (state.inHeaders && (match = stream.match(header))) {\n      state.inHeader = true;\n      state.emailPermitted = true;\n      state.header = match[1];\n      return \"atom\";\n    }\n\n    state.inHeaders = false;\n    stream.skipToEnd();\n    return null;\n  }\n\n  if (state.inSeparator) {\n    if (stream.match(email)) return \"link\";\n    if (stream.match(untilEmail)) return \"atom\";\n    stream.skipToEnd();\n    return \"atom\";\n  }\n\n  if (state.inHeader) {\n    var style = styleForHeader(state.header);\n\n    if (state.emailPermitted) {\n      if (stream.match(bracketedEmail)) return style + \" link\";\n      if (stream.match(untilBracketedEmail)) return style;\n    }\n    stream.skipToEnd();\n    return style;\n  }\n\n  stream.skipToEnd();\n  return null;\n};\n\nCodeMirror.defineMode(\"mbox\", function() {\n  return {\n    startState: function() {\n      return {\n        // Is in a mbox separator\n        inSeparator: false,\n        // Is in a mail header\n        inHeader: false,\n        // If bracketed email is permitted. Only applicable when inHeader\n        emailPermitted: false,\n        // Name of current header\n        header: null,\n        // Is in a region of mail headers\n        inHeaders: false\n      };\n    },\n    token: readToken,\n    blankLine: function(state) {\n      state.inHeaders = state.inSeparator = state.inHeader = false;\n    }\n  };\n});\n\nCodeMirror.defineMIME(\"application/mbox\", \"mbox\");\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}