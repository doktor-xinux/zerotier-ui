{"ast":null,"code":"// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"oz\", function (conf) {\n    function wordRegexp(words) {\n      return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n    }\n\n    var singleOperators = /[\\^@!\\|<>#~\\.\\*\\-\\+\\\\/,=]/;\n    var doubleOperators = /(<-)|(:=)|(=<)|(>=)|(<=)|(<:)|(>:)|(=:)|(\\\\=)|(\\\\=:)|(!!)|(==)|(::)/;\n    var tripleOperators = /(:::)|(\\.\\.\\.)|(=<:)|(>=:)/;\n    var middle = [\"in\", \"then\", \"else\", \"of\", \"elseof\", \"elsecase\", \"elseif\", \"catch\", \"finally\", \"with\", \"require\", \"prepare\", \"import\", \"export\", \"define\", \"do\"];\n    var end = [\"end\"];\n    var atoms = wordRegexp([\"true\", \"false\", \"nil\", \"unit\"]);\n    var commonKeywords = wordRegexp([\"andthen\", \"at\", \"attr\", \"declare\", \"feat\", \"from\", \"lex\", \"mod\", \"div\", \"mode\", \"orelse\", \"parser\", \"prod\", \"prop\", \"scanner\", \"self\", \"syn\", \"token\"]);\n    var openingKeywords = wordRegexp([\"local\", \"proc\", \"fun\", \"case\", \"class\", \"if\", \"cond\", \"or\", \"dis\", \"choice\", \"not\", \"thread\", \"try\", \"raise\", \"lock\", \"for\", \"suchthat\", \"meth\", \"functor\"]);\n    var middleKeywords = wordRegexp(middle);\n    var endKeywords = wordRegexp(end); // Tokenizers\n\n    function tokenBase(stream, state) {\n      if (stream.eatSpace()) {\n        return null;\n      } // Brackets\n\n\n      if (stream.match(/[{}]/)) {\n        return \"bracket\";\n      } // Special [] keyword\n\n\n      if (stream.match('[]')) {\n        return \"keyword\";\n      } // Operators\n\n\n      if (stream.match(tripleOperators) || stream.match(doubleOperators)) {\n        return \"operator\";\n      } // Atoms\n\n\n      if (stream.match(atoms)) {\n        return 'atom';\n      } // Opening keywords\n\n\n      var matched = stream.match(openingKeywords);\n\n      if (matched) {\n        if (!state.doInCurrentLine) state.currentIndent++;else state.doInCurrentLine = false; // Special matching for signatures\n\n        if (matched[0] == \"proc\" || matched[0] == \"fun\") state.tokenize = tokenFunProc;else if (matched[0] == \"class\") state.tokenize = tokenClass;else if (matched[0] == \"meth\") state.tokenize = tokenMeth;\n        return 'keyword';\n      } // Middle and other keywords\n\n\n      if (stream.match(middleKeywords) || stream.match(commonKeywords)) {\n        return \"keyword\";\n      } // End keywords\n\n\n      if (stream.match(endKeywords)) {\n        state.currentIndent--;\n        return 'keyword';\n      } // Eat the next char for next comparisons\n\n\n      var ch = stream.next(); // Strings\n\n      if (ch == '\"' || ch == \"'\") {\n        state.tokenize = tokenString(ch);\n        return state.tokenize(stream, state);\n      } // Numbers\n\n\n      if (/[~\\d]/.test(ch)) {\n        if (ch == \"~\") {\n          if (!/^[0-9]/.test(stream.peek())) return null;else if (stream.next() == \"0\" && stream.match(/^[xX][0-9a-fA-F]+/) || stream.match(/^[0-9]*(\\.[0-9]+)?([eE][~+]?[0-9]+)?/)) return \"number\";\n        }\n\n        if (ch == \"0\" && stream.match(/^[xX][0-9a-fA-F]+/) || stream.match(/^[0-9]*(\\.[0-9]+)?([eE][~+]?[0-9]+)?/)) return \"number\";\n        return null;\n      } // Comments\n\n\n      if (ch == \"%\") {\n        stream.skipToEnd();\n        return 'comment';\n      } else if (ch == \"/\") {\n        if (stream.eat(\"*\")) {\n          state.tokenize = tokenComment;\n          return tokenComment(stream, state);\n        }\n      } // Single operators\n\n\n      if (singleOperators.test(ch)) {\n        return \"operator\";\n      } // If nothing match, we skip the entire alphanumeric block\n\n\n      stream.eatWhile(/\\w/);\n      return \"variable\";\n    }\n\n    function tokenClass(stream, state) {\n      if (stream.eatSpace()) {\n        return null;\n      }\n\n      stream.match(/([A-Z][A-Za-z0-9_]*)|(`.+`)/);\n      state.tokenize = tokenBase;\n      return \"variable-3\";\n    }\n\n    function tokenMeth(stream, state) {\n      if (stream.eatSpace()) {\n        return null;\n      }\n\n      stream.match(/([a-zA-Z][A-Za-z0-9_]*)|(`.+`)/);\n      state.tokenize = tokenBase;\n      return \"def\";\n    }\n\n    function tokenFunProc(stream, state) {\n      if (stream.eatSpace()) {\n        return null;\n      }\n\n      if (!state.hasPassedFirstStage && stream.eat(\"{\")) {\n        state.hasPassedFirstStage = true;\n        return \"bracket\";\n      } else if (state.hasPassedFirstStage) {\n        stream.match(/([A-Z][A-Za-z0-9_]*)|(`.+`)|\\$/);\n        state.hasPassedFirstStage = false;\n        state.tokenize = tokenBase;\n        return \"def\";\n      } else {\n        state.tokenize = tokenBase;\n        return null;\n      }\n    }\n\n    function tokenComment(stream, state) {\n      var maybeEnd = false,\n          ch;\n\n      while (ch = stream.next()) {\n        if (ch == \"/\" && maybeEnd) {\n          state.tokenize = tokenBase;\n          break;\n        }\n\n        maybeEnd = ch == \"*\";\n      }\n\n      return \"comment\";\n    }\n\n    function tokenString(quote) {\n      return function (stream, state) {\n        var escaped = false,\n            next,\n            end = false;\n\n        while ((next = stream.next()) != null) {\n          if (next == quote && !escaped) {\n            end = true;\n            break;\n          }\n\n          escaped = !escaped && next == \"\\\\\";\n        }\n\n        if (end || !escaped) state.tokenize = tokenBase;\n        return \"string\";\n      };\n    }\n\n    function buildElectricInputRegEx() {\n      // Reindentation should occur on [] or on a match of any of\n      // the block closing keywords, at the end of a line.\n      var allClosings = middle.concat(end);\n      return new RegExp(\"[\\\\[\\\\]]|(\" + allClosings.join(\"|\") + \")$\");\n    }\n\n    return {\n      startState: function startState() {\n        return {\n          tokenize: tokenBase,\n          currentIndent: 0,\n          doInCurrentLine: false,\n          hasPassedFirstStage: false\n        };\n      },\n      token: function token(stream, state) {\n        if (stream.sol()) state.doInCurrentLine = 0;\n        return state.tokenize(stream, state);\n      },\n      indent: function indent(state, textAfter) {\n        var trueText = textAfter.replace(/^\\s+|\\s+$/g, '');\n        if (trueText.match(endKeywords) || trueText.match(middleKeywords) || trueText.match(/(\\[])/)) return conf.indentUnit * (state.currentIndent - 1);\n        if (state.currentIndent < 0) return 0;\n        return state.currentIndent * conf.indentUnit;\n      },\n      fold: \"indent\",\n      electricInput: buildElectricInputRegEx(),\n      lineComment: \"%\",\n      blockCommentStart: \"/*\",\n      blockCommentEnd: \"*/\"\n    };\n  });\n  CodeMirror.defineMIME(\"text/x-oz\", \"oz\");\n});","map":{"version":3,"names":["mod","exports","module","require","define","amd","CodeMirror","defineMode","conf","wordRegexp","words","RegExp","join","singleOperators","doubleOperators","tripleOperators","middle","end","atoms","commonKeywords","openingKeywords","middleKeywords","endKeywords","tokenBase","stream","state","eatSpace","match","matched","doInCurrentLine","currentIndent","tokenize","tokenFunProc","tokenClass","tokenMeth","ch","next","tokenString","test","peek","skipToEnd","eat","tokenComment","eatWhile","hasPassedFirstStage","maybeEnd","quote","escaped","buildElectricInputRegEx","allClosings","concat","startState","token","sol","indent","textAfter","trueText","replace","indentUnit","fold","electricInput","lineComment","blockCommentStart","blockCommentEnd","defineMIME"],"sources":["/mnt/Datengrab/python/Zero-tier/frontend/node_modules/codemirror/mode/oz/oz.js"],"sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"oz\", function (conf) {\n\n  function wordRegexp(words) {\n    return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n  }\n\n  var singleOperators = /[\\^@!\\|<>#~\\.\\*\\-\\+\\\\/,=]/;\n  var doubleOperators = /(<-)|(:=)|(=<)|(>=)|(<=)|(<:)|(>:)|(=:)|(\\\\=)|(\\\\=:)|(!!)|(==)|(::)/;\n  var tripleOperators = /(:::)|(\\.\\.\\.)|(=<:)|(>=:)/;\n\n  var middle = [\"in\", \"then\", \"else\", \"of\", \"elseof\", \"elsecase\", \"elseif\", \"catch\",\n    \"finally\", \"with\", \"require\", \"prepare\", \"import\", \"export\", \"define\", \"do\"];\n  var end = [\"end\"];\n\n  var atoms = wordRegexp([\"true\", \"false\", \"nil\", \"unit\"]);\n  var commonKeywords = wordRegexp([\"andthen\", \"at\", \"attr\", \"declare\", \"feat\", \"from\", \"lex\",\n    \"mod\", \"div\", \"mode\", \"orelse\", \"parser\", \"prod\", \"prop\", \"scanner\", \"self\", \"syn\", \"token\"]);\n  var openingKeywords = wordRegexp([\"local\", \"proc\", \"fun\", \"case\", \"class\", \"if\", \"cond\", \"or\", \"dis\",\n    \"choice\", \"not\", \"thread\", \"try\", \"raise\", \"lock\", \"for\", \"suchthat\", \"meth\", \"functor\"]);\n  var middleKeywords = wordRegexp(middle);\n  var endKeywords = wordRegexp(end);\n\n  // Tokenizers\n  function tokenBase(stream, state) {\n    if (stream.eatSpace()) {\n      return null;\n    }\n\n    // Brackets\n    if(stream.match(/[{}]/)) {\n      return \"bracket\";\n    }\n\n    // Special [] keyword\n    if (stream.match('[]')) {\n        return \"keyword\"\n    }\n\n    // Operators\n    if (stream.match(tripleOperators) || stream.match(doubleOperators)) {\n      return \"operator\";\n    }\n\n    // Atoms\n    if(stream.match(atoms)) {\n      return 'atom';\n    }\n\n    // Opening keywords\n    var matched = stream.match(openingKeywords);\n    if (matched) {\n      if (!state.doInCurrentLine)\n        state.currentIndent++;\n      else\n        state.doInCurrentLine = false;\n\n      // Special matching for signatures\n      if(matched[0] == \"proc\" || matched[0] == \"fun\")\n        state.tokenize = tokenFunProc;\n      else if(matched[0] == \"class\")\n        state.tokenize = tokenClass;\n      else if(matched[0] == \"meth\")\n        state.tokenize = tokenMeth;\n\n      return 'keyword';\n    }\n\n    // Middle and other keywords\n    if (stream.match(middleKeywords) || stream.match(commonKeywords)) {\n      return \"keyword\"\n    }\n\n    // End keywords\n    if (stream.match(endKeywords)) {\n      state.currentIndent--;\n      return 'keyword';\n    }\n\n    // Eat the next char for next comparisons\n    var ch = stream.next();\n\n    // Strings\n    if (ch == '\"' || ch == \"'\") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    }\n\n    // Numbers\n    if (/[~\\d]/.test(ch)) {\n      if (ch == \"~\") {\n        if(! /^[0-9]/.test(stream.peek()))\n          return null;\n        else if (( stream.next() == \"0\" && stream.match(/^[xX][0-9a-fA-F]+/)) || stream.match(/^[0-9]*(\\.[0-9]+)?([eE][~+]?[0-9]+)?/))\n          return \"number\";\n      }\n\n      if ((ch == \"0\" && stream.match(/^[xX][0-9a-fA-F]+/)) || stream.match(/^[0-9]*(\\.[0-9]+)?([eE][~+]?[0-9]+)?/))\n        return \"number\";\n\n      return null;\n    }\n\n    // Comments\n    if (ch == \"%\") {\n      stream.skipToEnd();\n      return 'comment';\n    }\n    else if (ch == \"/\") {\n      if (stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      }\n    }\n\n    // Single operators\n    if(singleOperators.test(ch)) {\n      return \"operator\";\n    }\n\n    // If nothing match, we skip the entire alphanumeric block\n    stream.eatWhile(/\\w/);\n\n    return \"variable\";\n  }\n\n  function tokenClass(stream, state) {\n    if (stream.eatSpace()) {\n      return null;\n    }\n    stream.match(/([A-Z][A-Za-z0-9_]*)|(`.+`)/);\n    state.tokenize = tokenBase;\n    return \"variable-3\"\n  }\n\n  function tokenMeth(stream, state) {\n    if (stream.eatSpace()) {\n      return null;\n    }\n    stream.match(/([a-zA-Z][A-Za-z0-9_]*)|(`.+`)/);\n    state.tokenize = tokenBase;\n    return \"def\"\n  }\n\n  function tokenFunProc(stream, state) {\n    if (stream.eatSpace()) {\n      return null;\n    }\n\n    if(!state.hasPassedFirstStage && stream.eat(\"{\")) {\n      state.hasPassedFirstStage = true;\n      return \"bracket\";\n    }\n    else if(state.hasPassedFirstStage) {\n      stream.match(/([A-Z][A-Za-z0-9_]*)|(`.+`)|\\$/);\n      state.hasPassedFirstStage = false;\n      state.tokenize = tokenBase;\n      return \"def\"\n    }\n    else {\n      state.tokenize = tokenBase;\n      return null;\n    }\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return \"comment\";\n  }\n\n  function tokenString(quote) {\n    return function (stream, state) {\n      var escaped = false, next, end = false;\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) {\n          end = true;\n          break;\n        }\n        escaped = !escaped && next == \"\\\\\";\n      }\n      if (end || !escaped)\n        state.tokenize = tokenBase;\n      return \"string\";\n    };\n  }\n\n  function buildElectricInputRegEx() {\n    // Reindentation should occur on [] or on a match of any of\n    // the block closing keywords, at the end of a line.\n    var allClosings = middle.concat(end);\n    return new RegExp(\"[\\\\[\\\\]]|(\" + allClosings.join(\"|\") + \")$\");\n  }\n\n  return {\n\n    startState: function () {\n      return {\n        tokenize: tokenBase,\n        currentIndent: 0,\n        doInCurrentLine: false,\n        hasPassedFirstStage: false\n      };\n    },\n\n    token: function (stream, state) {\n      if (stream.sol())\n        state.doInCurrentLine = 0;\n\n      return state.tokenize(stream, state);\n    },\n\n    indent: function (state, textAfter) {\n      var trueText = textAfter.replace(/^\\s+|\\s+$/g, '');\n\n      if (trueText.match(endKeywords) || trueText.match(middleKeywords) || trueText.match(/(\\[])/))\n        return conf.indentUnit * (state.currentIndent - 1);\n\n      if (state.currentIndent < 0)\n        return 0;\n\n      return state.currentIndent * conf.indentUnit;\n    },\n    fold: \"indent\",\n    electricInput: buildElectricInputRegEx(),\n    lineComment: \"%\",\n    blockCommentStart: \"/*\",\n    blockCommentEnd: \"*/\"\n  };\n});\n\nCodeMirror.defineMIME(\"text/x-oz\", \"oz\");\n\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}