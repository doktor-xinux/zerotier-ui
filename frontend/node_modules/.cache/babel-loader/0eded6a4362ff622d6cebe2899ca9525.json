{"ast":null,"code":"(function (root) {\n  'use strict'; // A list of regular expressions that match arbitrary IPv4 addresses,\n  // for which a number of weird notations exist.\n  // Note that an address like 0010.0xa5.1.1 is considered legal.\n\n  var ipv4Part = '(0?\\\\d+|0x[a-f0-9]+)';\n  var ipv4Regexes = {\n    fourOctet: new RegExp(\"^\".concat(ipv4Part, \"\\\\.\").concat(ipv4Part, \"\\\\.\").concat(ipv4Part, \"\\\\.\").concat(ipv4Part, \"$\"), 'i'),\n    threeOctet: new RegExp(\"^\".concat(ipv4Part, \"\\\\.\").concat(ipv4Part, \"\\\\.\").concat(ipv4Part, \"$\"), 'i'),\n    twoOctet: new RegExp(\"^\".concat(ipv4Part, \"\\\\.\").concat(ipv4Part, \"$\"), 'i'),\n    longValue: new RegExp(\"^\".concat(ipv4Part, \"$\"), 'i')\n  }; // Regular Expression for checking Octal numbers\n\n  var octalRegex = new RegExp(\"^0[0-7]+$\", 'i');\n  var hexRegex = new RegExp(\"^0x[a-f0-9]+$\", 'i');\n  var zoneIndex = '%[0-9a-z]{1,}'; // IPv6-matching regular expressions.\n  // For IPv6, the task is simpler: it is enough to match the colon-delimited\n  // hexadecimal IPv6 and a transitional variant with dotted-decimal IPv4 at\n  // the end.\n\n  var ipv6Part = '(?:[0-9a-f]+::?)+';\n  var ipv6Regexes = {\n    zoneIndex: new RegExp(zoneIndex, 'i'),\n    'native': new RegExp(\"^(::)?(\".concat(ipv6Part, \")?([0-9a-f]+)?(::)?(\").concat(zoneIndex, \")?$\"), 'i'),\n    deprecatedTransitional: new RegExp(\"^(?:::)(\".concat(ipv4Part, \"\\\\.\").concat(ipv4Part, \"\\\\.\").concat(ipv4Part, \"\\\\.\").concat(ipv4Part, \"(\").concat(zoneIndex, \")?)$\"), 'i'),\n    transitional: new RegExp(\"^((?:\".concat(ipv6Part, \")|(?:::)(?:\").concat(ipv6Part, \")?)\").concat(ipv4Part, \"\\\\.\").concat(ipv4Part, \"\\\\.\").concat(ipv4Part, \"\\\\.\").concat(ipv4Part, \"(\").concat(zoneIndex, \")?$\"), 'i')\n  }; // Expand :: in an IPv6 address or address part consisting of `parts` groups.\n\n  function expandIPv6(string, parts) {\n    // More than one '::' means invalid adddress\n    if (string.indexOf('::') !== string.lastIndexOf('::')) {\n      return null;\n    }\n\n    var colonCount = 0;\n    var lastColon = -1;\n    var zoneId = (string.match(ipv6Regexes.zoneIndex) || [])[0];\n    var replacement, replacementCount; // Remove zone index and save it for later\n\n    if (zoneId) {\n      zoneId = zoneId.substring(1);\n      string = string.replace(/%.+$/, '');\n    } // How many parts do we already have?\n\n\n    while ((lastColon = string.indexOf(':', lastColon + 1)) >= 0) {\n      colonCount++;\n    } // 0::0 is two parts more than ::\n\n\n    if (string.substr(0, 2) === '::') {\n      colonCount--;\n    }\n\n    if (string.substr(-2, 2) === '::') {\n      colonCount--;\n    } // The following loop would hang if colonCount > parts\n\n\n    if (colonCount > parts) {\n      return null;\n    } // replacement = ':' + '0:' * (parts - colonCount)\n\n\n    replacementCount = parts - colonCount;\n    replacement = ':';\n\n    while (replacementCount--) {\n      replacement += '0:';\n    } // Insert the missing zeroes\n\n\n    string = string.replace('::', replacement); // Trim any garbage which may be hanging around if :: was at the edge in\n    // the source strin\n\n    if (string[0] === ':') {\n      string = string.slice(1);\n    }\n\n    if (string[string.length - 1] === ':') {\n      string = string.slice(0, -1);\n    }\n\n    parts = function () {\n      var ref = string.split(':');\n      var results = [];\n\n      for (var i = 0; i < ref.length; i++) {\n        results.push(parseInt(ref[i], 16));\n      }\n\n      return results;\n    }();\n\n    return {\n      parts: parts,\n      zoneId: zoneId\n    };\n  } // A generic CIDR (Classless Inter-Domain Routing) RFC1518 range matcher.\n\n\n  function matchCIDR(first, second, partSize, cidrBits) {\n    if (first.length !== second.length) {\n      throw new Error('ipaddr: cannot match CIDR for objects with different lengths');\n    }\n\n    var part = 0;\n    var shift;\n\n    while (cidrBits > 0) {\n      shift = partSize - cidrBits;\n\n      if (shift < 0) {\n        shift = 0;\n      }\n\n      if (first[part] >> shift !== second[part] >> shift) {\n        return false;\n      }\n\n      cidrBits -= partSize;\n      part += 1;\n    }\n\n    return true;\n  }\n\n  function parseIntAuto(string) {\n    // Hexadedimal base 16 (0x#)\n    if (hexRegex.test(string)) {\n      return parseInt(string, 16);\n    } // While octal representation is discouraged by ECMAScript 3\n    // and forbidden by ECMAScript 5, we silently allow it to\n    // work only if the rest of the string has numbers less than 8.\n\n\n    if (string[0] === '0' && !isNaN(parseInt(string[1], 10))) {\n      if (octalRegex.test(string)) {\n        return parseInt(string, 8);\n      }\n\n      throw new Error(\"ipaddr: cannot parse \".concat(string, \" as octal\"));\n    } // Always include the base 10 radix!\n\n\n    return parseInt(string, 10);\n  }\n\n  function padPart(part, length) {\n    while (part.length < length) {\n      part = \"0\".concat(part);\n    }\n\n    return part;\n  }\n\n  var ipaddr = {}; // An IPv4 address (RFC791).\n\n  ipaddr.IPv4 = function () {\n    // Constructs a new IPv4 address from an array of four octets\n    // in network order (MSB first)\n    // Verifies the input.\n    function IPv4(octets) {\n      if (octets.length !== 4) {\n        throw new Error('ipaddr: ipv4 octet count should be 4');\n      }\n\n      var i, octet;\n\n      for (i = 0; i < octets.length; i++) {\n        octet = octets[i];\n\n        if (!(0 <= octet && octet <= 255)) {\n          throw new Error('ipaddr: ipv4 octet should fit in 8 bits');\n        }\n      }\n\n      this.octets = octets;\n    } // Special IPv4 address ranges.\n    // See also https://en.wikipedia.org/wiki/Reserved_IP_addresses\n\n\n    IPv4.prototype.SpecialRanges = {\n      unspecified: [[new IPv4([0, 0, 0, 0]), 8]],\n      broadcast: [[new IPv4([255, 255, 255, 255]), 32]],\n      // RFC3171\n      multicast: [[new IPv4([224, 0, 0, 0]), 4]],\n      // RFC3927\n      linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],\n      // RFC5735\n      loopback: [[new IPv4([127, 0, 0, 0]), 8]],\n      // RFC6598\n      carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],\n      // RFC1918\n      'private': [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],\n      // Reserved and testing-only ranges; RFCs 5735, 5737, 2544, 1700\n      reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]]\n    }; // The 'kind' method exists on both IPv4 and IPv6 classes.\n\n    IPv4.prototype.kind = function () {\n      return 'ipv4';\n    }; // Checks if this address matches other one within given CIDR range.\n\n\n    IPv4.prototype.match = function (other, cidrRange) {\n      var ref;\n\n      if (cidrRange === undefined) {\n        ref = other;\n        other = ref[0];\n        cidrRange = ref[1];\n      }\n\n      if (other.kind() !== 'ipv4') {\n        throw new Error('ipaddr: cannot match ipv4 address with non-ipv4 one');\n      }\n\n      return matchCIDR(this.octets, other.octets, 8, cidrRange);\n    }; // returns a number of leading ones in IPv4 address, making sure that\n    // the rest is a solid sequence of 0's (valid netmask)\n    // returns either the CIDR length or null if mask is not valid\n\n\n    IPv4.prototype.prefixLengthFromSubnetMask = function () {\n      var cidr = 0; // non-zero encountered stop scanning for zeroes\n\n      var stop = false; // number of zeroes in octet\n\n      var zerotable = {\n        0: 8,\n        128: 7,\n        192: 6,\n        224: 5,\n        240: 4,\n        248: 3,\n        252: 2,\n        254: 1,\n        255: 0\n      };\n      var i, octet, zeros;\n\n      for (i = 3; i >= 0; i -= 1) {\n        octet = this.octets[i];\n\n        if (octet in zerotable) {\n          zeros = zerotable[octet];\n\n          if (stop && zeros !== 0) {\n            return null;\n          }\n\n          if (zeros !== 8) {\n            stop = true;\n          }\n\n          cidr += zeros;\n        } else {\n          return null;\n        }\n      }\n\n      return 32 - cidr;\n    }; // Checks if the address corresponds to one of the special ranges.\n\n\n    IPv4.prototype.range = function () {\n      return ipaddr.subnetMatch(this, this.SpecialRanges);\n    }; // Returns an array of byte-sized values in network order (MSB first)\n\n\n    IPv4.prototype.toByteArray = function () {\n      return this.octets.slice(0);\n    }; // Converts this IPv4 address to an IPv4-mapped IPv6 address.\n\n\n    IPv4.prototype.toIPv4MappedAddress = function () {\n      return ipaddr.IPv6.parse(\"::ffff:\".concat(this.toString()));\n    }; // Symmetrical method strictly for aligning with the IPv6 methods.\n\n\n    IPv4.prototype.toNormalizedString = function () {\n      return this.toString();\n    }; // Returns the address in convenient, decimal-dotted format.\n\n\n    IPv4.prototype.toString = function () {\n      return this.octets.join('.');\n    };\n\n    return IPv4;\n  }(); // A utility function to return broadcast address given the IPv4 interface and prefix length in CIDR notation\n\n\n  ipaddr.IPv4.broadcastAddressFromCIDR = function (string) {\n    try {\n      var cidr = this.parseCIDR(string);\n      var ipInterfaceOctets = cidr[0].toByteArray();\n      var subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n      var octets = [];\n      var i = 0;\n\n      while (i < 4) {\n        // Broadcast address is bitwise OR between ip interface and inverted mask\n        octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);\n        i++;\n      }\n\n      return new this(octets);\n    } catch (e) {\n      throw new Error('ipaddr: the address does not have IPv4 CIDR format');\n    }\n  }; // Checks if a given string is formatted like IPv4 address.\n\n\n  ipaddr.IPv4.isIPv4 = function (string) {\n    return this.parser(string) !== null;\n  }; // Checks if a given string is a valid IPv4 address.\n\n\n  ipaddr.IPv4.isValid = function (string) {\n    try {\n      new this(this.parser(string));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }; // Checks if a given string is a full four-part IPv4 Address.\n\n\n  ipaddr.IPv4.isValidFourPartDecimal = function (string) {\n    if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){3}$/)) {\n      return true;\n    } else {\n      return false;\n    }\n  }; // A utility function to return network address given the IPv4 interface and prefix length in CIDR notation\n\n\n  ipaddr.IPv4.networkAddressFromCIDR = function (string) {\n    var cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;\n\n    try {\n      cidr = this.parseCIDR(string);\n      ipInterfaceOctets = cidr[0].toByteArray();\n      subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n      octets = [];\n      i = 0;\n\n      while (i < 4) {\n        // Network address is bitwise AND between ip interface and mask\n        octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));\n        i++;\n      }\n\n      return new this(octets);\n    } catch (e) {\n      throw new Error('ipaddr: the address does not have IPv4 CIDR format');\n    }\n  }; // Tries to parse and validate a string with IPv4 address.\n  // Throws an error if it fails.\n\n\n  ipaddr.IPv4.parse = function (string) {\n    var parts = this.parser(string);\n\n    if (parts === null) {\n      throw new Error('ipaddr: string is not formatted like an IPv4 Address');\n    }\n\n    return new this(parts);\n  }; // Parses the string as an IPv4 Address with CIDR Notation.\n\n\n  ipaddr.IPv4.parseCIDR = function (string) {\n    var match;\n\n    if (match = string.match(/^(.+)\\/(\\d+)$/)) {\n      var maskLength = parseInt(match[2]);\n\n      if (maskLength >= 0 && maskLength <= 32) {\n        var parsed = [this.parse(match[1]), maskLength];\n        Object.defineProperty(parsed, 'toString', {\n          value: function value() {\n            return this.join('/');\n          }\n        });\n        return parsed;\n      }\n    }\n\n    throw new Error('ipaddr: string is not formatted like an IPv4 CIDR range');\n  }; // Classful variants (like a.b, where a is an octet, and b is a 24-bit\n  // value representing last three octets; this corresponds to a class C\n  // address) are omitted due to classless nature of modern Internet.\n\n\n  ipaddr.IPv4.parser = function (string) {\n    var match, part, value; // parseInt recognizes all that octal & hexadecimal weirdness for us\n\n    if (match = string.match(ipv4Regexes.fourOctet)) {\n      return function () {\n        var ref = match.slice(1, 6);\n        var results = [];\n\n        for (var i = 0; i < ref.length; i++) {\n          part = ref[i];\n          results.push(parseIntAuto(part));\n        }\n\n        return results;\n      }();\n    } else if (match = string.match(ipv4Regexes.longValue)) {\n      value = parseIntAuto(match[1]);\n\n      if (value > 0xffffffff || value < 0) {\n        throw new Error('ipaddr: address outside defined range');\n      }\n\n      return function () {\n        var results = [];\n        var shift;\n\n        for (shift = 0; shift <= 24; shift += 8) {\n          results.push(value >> shift & 0xff);\n        }\n\n        return results;\n      }().reverse();\n    } else if (match = string.match(ipv4Regexes.twoOctet)) {\n      return function () {\n        var ref = match.slice(1, 4);\n        var results = [];\n        value = parseIntAuto(ref[1]);\n\n        if (value > 0xffffff || value < 0) {\n          throw new Error('ipaddr: address outside defined range');\n        }\n\n        results.push(parseIntAuto(ref[0]));\n        results.push(value >> 16 & 0xff);\n        results.push(value >> 8 & 0xff);\n        results.push(value & 0xff);\n        return results;\n      }();\n    } else if (match = string.match(ipv4Regexes.threeOctet)) {\n      return function () {\n        var ref = match.slice(1, 5);\n        var results = [];\n        value = parseIntAuto(ref[2]);\n\n        if (value > 0xffff || value < 0) {\n          throw new Error('ipaddr: address outside defined range');\n        }\n\n        results.push(parseIntAuto(ref[0]));\n        results.push(parseIntAuto(ref[1]));\n        results.push(value >> 8 & 0xff);\n        results.push(value & 0xff);\n        return results;\n      }();\n    } else {\n      return null;\n    }\n  }; // A utility function to return subnet mask in IPv4 format given the prefix length\n\n\n  ipaddr.IPv4.subnetMaskFromPrefixLength = function (prefix) {\n    prefix = parseInt(prefix);\n\n    if (prefix < 0 || prefix > 32) {\n      throw new Error('ipaddr: invalid IPv4 prefix length');\n    }\n\n    var octets = [0, 0, 0, 0];\n    var j = 0;\n    var filledOctetCount = Math.floor(prefix / 8);\n\n    while (j < filledOctetCount) {\n      octets[j] = 255;\n      j++;\n    }\n\n    if (filledOctetCount < 4) {\n      octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;\n    }\n\n    return new this(octets);\n  }; // An IPv6 address (RFC2460)\n\n\n  ipaddr.IPv6 = function () {\n    // Constructs an IPv6 address from an array of eight 16 - bit parts\n    // or sixteen 8 - bit parts in network order(MSB first).\n    // Throws an error if the input is invalid.\n    function IPv6(parts, zoneId) {\n      var i, part;\n\n      if (parts.length === 16) {\n        this.parts = [];\n\n        for (i = 0; i <= 14; i += 2) {\n          this.parts.push(parts[i] << 8 | parts[i + 1]);\n        }\n      } else if (parts.length === 8) {\n        this.parts = parts;\n      } else {\n        throw new Error('ipaddr: ipv6 part count should be 8 or 16');\n      }\n\n      for (i = 0; i < this.parts.length; i++) {\n        part = this.parts[i];\n\n        if (!(0 <= part && part <= 0xffff)) {\n          throw new Error('ipaddr: ipv6 part should fit in 16 bits');\n        }\n      }\n\n      if (zoneId) {\n        this.zoneId = zoneId;\n      }\n    } // Special IPv6 ranges\n\n\n    IPv6.prototype.SpecialRanges = {\n      // RFC4291, here and after\n      unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],\n      linkLocal: [new IPv6([0xfe80, 0, 0, 0, 0, 0, 0, 0]), 10],\n      multicast: [new IPv6([0xff00, 0, 0, 0, 0, 0, 0, 0]), 8],\n      loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],\n      uniqueLocal: [new IPv6([0xfc00, 0, 0, 0, 0, 0, 0, 0]), 7],\n      ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 0xffff, 0, 0]), 96],\n      // RFC6145\n      rfc6145: [new IPv6([0, 0, 0, 0, 0xffff, 0, 0, 0]), 96],\n      // RFC6052\n      rfc6052: [new IPv6([0x64, 0xff9b, 0, 0, 0, 0, 0, 0]), 96],\n      // RFC3056\n      '6to4': [new IPv6([0x2002, 0, 0, 0, 0, 0, 0, 0]), 16],\n      // RFC6052, RFC6146\n      teredo: [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 32],\n      // RFC4291\n      reserved: [[new IPv6([0x2001, 0xdb8, 0, 0, 0, 0, 0, 0]), 32]]\n    }; // Checks if this address is an IPv4-mapped IPv6 address.\n\n    IPv6.prototype.isIPv4MappedAddress = function () {\n      return this.range() === 'ipv4Mapped';\n    }; // The 'kind' method exists on both IPv4 and IPv6 classes.\n\n\n    IPv6.prototype.kind = function () {\n      return 'ipv6';\n    }; // Checks if this address matches other one within given CIDR range.\n\n\n    IPv6.prototype.match = function (other, cidrRange) {\n      var ref;\n\n      if (cidrRange === undefined) {\n        ref = other;\n        other = ref[0];\n        cidrRange = ref[1];\n      }\n\n      if (other.kind() !== 'ipv6') {\n        throw new Error('ipaddr: cannot match ipv6 address with non-ipv6 one');\n      }\n\n      return matchCIDR(this.parts, other.parts, 16, cidrRange);\n    }; // returns a number of leading ones in IPv6 address, making sure that\n    // the rest is a solid sequence of 0's (valid netmask)\n    // returns either the CIDR length or null if mask is not valid\n\n\n    IPv6.prototype.prefixLengthFromSubnetMask = function () {\n      var cidr = 0; // non-zero encountered stop scanning for zeroes\n\n      var stop = false; // number of zeroes in octet\n\n      var zerotable = {\n        0: 16,\n        32768: 15,\n        49152: 14,\n        57344: 13,\n        61440: 12,\n        63488: 11,\n        64512: 10,\n        65024: 9,\n        65280: 8,\n        65408: 7,\n        65472: 6,\n        65504: 5,\n        65520: 4,\n        65528: 3,\n        65532: 2,\n        65534: 1,\n        65535: 0\n      };\n      var part, zeros;\n\n      for (var i = 7; i >= 0; i -= 1) {\n        part = this.parts[i];\n\n        if (part in zerotable) {\n          zeros = zerotable[part];\n\n          if (stop && zeros !== 0) {\n            return null;\n          }\n\n          if (zeros !== 16) {\n            stop = true;\n          }\n\n          cidr += zeros;\n        } else {\n          return null;\n        }\n      }\n\n      return 128 - cidr;\n    }; // Checks if the address corresponds to one of the special ranges.\n\n\n    IPv6.prototype.range = function () {\n      return ipaddr.subnetMatch(this, this.SpecialRanges);\n    }; // Returns an array of byte-sized values in network order (MSB first)\n\n\n    IPv6.prototype.toByteArray = function () {\n      var part;\n      var bytes = [];\n      var ref = this.parts;\n\n      for (var i = 0; i < ref.length; i++) {\n        part = ref[i];\n        bytes.push(part >> 8);\n        bytes.push(part & 0xff);\n      }\n\n      return bytes;\n    }; // Returns the address in expanded format with all zeroes included, like\n    // 2001:0db8:0008:0066:0000:0000:0000:0001\n\n\n    IPv6.prototype.toFixedLengthString = function () {\n      var addr = function () {\n        var results = [];\n\n        for (var i = 0; i < this.parts.length; i++) {\n          results.push(padPart(this.parts[i].toString(16), 4));\n        }\n\n        return results;\n      }.call(this).join(':');\n\n      var suffix = '';\n\n      if (this.zoneId) {\n        suffix = \"%\".concat(this.zoneId);\n      }\n\n      return addr + suffix;\n    }; // Converts this address to IPv4 address if it is an IPv4-mapped IPv6 address.\n    // Throws an error otherwise.\n\n\n    IPv6.prototype.toIPv4Address = function () {\n      if (!this.isIPv4MappedAddress()) {\n        throw new Error('ipaddr: trying to convert a generic ipv6 address to ipv4');\n      }\n\n      var ref = this.parts.slice(-2);\n      var high = ref[0];\n      var low = ref[1];\n      return new ipaddr.IPv4([high >> 8, high & 0xff, low >> 8, low & 0xff]);\n    }; // Returns the address in expanded format with all zeroes included, like\n    // 2001:db8:8:66:0:0:0:1\n    //\n    // Deprecated: use toFixedLengthString() instead.\n\n\n    IPv6.prototype.toNormalizedString = function () {\n      var addr = function () {\n        var results = [];\n\n        for (var i = 0; i < this.parts.length; i++) {\n          results.push(this.parts[i].toString(16));\n        }\n\n        return results;\n      }.call(this).join(':');\n\n      var suffix = '';\n\n      if (this.zoneId) {\n        suffix = \"%\".concat(this.zoneId);\n      }\n\n      return addr + suffix;\n    }; // Returns the address in compact, human-readable format like\n    // 2001:db8:8:66::1\n    // in line with RFC 5952 (see https://tools.ietf.org/html/rfc5952#section-4)\n\n\n    IPv6.prototype.toRFC5952String = function () {\n      var regex = /((^|:)(0(:|$)){2,})/g;\n      var string = this.toNormalizedString();\n      var bestMatchIndex = 0;\n      var bestMatchLength = -1;\n      var match;\n\n      while (match = regex.exec(string)) {\n        if (match[0].length > bestMatchLength) {\n          bestMatchIndex = match.index;\n          bestMatchLength = match[0].length;\n        }\n      }\n\n      if (bestMatchLength < 0) {\n        return string;\n      }\n\n      return \"\".concat(string.substring(0, bestMatchIndex), \"::\").concat(string.substring(bestMatchIndex + bestMatchLength));\n    }; // Returns the address in compact, human-readable format like\n    // 2001:db8:8:66::1\n    //\n    // Deprecated: use toRFC5952String() instead.\n\n\n    IPv6.prototype.toString = function () {\n      // Replace the first sequence of 1 or more '0' parts with '::'\n      return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, '::');\n    };\n\n    return IPv6;\n  }(); // A utility function to return broadcast address given the IPv6 interface and prefix length in CIDR notation\n\n\n  ipaddr.IPv6.broadcastAddressFromCIDR = function (string) {\n    try {\n      var cidr = this.parseCIDR(string);\n      var ipInterfaceOctets = cidr[0].toByteArray();\n      var subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n      var octets = [];\n      var i = 0;\n\n      while (i < 16) {\n        // Broadcast address is bitwise OR between ip interface and inverted mask\n        octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);\n        i++;\n      }\n\n      return new this(octets);\n    } catch (e) {\n      throw new Error(\"ipaddr: the address does not have IPv6 CIDR format (\".concat(e, \")\"));\n    }\n  }; // Checks if a given string is formatted like IPv6 address.\n\n\n  ipaddr.IPv6.isIPv6 = function (string) {\n    return this.parser(string) !== null;\n  }; // Checks to see if string is a valid IPv6 Address\n\n\n  ipaddr.IPv6.isValid = function (string) {\n    // Since IPv6.isValid is always called first, this shortcut\n    // provides a substantial performance gain.\n    if (typeof string === 'string' && string.indexOf(':') === -1) {\n      return false;\n    }\n\n    try {\n      var addr = this.parser(string);\n      new this(addr.parts, addr.zoneId);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }; // A utility function to return network address given the IPv6 interface and prefix length in CIDR notation\n\n\n  ipaddr.IPv6.networkAddressFromCIDR = function (string) {\n    var cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;\n\n    try {\n      cidr = this.parseCIDR(string);\n      ipInterfaceOctets = cidr[0].toByteArray();\n      subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n      octets = [];\n      i = 0;\n\n      while (i < 16) {\n        // Network address is bitwise AND between ip interface and mask\n        octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));\n        i++;\n      }\n\n      return new this(octets);\n    } catch (e) {\n      throw new Error(\"ipaddr: the address does not have IPv6 CIDR format (\".concat(e, \")\"));\n    }\n  }; // Tries to parse and validate a string with IPv6 address.\n  // Throws an error if it fails.\n\n\n  ipaddr.IPv6.parse = function (string) {\n    var addr = this.parser(string);\n\n    if (addr.parts === null) {\n      throw new Error('ipaddr: string is not formatted like an IPv6 Address');\n    }\n\n    return new this(addr.parts, addr.zoneId);\n  };\n\n  ipaddr.IPv6.parseCIDR = function (string) {\n    var maskLength, match, parsed;\n\n    if (match = string.match(/^(.+)\\/(\\d+)$/)) {\n      maskLength = parseInt(match[2]);\n\n      if (maskLength >= 0 && maskLength <= 128) {\n        parsed = [this.parse(match[1]), maskLength];\n        Object.defineProperty(parsed, 'toString', {\n          value: function value() {\n            return this.join('/');\n          }\n        });\n        return parsed;\n      }\n    }\n\n    throw new Error('ipaddr: string is not formatted like an IPv6 CIDR range');\n  }; // Parse an IPv6 address.\n\n\n  ipaddr.IPv6.parser = function (string) {\n    var addr, i, match, octet, octets, zoneId;\n\n    if (match = string.match(ipv6Regexes.deprecatedTransitional)) {\n      return this.parser(\"::ffff:\".concat(match[1]));\n    }\n\n    if (ipv6Regexes.native.test(string)) {\n      return expandIPv6(string, 8);\n    }\n\n    if (match = string.match(ipv6Regexes.transitional)) {\n      zoneId = match[6] || '';\n      addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);\n\n      if (addr.parts) {\n        octets = [parseInt(match[2]), parseInt(match[3]), parseInt(match[4]), parseInt(match[5])];\n\n        for (i = 0; i < octets.length; i++) {\n          octet = octets[i];\n\n          if (!(0 <= octet && octet <= 255)) {\n            return null;\n          }\n        }\n\n        addr.parts.push(octets[0] << 8 | octets[1]);\n        addr.parts.push(octets[2] << 8 | octets[3]);\n        return {\n          parts: addr.parts,\n          zoneId: addr.zoneId\n        };\n      }\n    }\n\n    return null;\n  }; // A utility function to return subnet mask in IPv6 format given the prefix length\n\n\n  ipaddr.IPv6.subnetMaskFromPrefixLength = function (prefix) {\n    prefix = parseInt(prefix);\n\n    if (prefix < 0 || prefix > 128) {\n      throw new Error('ipaddr: invalid IPv6 prefix length');\n    }\n\n    var octets = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    var j = 0;\n    var filledOctetCount = Math.floor(prefix / 8);\n\n    while (j < filledOctetCount) {\n      octets[j] = 255;\n      j++;\n    }\n\n    if (filledOctetCount < 16) {\n      octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;\n    }\n\n    return new this(octets);\n  }; // Try to parse an array in network order (MSB first) for IPv4 and IPv6\n\n\n  ipaddr.fromByteArray = function (bytes) {\n    var length = bytes.length;\n\n    if (length === 4) {\n      return new ipaddr.IPv4(bytes);\n    } else if (length === 16) {\n      return new ipaddr.IPv6(bytes);\n    } else {\n      throw new Error('ipaddr: the binary input is neither an IPv6 nor IPv4 address');\n    }\n  }; // Checks if the address is valid IP address\n\n\n  ipaddr.isValid = function (string) {\n    return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);\n  }; // Attempts to parse an IP Address, first through IPv6 then IPv4.\n  // Throws an error if it could not be parsed.\n\n\n  ipaddr.parse = function (string) {\n    if (ipaddr.IPv6.isValid(string)) {\n      return ipaddr.IPv6.parse(string);\n    } else if (ipaddr.IPv4.isValid(string)) {\n      return ipaddr.IPv4.parse(string);\n    } else {\n      throw new Error('ipaddr: the address has neither IPv6 nor IPv4 format');\n    }\n  }; // Attempt to parse CIDR notation, first through IPv6 then IPv4.\n  // Throws an error if it could not be parsed.\n\n\n  ipaddr.parseCIDR = function (string) {\n    try {\n      return ipaddr.IPv6.parseCIDR(string);\n    } catch (e) {\n      try {\n        return ipaddr.IPv4.parseCIDR(string);\n      } catch (e2) {\n        throw new Error('ipaddr: the address has neither IPv6 nor IPv4 CIDR format');\n      }\n    }\n  }; // Parse an address and return plain IPv4 address if it is an IPv4-mapped address\n\n\n  ipaddr.process = function (string) {\n    var addr = this.parse(string);\n\n    if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress()) {\n      return addr.toIPv4Address();\n    } else {\n      return addr;\n    }\n  }; // An utility function to ease named range matching. See examples below.\n  // rangeList can contain both IPv4 and IPv6 subnet entries and will not throw errors\n  // on matching IPv4 addresses to IPv6 ranges or vice versa.\n\n\n  ipaddr.subnetMatch = function (address, rangeList, defaultName) {\n    var i, rangeName, rangeSubnets, subnet;\n\n    if (defaultName === undefined || defaultName === null) {\n      defaultName = 'unicast';\n    }\n\n    for (rangeName in rangeList) {\n      if (Object.prototype.hasOwnProperty.call(rangeList, rangeName)) {\n        rangeSubnets = rangeList[rangeName]; // ECMA5 Array.isArray isn't available everywhere\n\n        if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {\n          rangeSubnets = [rangeSubnets];\n        }\n\n        for (i = 0; i < rangeSubnets.length; i++) {\n          subnet = rangeSubnets[i];\n\n          if (address.kind() === subnet[0].kind() && address.match.apply(address, subnet)) {\n            return rangeName;\n          }\n        }\n      }\n    }\n\n    return defaultName;\n  }; // Export for both the CommonJS and browser-like environment\n\n\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = ipaddr;\n  } else {\n    root.ipaddr = ipaddr;\n  }\n})(this);","map":{"version":3,"names":["root","ipv4Part","ipv4Regexes","fourOctet","RegExp","threeOctet","twoOctet","longValue","octalRegex","hexRegex","zoneIndex","ipv6Part","ipv6Regexes","deprecatedTransitional","transitional","expandIPv6","string","parts","indexOf","lastIndexOf","colonCount","lastColon","zoneId","match","replacement","replacementCount","substring","replace","substr","slice","length","ref","split","results","i","push","parseInt","matchCIDR","first","second","partSize","cidrBits","Error","part","shift","parseIntAuto","test","isNaN","padPart","ipaddr","IPv4","octets","octet","prototype","SpecialRanges","unspecified","broadcast","multicast","linkLocal","loopback","carrierGradeNat","reserved","kind","other","cidrRange","undefined","prefixLengthFromSubnetMask","cidr","stop","zerotable","zeros","range","subnetMatch","toByteArray","toIPv4MappedAddress","IPv6","parse","toString","toNormalizedString","join","broadcastAddressFromCIDR","parseCIDR","ipInterfaceOctets","subnetMaskOctets","subnetMaskFromPrefixLength","e","isIPv4","parser","isValid","isValidFourPartDecimal","networkAddressFromCIDR","maskLength","parsed","Object","defineProperty","value","reverse","prefix","j","filledOctetCount","Math","floor","pow","uniqueLocal","ipv4Mapped","rfc6145","rfc6052","teredo","isIPv4MappedAddress","bytes","toFixedLengthString","addr","call","suffix","toIPv4Address","high","low","toRFC5952String","regex","bestMatchIndex","bestMatchLength","exec","index","isIPv6","native","fromByteArray","e2","process","address","rangeList","defaultName","rangeName","rangeSubnets","subnet","hasOwnProperty","Array","apply","module","exports"],"sources":["/mnt/Datengrab/python/Zero-tier/frontend/node_modules/ipaddr.js/lib/ipaddr.js"],"sourcesContent":["(function (root) {\n    'use strict';\n    // A list of regular expressions that match arbitrary IPv4 addresses,\n    // for which a number of weird notations exist.\n    // Note that an address like 0010.0xa5.1.1 is considered legal.\n    const ipv4Part = '(0?\\\\d+|0x[a-f0-9]+)';\n    const ipv4Regexes = {\n        fourOctet: new RegExp(`^${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}$`, 'i'),\n        threeOctet: new RegExp(`^${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}$`, 'i'),\n        twoOctet: new RegExp(`^${ipv4Part}\\\\.${ipv4Part}$`, 'i'),\n        longValue: new RegExp(`^${ipv4Part}$`, 'i')\n    };\n\n    // Regular Expression for checking Octal numbers\n    const octalRegex = new RegExp(`^0[0-7]+$`, 'i');\n    const hexRegex = new RegExp(`^0x[a-f0-9]+$`, 'i');\n\n    const zoneIndex = '%[0-9a-z]{1,}';\n\n    // IPv6-matching regular expressions.\n    // For IPv6, the task is simpler: it is enough to match the colon-delimited\n    // hexadecimal IPv6 and a transitional variant with dotted-decimal IPv4 at\n    // the end.\n    const ipv6Part = '(?:[0-9a-f]+::?)+';\n    const ipv6Regexes = {\n        zoneIndex: new RegExp(zoneIndex, 'i'),\n        'native': new RegExp(`^(::)?(${ipv6Part})?([0-9a-f]+)?(::)?(${zoneIndex})?$`, 'i'),\n        deprecatedTransitional: new RegExp(`^(?:::)(${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}(${zoneIndex})?)$`, 'i'),\n        transitional: new RegExp(`^((?:${ipv6Part})|(?:::)(?:${ipv6Part})?)${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}(${zoneIndex})?$`, 'i')\n    };\n\n    // Expand :: in an IPv6 address or address part consisting of `parts` groups.\n    function expandIPv6 (string, parts) {\n        // More than one '::' means invalid adddress\n        if (string.indexOf('::') !== string.lastIndexOf('::')) {\n            return null;\n        }\n\n        let colonCount = 0;\n        let lastColon = -1;\n        let zoneId = (string.match(ipv6Regexes.zoneIndex) || [])[0];\n        let replacement, replacementCount;\n\n        // Remove zone index and save it for later\n        if (zoneId) {\n            zoneId = zoneId.substring(1);\n            string = string.replace(/%.+$/, '');\n        }\n\n        // How many parts do we already have?\n        while ((lastColon = string.indexOf(':', lastColon + 1)) >= 0) {\n            colonCount++;\n        }\n\n        // 0::0 is two parts more than ::\n        if (string.substr(0, 2) === '::') {\n            colonCount--;\n        }\n\n        if (string.substr(-2, 2) === '::') {\n            colonCount--;\n        }\n\n        // The following loop would hang if colonCount > parts\n        if (colonCount > parts) {\n            return null;\n        }\n\n        // replacement = ':' + '0:' * (parts - colonCount)\n        replacementCount = parts - colonCount;\n        replacement = ':';\n        while (replacementCount--) {\n            replacement += '0:';\n        }\n\n        // Insert the missing zeroes\n        string = string.replace('::', replacement);\n\n        // Trim any garbage which may be hanging around if :: was at the edge in\n        // the source strin\n        if (string[0] === ':') {\n            string = string.slice(1);\n        }\n\n        if (string[string.length - 1] === ':') {\n            string = string.slice(0, -1);\n        }\n\n        parts = (function () {\n            const ref = string.split(':');\n            const results = [];\n\n            for (let i = 0; i < ref.length; i++) {\n                results.push(parseInt(ref[i], 16));\n            }\n\n            return results;\n        })();\n\n        return {\n            parts: parts,\n            zoneId: zoneId\n        };\n    }\n\n    // A generic CIDR (Classless Inter-Domain Routing) RFC1518 range matcher.\n    function matchCIDR (first, second, partSize, cidrBits) {\n        if (first.length !== second.length) {\n            throw new Error('ipaddr: cannot match CIDR for objects with different lengths');\n        }\n\n        let part = 0;\n        let shift;\n\n        while (cidrBits > 0) {\n            shift = partSize - cidrBits;\n            if (shift < 0) {\n                shift = 0;\n            }\n\n            if (first[part] >> shift !== second[part] >> shift) {\n                return false;\n            }\n\n            cidrBits -= partSize;\n            part += 1;\n        }\n\n        return true;\n    }\n\n    function parseIntAuto (string) {\n        // Hexadedimal base 16 (0x#)\n        if (hexRegex.test(string)) {\n            return parseInt(string, 16);\n        }\n        // While octal representation is discouraged by ECMAScript 3\n        // and forbidden by ECMAScript 5, we silently allow it to\n        // work only if the rest of the string has numbers less than 8.\n        if (string[0] === '0' && !isNaN(parseInt(string[1], 10))) {\n        if (octalRegex.test(string)) {\n            return parseInt(string, 8);\n        }\n            throw new Error(`ipaddr: cannot parse ${string} as octal`);\n        }\n        // Always include the base 10 radix!\n        return parseInt(string, 10);\n    }\n\n    function padPart (part, length) {\n        while (part.length < length) {\n            part = `0${part}`;\n        }\n\n        return part;\n    }\n\n    const ipaddr = {};\n\n    // An IPv4 address (RFC791).\n    ipaddr.IPv4 = (function () {\n        // Constructs a new IPv4 address from an array of four octets\n        // in network order (MSB first)\n        // Verifies the input.\n        function IPv4 (octets) {\n            if (octets.length !== 4) {\n                throw new Error('ipaddr: ipv4 octet count should be 4');\n            }\n\n            let i, octet;\n\n            for (i = 0; i < octets.length; i++) {\n                octet = octets[i];\n                if (!((0 <= octet && octet <= 255))) {\n                    throw new Error('ipaddr: ipv4 octet should fit in 8 bits');\n                }\n            }\n\n            this.octets = octets;\n        }\n\n        // Special IPv4 address ranges.\n        // See also https://en.wikipedia.org/wiki/Reserved_IP_addresses\n        IPv4.prototype.SpecialRanges = {\n            unspecified: [[new IPv4([0, 0, 0, 0]), 8]],\n            broadcast: [[new IPv4([255, 255, 255, 255]), 32]],\n            // RFC3171\n            multicast: [[new IPv4([224, 0, 0, 0]), 4]],\n            // RFC3927\n            linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],\n            // RFC5735\n            loopback: [[new IPv4([127, 0, 0, 0]), 8]],\n            // RFC6598\n            carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],\n            // RFC1918\n            'private': [\n                [new IPv4([10, 0, 0, 0]), 8],\n                [new IPv4([172, 16, 0, 0]), 12],\n                [new IPv4([192, 168, 0, 0]), 16]\n            ],\n            // Reserved and testing-only ranges; RFCs 5735, 5737, 2544, 1700\n            reserved: [\n                [new IPv4([192, 0, 0, 0]), 24],\n                [new IPv4([192, 0, 2, 0]), 24],\n                [new IPv4([192, 88, 99, 0]), 24],\n                [new IPv4([198, 51, 100, 0]), 24],\n                [new IPv4([203, 0, 113, 0]), 24],\n                [new IPv4([240, 0, 0, 0]), 4]\n            ]\n        };\n\n        // The 'kind' method exists on both IPv4 and IPv6 classes.\n        IPv4.prototype.kind = function () {\n            return 'ipv4';\n        };\n\n        // Checks if this address matches other one within given CIDR range.\n        IPv4.prototype.match = function (other, cidrRange) {\n            let ref;\n            if (cidrRange === undefined) {\n                ref = other;\n                other = ref[0];\n                cidrRange = ref[1];\n            }\n\n            if (other.kind() !== 'ipv4') {\n                throw new Error('ipaddr: cannot match ipv4 address with non-ipv4 one');\n            }\n\n            return matchCIDR(this.octets, other.octets, 8, cidrRange);\n        };\n\n        // returns a number of leading ones in IPv4 address, making sure that\n        // the rest is a solid sequence of 0's (valid netmask)\n        // returns either the CIDR length or null if mask is not valid\n        IPv4.prototype.prefixLengthFromSubnetMask = function () {\n            let cidr = 0;\n            // non-zero encountered stop scanning for zeroes\n            let stop = false;\n            // number of zeroes in octet\n            const zerotable = {\n                0: 8,\n                128: 7,\n                192: 6,\n                224: 5,\n                240: 4,\n                248: 3,\n                252: 2,\n                254: 1,\n                255: 0\n            };\n            let i, octet, zeros;\n\n            for (i = 3; i >= 0; i -= 1) {\n                octet = this.octets[i];\n                if (octet in zerotable) {\n                    zeros = zerotable[octet];\n                    if (stop && zeros !== 0) {\n                        return null;\n                    }\n\n                    if (zeros !== 8) {\n                        stop = true;\n                    }\n\n                    cidr += zeros;\n                } else {\n                    return null;\n                }\n            }\n\n            return 32 - cidr;\n        };\n\n        // Checks if the address corresponds to one of the special ranges.\n        IPv4.prototype.range = function () {\n            return ipaddr.subnetMatch(this, this.SpecialRanges);\n        };\n\n        // Returns an array of byte-sized values in network order (MSB first)\n        IPv4.prototype.toByteArray = function () {\n            return this.octets.slice(0);\n        };\n\n        // Converts this IPv4 address to an IPv4-mapped IPv6 address.\n        IPv4.prototype.toIPv4MappedAddress = function () {\n            return ipaddr.IPv6.parse(`::ffff:${this.toString()}`);\n        };\n\n        // Symmetrical method strictly for aligning with the IPv6 methods.\n        IPv4.prototype.toNormalizedString = function () {\n            return this.toString();\n        };\n\n        // Returns the address in convenient, decimal-dotted format.\n        IPv4.prototype.toString = function () {\n            return this.octets.join('.');\n        };\n\n        return IPv4;\n    })();\n\n    // A utility function to return broadcast address given the IPv4 interface and prefix length in CIDR notation\n    ipaddr.IPv4.broadcastAddressFromCIDR = function (string) {\n\n        try {\n            const cidr = this.parseCIDR(string);\n            const ipInterfaceOctets = cidr[0].toByteArray();\n            const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            const octets = [];\n            let i = 0;\n            while (i < 4) {\n                // Broadcast address is bitwise OR between ip interface and inverted mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);\n                i++;\n            }\n\n            return new this(octets);\n        } catch (e) {\n            throw new Error('ipaddr: the address does not have IPv4 CIDR format');\n        }\n    };\n\n    // Checks if a given string is formatted like IPv4 address.\n    ipaddr.IPv4.isIPv4 = function (string) {\n        return this.parser(string) !== null;\n    };\n\n    // Checks if a given string is a valid IPv4 address.\n    ipaddr.IPv4.isValid = function (string) {\n        try {\n            new this(this.parser(string));\n            return true;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    // Checks if a given string is a full four-part IPv4 Address.\n    ipaddr.IPv4.isValidFourPartDecimal = function (string) {\n        if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){3}$/)) {\n            return true;\n        } else {\n            return false;\n        }\n    };\n\n    // A utility function to return network address given the IPv4 interface and prefix length in CIDR notation\n    ipaddr.IPv4.networkAddressFromCIDR = function (string) {\n        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;\n\n        try {\n            cidr = this.parseCIDR(string);\n            ipInterfaceOctets = cidr[0].toByteArray();\n            subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            octets = [];\n            i = 0;\n            while (i < 4) {\n                // Network address is bitwise AND between ip interface and mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));\n                i++;\n            }\n\n            return new this(octets);\n        } catch (e) {\n            throw new Error('ipaddr: the address does not have IPv4 CIDR format');\n        }\n    };\n\n    // Tries to parse and validate a string with IPv4 address.\n    // Throws an error if it fails.\n    ipaddr.IPv4.parse = function (string) {\n        const parts = this.parser(string);\n\n        if (parts === null) {\n            throw new Error('ipaddr: string is not formatted like an IPv4 Address');\n        }\n\n        return new this(parts);\n    };\n\n    // Parses the string as an IPv4 Address with CIDR Notation.\n    ipaddr.IPv4.parseCIDR = function (string) {\n        let match;\n\n        if ((match = string.match(/^(.+)\\/(\\d+)$/))) {\n            const maskLength = parseInt(match[2]);\n            if (maskLength >= 0 && maskLength <= 32) {\n                const parsed = [this.parse(match[1]), maskLength];\n                Object.defineProperty(parsed, 'toString', {\n                    value: function () {\n                        return this.join('/');\n                    }\n                });\n                return parsed;\n            }\n        }\n\n        throw new Error('ipaddr: string is not formatted like an IPv4 CIDR range');\n    };\n\n    // Classful variants (like a.b, where a is an octet, and b is a 24-bit\n    // value representing last three octets; this corresponds to a class C\n    // address) are omitted due to classless nature of modern Internet.\n    ipaddr.IPv4.parser = function (string) {\n        let match, part, value;\n\n        // parseInt recognizes all that octal & hexadecimal weirdness for us\n        if ((match = string.match(ipv4Regexes.fourOctet))) {\n            return (function () {\n                const ref = match.slice(1, 6);\n                const results = [];\n\n                for (let i = 0; i < ref.length; i++) {\n                    part = ref[i];\n                    results.push(parseIntAuto(part));\n                }\n\n                return results;\n            })();\n        } else if ((match = string.match(ipv4Regexes.longValue))) {\n            value = parseIntAuto(match[1]);\n            if (value > 0xffffffff || value < 0) {\n                throw new Error('ipaddr: address outside defined range');\n            }\n\n            return ((function () {\n                const results = [];\n                let shift;\n\n                for (shift = 0; shift <= 24; shift += 8) {\n                    results.push((value >> shift) & 0xff);\n                }\n\n                return results;\n            })()).reverse();\n        } else if ((match = string.match(ipv4Regexes.twoOctet))) {\n            return (function () {\n                const ref = match.slice(1, 4);\n                const results = [];\n\n                value = parseIntAuto(ref[1]);\n                if (value > 0xffffff || value < 0) {\n                    throw new Error('ipaddr: address outside defined range');\n                }\n\n                results.push(parseIntAuto(ref[0]));\n                results.push((value >> 16) & 0xff);\n                results.push((value >>  8) & 0xff);\n                results.push( value        & 0xff);\n\n                return results;\n            })();\n        } else if ((match = string.match(ipv4Regexes.threeOctet))) {\n            return (function () {\n                const ref = match.slice(1, 5);\n                const results = [];\n\n                value = parseIntAuto(ref[2]);\n                if (value > 0xffff || value < 0) {\n                    throw new Error('ipaddr: address outside defined range');\n                }\n\n                results.push(parseIntAuto(ref[0]));\n                results.push(parseIntAuto(ref[1]));\n                results.push((value >> 8) & 0xff);\n                results.push( value       & 0xff);\n\n                return results;\n            })();\n        } else {\n            return null;\n        }\n    };\n\n    // A utility function to return subnet mask in IPv4 format given the prefix length\n    ipaddr.IPv4.subnetMaskFromPrefixLength = function (prefix) {\n        prefix = parseInt(prefix);\n        if (prefix < 0 || prefix > 32) {\n            throw new Error('ipaddr: invalid IPv4 prefix length');\n        }\n\n        const octets = [0, 0, 0, 0];\n        let j = 0;\n        const filledOctetCount = Math.floor(prefix / 8);\n\n        while (j < filledOctetCount) {\n            octets[j] = 255;\n            j++;\n        }\n\n        if (filledOctetCount < 4) {\n            octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - (prefix % 8);\n        }\n\n        return new this(octets);\n    };\n\n    // An IPv6 address (RFC2460)\n    ipaddr.IPv6 = (function () {\n        // Constructs an IPv6 address from an array of eight 16 - bit parts\n        // or sixteen 8 - bit parts in network order(MSB first).\n        // Throws an error if the input is invalid.\n        function IPv6 (parts, zoneId) {\n            let i, part;\n\n            if (parts.length === 16) {\n                this.parts = [];\n                for (i = 0; i <= 14; i += 2) {\n                    this.parts.push((parts[i] << 8) | parts[i + 1]);\n                }\n            } else if (parts.length === 8) {\n                this.parts = parts;\n            } else {\n                throw new Error('ipaddr: ipv6 part count should be 8 or 16');\n            }\n\n            for (i = 0; i < this.parts.length; i++) {\n                part = this.parts[i];\n                if (!((0 <= part && part <= 0xffff))) {\n                    throw new Error('ipaddr: ipv6 part should fit in 16 bits');\n                }\n            }\n\n            if (zoneId) {\n                this.zoneId = zoneId;\n            }\n        }\n\n        // Special IPv6 ranges\n        IPv6.prototype.SpecialRanges = {\n            // RFC4291, here and after\n            unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],\n            linkLocal: [new IPv6([0xfe80, 0, 0, 0, 0, 0, 0, 0]), 10],\n            multicast: [new IPv6([0xff00, 0, 0, 0, 0, 0, 0, 0]), 8],\n            loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],\n            uniqueLocal: [new IPv6([0xfc00, 0, 0, 0, 0, 0, 0, 0]), 7],\n            ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 0xffff, 0, 0]), 96],\n            // RFC6145\n            rfc6145: [new IPv6([0, 0, 0, 0, 0xffff, 0, 0, 0]), 96],\n            // RFC6052\n            rfc6052: [new IPv6([0x64, 0xff9b, 0, 0, 0, 0, 0, 0]), 96],\n            // RFC3056\n            '6to4': [new IPv6([0x2002, 0, 0, 0, 0, 0, 0, 0]), 16],\n            // RFC6052, RFC6146\n            teredo: [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 32],\n            // RFC4291\n            reserved: [[new IPv6([0x2001, 0xdb8, 0, 0, 0, 0, 0, 0]), 32]]\n        };\n\n        // Checks if this address is an IPv4-mapped IPv6 address.\n        IPv6.prototype.isIPv4MappedAddress = function () {\n            return this.range() === 'ipv4Mapped';\n        };\n\n        // The 'kind' method exists on both IPv4 and IPv6 classes.\n        IPv6.prototype.kind = function () {\n            return 'ipv6';\n        };\n\n        // Checks if this address matches other one within given CIDR range.\n        IPv6.prototype.match = function (other, cidrRange) {\n            let ref;\n\n            if (cidrRange === undefined) {\n                ref = other;\n                other = ref[0];\n                cidrRange = ref[1];\n            }\n\n            if (other.kind() !== 'ipv6') {\n                throw new Error('ipaddr: cannot match ipv6 address with non-ipv6 one');\n            }\n\n            return matchCIDR(this.parts, other.parts, 16, cidrRange);\n        };\n\n        // returns a number of leading ones in IPv6 address, making sure that\n        // the rest is a solid sequence of 0's (valid netmask)\n        // returns either the CIDR length or null if mask is not valid\n        IPv6.prototype.prefixLengthFromSubnetMask = function () {\n            let cidr = 0;\n            // non-zero encountered stop scanning for zeroes\n            let stop = false;\n            // number of zeroes in octet\n            const zerotable = {\n                0: 16,\n                32768: 15,\n                49152: 14,\n                57344: 13,\n                61440: 12,\n                63488: 11,\n                64512: 10,\n                65024: 9,\n                65280: 8,\n                65408: 7,\n                65472: 6,\n                65504: 5,\n                65520: 4,\n                65528: 3,\n                65532: 2,\n                65534: 1,\n                65535: 0\n            };\n            let part, zeros;\n\n            for (let i = 7; i >= 0; i -= 1) {\n                part = this.parts[i];\n                if (part in zerotable) {\n                    zeros = zerotable[part];\n                    if (stop && zeros !== 0) {\n                        return null;\n                    }\n\n                    if (zeros !== 16) {\n                        stop = true;\n                    }\n\n                    cidr += zeros;\n                } else {\n                    return null;\n                }\n            }\n\n            return 128 - cidr;\n        };\n\n\n        // Checks if the address corresponds to one of the special ranges.\n        IPv6.prototype.range = function () {\n            return ipaddr.subnetMatch(this, this.SpecialRanges);\n        };\n\n        // Returns an array of byte-sized values in network order (MSB first)\n        IPv6.prototype.toByteArray = function () {\n            let part;\n            const bytes = [];\n            const ref = this.parts;\n            for (let i = 0; i < ref.length; i++) {\n                part = ref[i];\n                bytes.push(part >> 8);\n                bytes.push(part & 0xff);\n            }\n\n            return bytes;\n        };\n\n        // Returns the address in expanded format with all zeroes included, like\n        // 2001:0db8:0008:0066:0000:0000:0000:0001\n        IPv6.prototype.toFixedLengthString = function () {\n            const addr = ((function () {\n                const results = [];\n                for (let i = 0; i < this.parts.length; i++) {\n                    results.push(padPart(this.parts[i].toString(16), 4));\n                }\n\n                return results;\n            }).call(this)).join(':');\n\n            let suffix = '';\n\n            if (this.zoneId) {\n                suffix = `%${this.zoneId}`;\n            }\n\n            return addr + suffix;\n        };\n\n        // Converts this address to IPv4 address if it is an IPv4-mapped IPv6 address.\n        // Throws an error otherwise.\n        IPv6.prototype.toIPv4Address = function () {\n            if (!this.isIPv4MappedAddress()) {\n                throw new Error('ipaddr: trying to convert a generic ipv6 address to ipv4');\n            }\n\n            const ref = this.parts.slice(-2);\n            const high = ref[0];\n            const low = ref[1];\n\n            return new ipaddr.IPv4([high >> 8, high & 0xff, low >> 8, low & 0xff]);\n        };\n\n        // Returns the address in expanded format with all zeroes included, like\n        // 2001:db8:8:66:0:0:0:1\n        //\n        // Deprecated: use toFixedLengthString() instead.\n        IPv6.prototype.toNormalizedString = function () {\n            const addr = ((function () {\n                const results = [];\n\n                for (let i = 0; i < this.parts.length; i++) {\n                    results.push(this.parts[i].toString(16));\n                }\n\n                return results;\n            }).call(this)).join(':');\n\n            let suffix = '';\n\n            if (this.zoneId) {\n                suffix = `%${this.zoneId}`;\n            }\n\n            return addr + suffix;\n        };\n\n        // Returns the address in compact, human-readable format like\n        // 2001:db8:8:66::1\n        // in line with RFC 5952 (see https://tools.ietf.org/html/rfc5952#section-4)\n        IPv6.prototype.toRFC5952String = function () {\n            const regex = /((^|:)(0(:|$)){2,})/g;\n            const string = this.toNormalizedString();\n            let bestMatchIndex = 0;\n            let bestMatchLength = -1;\n            let match;\n\n            while ((match = regex.exec(string))) {\n                if (match[0].length > bestMatchLength) {\n                    bestMatchIndex = match.index;\n                    bestMatchLength = match[0].length;\n                }\n            }\n\n            if (bestMatchLength < 0) {\n                return string;\n            }\n\n            return `${string.substring(0, bestMatchIndex)}::${string.substring(bestMatchIndex + bestMatchLength)}`;\n        };\n\n        // Returns the address in compact, human-readable format like\n        // 2001:db8:8:66::1\n        //\n        // Deprecated: use toRFC5952String() instead.\n        IPv6.prototype.toString = function () {\n            // Replace the first sequence of 1 or more '0' parts with '::'\n            return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, '::');\n        };\n\n        return IPv6;\n\n    })();\n\n    // A utility function to return broadcast address given the IPv6 interface and prefix length in CIDR notation\n    ipaddr.IPv6.broadcastAddressFromCIDR = function (string) {\n        try {\n            const cidr = this.parseCIDR(string);\n            const ipInterfaceOctets = cidr[0].toByteArray();\n            const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            const octets = [];\n            let i = 0;\n            while (i < 16) {\n                // Broadcast address is bitwise OR between ip interface and inverted mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);\n                i++;\n            }\n\n            return new this(octets);\n        } catch (e) {\n            throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);\n        }\n    };\n\n    // Checks if a given string is formatted like IPv6 address.\n    ipaddr.IPv6.isIPv6 = function (string) {\n        return this.parser(string) !== null;\n    };\n\n    // Checks to see if string is a valid IPv6 Address\n    ipaddr.IPv6.isValid = function (string) {\n\n        // Since IPv6.isValid is always called first, this shortcut\n        // provides a substantial performance gain.\n        if (typeof string === 'string' && string.indexOf(':') === -1) {\n            return false;\n        }\n\n        try {\n            const addr = this.parser(string);\n            new this(addr.parts, addr.zoneId);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    // A utility function to return network address given the IPv6 interface and prefix length in CIDR notation\n    ipaddr.IPv6.networkAddressFromCIDR = function (string) {\n        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;\n\n        try {\n            cidr = this.parseCIDR(string);\n            ipInterfaceOctets = cidr[0].toByteArray();\n            subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            octets = [];\n            i = 0;\n            while (i < 16) {\n                // Network address is bitwise AND between ip interface and mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));\n                i++;\n            }\n\n            return new this(octets);\n        } catch (e) {\n            throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);\n        }\n    };\n\n    // Tries to parse and validate a string with IPv6 address.\n    // Throws an error if it fails.\n    ipaddr.IPv6.parse = function (string) {\n        const addr = this.parser(string);\n\n        if (addr.parts === null) {\n            throw new Error('ipaddr: string is not formatted like an IPv6 Address');\n        }\n\n        return new this(addr.parts, addr.zoneId);\n    };\n\n    ipaddr.IPv6.parseCIDR = function (string) {\n        let maskLength, match, parsed;\n\n        if ((match = string.match(/^(.+)\\/(\\d+)$/))) {\n            maskLength = parseInt(match[2]);\n            if (maskLength >= 0 && maskLength <= 128) {\n                parsed = [this.parse(match[1]), maskLength];\n                Object.defineProperty(parsed, 'toString', {\n                    value: function () {\n                        return this.join('/');\n                    }\n                });\n                return parsed;\n            }\n        }\n\n        throw new Error('ipaddr: string is not formatted like an IPv6 CIDR range');\n    };\n\n    // Parse an IPv6 address.\n    ipaddr.IPv6.parser = function (string) {\n        let addr, i, match, octet, octets, zoneId;\n\n        if ((match = string.match(ipv6Regexes.deprecatedTransitional))) {\n            return this.parser(`::ffff:${match[1]}`);\n        }\n        if (ipv6Regexes.native.test(string)) {\n            return expandIPv6(string, 8);\n        }\n        if ((match = string.match(ipv6Regexes.transitional))) {\n            zoneId = match[6] || '';\n            addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);\n            if (addr.parts) {\n                octets = [\n                    parseInt(match[2]),\n                    parseInt(match[3]),\n                    parseInt(match[4]),\n                    parseInt(match[5])\n                ];\n                for (i = 0; i < octets.length; i++) {\n                    octet = octets[i];\n                    if (!((0 <= octet && octet <= 255))) {\n                        return null;\n                    }\n                }\n\n                addr.parts.push(octets[0] << 8 | octets[1]);\n                addr.parts.push(octets[2] << 8 | octets[3]);\n                return {\n                    parts: addr.parts,\n                    zoneId: addr.zoneId\n                };\n            }\n        }\n\n        return null;\n    };\n\n    // A utility function to return subnet mask in IPv6 format given the prefix length\n    ipaddr.IPv6.subnetMaskFromPrefixLength = function (prefix) {\n        prefix = parseInt(prefix);\n        if (prefix < 0 || prefix > 128) {\n            throw new Error('ipaddr: invalid IPv6 prefix length');\n        }\n\n        const octets = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        let j = 0;\n        const filledOctetCount = Math.floor(prefix / 8);\n\n        while (j < filledOctetCount) {\n            octets[j] = 255;\n            j++;\n        }\n\n        if (filledOctetCount < 16) {\n            octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - (prefix % 8);\n        }\n\n        return new this(octets);\n    };\n\n    // Try to parse an array in network order (MSB first) for IPv4 and IPv6\n    ipaddr.fromByteArray = function (bytes) {\n        const length = bytes.length;\n\n        if (length === 4) {\n            return new ipaddr.IPv4(bytes);\n        } else if (length === 16) {\n            return new ipaddr.IPv6(bytes);\n        } else {\n            throw new Error('ipaddr: the binary input is neither an IPv6 nor IPv4 address');\n        }\n    };\n\n    // Checks if the address is valid IP address\n    ipaddr.isValid = function (string) {\n        return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);\n    };\n\n\n    // Attempts to parse an IP Address, first through IPv6 then IPv4.\n    // Throws an error if it could not be parsed.\n    ipaddr.parse = function (string) {\n        if (ipaddr.IPv6.isValid(string)) {\n            return ipaddr.IPv6.parse(string);\n        } else if (ipaddr.IPv4.isValid(string)) {\n            return ipaddr.IPv4.parse(string);\n        } else {\n            throw new Error('ipaddr: the address has neither IPv6 nor IPv4 format');\n        }\n    };\n\n    // Attempt to parse CIDR notation, first through IPv6 then IPv4.\n    // Throws an error if it could not be parsed.\n    ipaddr.parseCIDR = function (string) {\n        try {\n            return ipaddr.IPv6.parseCIDR(string);\n        } catch (e) {\n            try {\n                return ipaddr.IPv4.parseCIDR(string);\n            } catch (e2) {\n                throw new Error('ipaddr: the address has neither IPv6 nor IPv4 CIDR format');\n            }\n        }\n    };\n\n    // Parse an address and return plain IPv4 address if it is an IPv4-mapped address\n    ipaddr.process = function (string) {\n        const addr = this.parse(string);\n\n        if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress()) {\n            return addr.toIPv4Address();\n        } else {\n            return addr;\n        }\n    };\n\n    // An utility function to ease named range matching. See examples below.\n    // rangeList can contain both IPv4 and IPv6 subnet entries and will not throw errors\n    // on matching IPv4 addresses to IPv6 ranges or vice versa.\n    ipaddr.subnetMatch = function (address, rangeList, defaultName) {\n        let i, rangeName, rangeSubnets, subnet;\n\n        if (defaultName === undefined || defaultName === null) {\n            defaultName = 'unicast';\n        }\n\n        for (rangeName in rangeList) {\n            if (Object.prototype.hasOwnProperty.call(rangeList, rangeName)) {\n                rangeSubnets = rangeList[rangeName];\n                // ECMA5 Array.isArray isn't available everywhere\n                if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {\n                    rangeSubnets = [rangeSubnets];\n                }\n\n                for (i = 0; i < rangeSubnets.length; i++) {\n                    subnet = rangeSubnets[i];\n                    if (address.kind() === subnet[0].kind() && address.match.apply(address, subnet)) {\n                        return rangeName;\n                    }\n                }\n            }\n        }\n\n        return defaultName;\n    };\n\n    // Export for both the CommonJS and browser-like environment\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = ipaddr;\n\n    } else {\n        root.ipaddr = ipaddr;\n    }\n\n}(this));\n"],"mappings":"AAAC,WAAUA,IAAV,EAAgB;EACb,aADa,CAEb;EACA;EACA;;EACA,IAAMC,QAAQ,GAAG,sBAAjB;EACA,IAAMC,WAAW,GAAG;IAChBC,SAAS,EAAE,IAAIC,MAAJ,YAAeH,QAAf,gBAA6BA,QAA7B,gBAA2CA,QAA3C,gBAAyDA,QAAzD,QAAsE,GAAtE,CADK;IAEhBI,UAAU,EAAE,IAAID,MAAJ,YAAeH,QAAf,gBAA6BA,QAA7B,gBAA2CA,QAA3C,QAAwD,GAAxD,CAFI;IAGhBK,QAAQ,EAAE,IAAIF,MAAJ,YAAeH,QAAf,gBAA6BA,QAA7B,QAA0C,GAA1C,CAHM;IAIhBM,SAAS,EAAE,IAAIH,MAAJ,YAAeH,QAAf,QAA4B,GAA5B;EAJK,CAApB,CANa,CAab;;EACA,IAAMO,UAAU,GAAG,IAAIJ,MAAJ,cAAwB,GAAxB,CAAnB;EACA,IAAMK,QAAQ,GAAG,IAAIL,MAAJ,kBAA4B,GAA5B,CAAjB;EAEA,IAAMM,SAAS,GAAG,eAAlB,CAjBa,CAmBb;EACA;EACA;EACA;;EACA,IAAMC,QAAQ,GAAG,mBAAjB;EACA,IAAMC,WAAW,GAAG;IAChBF,SAAS,EAAE,IAAIN,MAAJ,CAAWM,SAAX,EAAsB,GAAtB,CADK;IAEhB,UAAU,IAAIN,MAAJ,kBAAqBO,QAArB,iCAAoDD,SAApD,UAAoE,GAApE,CAFM;IAGhBG,sBAAsB,EAAE,IAAIT,MAAJ,mBAAsBH,QAAtB,gBAAoCA,QAApC,gBAAkDA,QAAlD,gBAAgEA,QAAhE,cAA4ES,SAA5E,WAA6F,GAA7F,CAHR;IAIhBI,YAAY,EAAE,IAAIV,MAAJ,gBAAmBO,QAAnB,wBAAyCA,QAAzC,gBAAuDV,QAAvD,gBAAqEA,QAArE,gBAAmFA,QAAnF,gBAAiGA,QAAjG,cAA6GS,SAA7G,UAA6H,GAA7H;EAJE,CAApB,CAxBa,CA+Bb;;EACA,SAASK,UAAT,CAAqBC,MAArB,EAA6BC,KAA7B,EAAoC;IAChC;IACA,IAAID,MAAM,CAACE,OAAP,CAAe,IAAf,MAAyBF,MAAM,CAACG,WAAP,CAAmB,IAAnB,CAA7B,EAAuD;MACnD,OAAO,IAAP;IACH;;IAED,IAAIC,UAAU,GAAG,CAAjB;IACA,IAAIC,SAAS,GAAG,CAAC,CAAjB;IACA,IAAIC,MAAM,GAAG,CAACN,MAAM,CAACO,KAAP,CAAaX,WAAW,CAACF,SAAzB,KAAuC,EAAxC,EAA4C,CAA5C,CAAb;IACA,IAAIc,WAAJ,EAAiBC,gBAAjB,CATgC,CAWhC;;IACA,IAAIH,MAAJ,EAAY;MACRA,MAAM,GAAGA,MAAM,CAACI,SAAP,CAAiB,CAAjB,CAAT;MACAV,MAAM,GAAGA,MAAM,CAACW,OAAP,CAAe,MAAf,EAAuB,EAAvB,CAAT;IACH,CAf+B,CAiBhC;;;IACA,OAAO,CAACN,SAAS,GAAGL,MAAM,CAACE,OAAP,CAAe,GAAf,EAAoBG,SAAS,GAAG,CAAhC,CAAb,KAAoD,CAA3D,EAA8D;MAC1DD,UAAU;IACb,CApB+B,CAsBhC;;;IACA,IAAIJ,MAAM,CAACY,MAAP,CAAc,CAAd,EAAiB,CAAjB,MAAwB,IAA5B,EAAkC;MAC9BR,UAAU;IACb;;IAED,IAAIJ,MAAM,CAACY,MAAP,CAAc,CAAC,CAAf,EAAkB,CAAlB,MAAyB,IAA7B,EAAmC;MAC/BR,UAAU;IACb,CA7B+B,CA+BhC;;;IACA,IAAIA,UAAU,GAAGH,KAAjB,EAAwB;MACpB,OAAO,IAAP;IACH,CAlC+B,CAoChC;;;IACAQ,gBAAgB,GAAGR,KAAK,GAAGG,UAA3B;IACAI,WAAW,GAAG,GAAd;;IACA,OAAOC,gBAAgB,EAAvB,EAA2B;MACvBD,WAAW,IAAI,IAAf;IACH,CAzC+B,CA2ChC;;;IACAR,MAAM,GAAGA,MAAM,CAACW,OAAP,CAAe,IAAf,EAAqBH,WAArB,CAAT,CA5CgC,CA8ChC;IACA;;IACA,IAAIR,MAAM,CAAC,CAAD,CAAN,KAAc,GAAlB,EAAuB;MACnBA,MAAM,GAAGA,MAAM,CAACa,KAAP,CAAa,CAAb,CAAT;IACH;;IAED,IAAIb,MAAM,CAACA,MAAM,CAACc,MAAP,GAAgB,CAAjB,CAAN,KAA8B,GAAlC,EAAuC;MACnCd,MAAM,GAAGA,MAAM,CAACa,KAAP,CAAa,CAAb,EAAgB,CAAC,CAAjB,CAAT;IACH;;IAEDZ,KAAK,GAAI,YAAY;MACjB,IAAMc,GAAG,GAAGf,MAAM,CAACgB,KAAP,CAAa,GAAb,CAAZ;MACA,IAAMC,OAAO,GAAG,EAAhB;;MAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,GAAG,CAACD,MAAxB,EAAgCI,CAAC,EAAjC,EAAqC;QACjCD,OAAO,CAACE,IAAR,CAAaC,QAAQ,CAACL,GAAG,CAACG,CAAD,CAAJ,EAAS,EAAT,CAArB;MACH;;MAED,OAAOD,OAAP;IACH,CATO,EAAR;;IAWA,OAAO;MACHhB,KAAK,EAAEA,KADJ;MAEHK,MAAM,EAAEA;IAFL,CAAP;EAIH,CAvGY,CAyGb;;;EACA,SAASe,SAAT,CAAoBC,KAApB,EAA2BC,MAA3B,EAAmCC,QAAnC,EAA6CC,QAA7C,EAAuD;IACnD,IAAIH,KAAK,CAACR,MAAN,KAAiBS,MAAM,CAACT,MAA5B,EAAoC;MAChC,MAAM,IAAIY,KAAJ,CAAU,8DAAV,CAAN;IACH;;IAED,IAAIC,IAAI,GAAG,CAAX;IACA,IAAIC,KAAJ;;IAEA,OAAOH,QAAQ,GAAG,CAAlB,EAAqB;MACjBG,KAAK,GAAGJ,QAAQ,GAAGC,QAAnB;;MACA,IAAIG,KAAK,GAAG,CAAZ,EAAe;QACXA,KAAK,GAAG,CAAR;MACH;;MAED,IAAIN,KAAK,CAACK,IAAD,CAAL,IAAeC,KAAf,KAAyBL,MAAM,CAACI,IAAD,CAAN,IAAgBC,KAA7C,EAAoD;QAChD,OAAO,KAAP;MACH;;MAEDH,QAAQ,IAAID,QAAZ;MACAG,IAAI,IAAI,CAAR;IACH;;IAED,OAAO,IAAP;EACH;;EAED,SAASE,YAAT,CAAuB7B,MAAvB,EAA+B;IAC3B;IACA,IAAIP,QAAQ,CAACqC,IAAT,CAAc9B,MAAd,CAAJ,EAA2B;MACvB,OAAOoB,QAAQ,CAACpB,MAAD,EAAS,EAAT,CAAf;IACH,CAJ0B,CAK3B;IACA;IACA;;;IACA,IAAIA,MAAM,CAAC,CAAD,CAAN,KAAc,GAAd,IAAqB,CAAC+B,KAAK,CAACX,QAAQ,CAACpB,MAAM,CAAC,CAAD,CAAP,EAAY,EAAZ,CAAT,CAA/B,EAA0D;MAC1D,IAAIR,UAAU,CAACsC,IAAX,CAAgB9B,MAAhB,CAAJ,EAA6B;QACzB,OAAOoB,QAAQ,CAACpB,MAAD,EAAS,CAAT,CAAf;MACH;;MACG,MAAM,IAAI0B,KAAJ,gCAAkC1B,MAAlC,eAAN;IACH,CAb0B,CAc3B;;;IACA,OAAOoB,QAAQ,CAACpB,MAAD,EAAS,EAAT,CAAf;EACH;;EAED,SAASgC,OAAT,CAAkBL,IAAlB,EAAwBb,MAAxB,EAAgC;IAC5B,OAAOa,IAAI,CAACb,MAAL,GAAcA,MAArB,EAA6B;MACzBa,IAAI,cAAOA,IAAP,CAAJ;IACH;;IAED,OAAOA,IAAP;EACH;;EAED,IAAMM,MAAM,GAAG,EAAf,CA7Ja,CA+Jb;;EACAA,MAAM,CAACC,IAAP,GAAe,YAAY;IACvB;IACA;IACA;IACA,SAASA,IAAT,CAAeC,MAAf,EAAuB;MACnB,IAAIA,MAAM,CAACrB,MAAP,KAAkB,CAAtB,EAAyB;QACrB,MAAM,IAAIY,KAAJ,CAAU,sCAAV,CAAN;MACH;;MAED,IAAIR,CAAJ,EAAOkB,KAAP;;MAEA,KAAKlB,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGiB,MAAM,CAACrB,MAAvB,EAA+BI,CAAC,EAAhC,EAAoC;QAChCkB,KAAK,GAAGD,MAAM,CAACjB,CAAD,CAAd;;QACA,IAAI,EAAG,KAAKkB,KAAL,IAAcA,KAAK,IAAI,GAA1B,CAAJ,EAAqC;UACjC,MAAM,IAAIV,KAAJ,CAAU,yCAAV,CAAN;QACH;MACJ;;MAED,KAAKS,MAAL,GAAcA,MAAd;IACH,CAnBsB,CAqBvB;IACA;;;IACAD,IAAI,CAACG,SAAL,CAAeC,aAAf,GAA+B;MAC3BC,WAAW,EAAE,CAAC,CAAC,IAAIL,IAAJ,CAAS,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,CAAT,CAAD,EAAyB,CAAzB,CAAD,CADc;MAE3BM,SAAS,EAAE,CAAC,CAAC,IAAIN,IAAJ,CAAS,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgB,GAAhB,CAAT,CAAD,EAAiC,EAAjC,CAAD,CAFgB;MAG3B;MACAO,SAAS,EAAE,CAAC,CAAC,IAAIP,IAAJ,CAAS,CAAC,GAAD,EAAM,CAAN,EAAS,CAAT,EAAY,CAAZ,CAAT,CAAD,EAA2B,CAA3B,CAAD,CAJgB;MAK3B;MACAQ,SAAS,EAAE,CAAC,CAAC,IAAIR,IAAJ,CAAS,CAAC,GAAD,EAAM,GAAN,EAAW,CAAX,EAAc,CAAd,CAAT,CAAD,EAA6B,EAA7B,CAAD,CANgB;MAO3B;MACAS,QAAQ,EAAE,CAAC,CAAC,IAAIT,IAAJ,CAAS,CAAC,GAAD,EAAM,CAAN,EAAS,CAAT,EAAY,CAAZ,CAAT,CAAD,EAA2B,CAA3B,CAAD,CARiB;MAS3B;MACAU,eAAe,EAAE,CAAC,CAAC,IAAIV,IAAJ,CAAS,CAAC,GAAD,EAAM,EAAN,EAAU,CAAV,EAAa,CAAb,CAAT,CAAD,EAA4B,EAA5B,CAAD,CAVU;MAW3B;MACA,WAAW,CACP,CAAC,IAAIA,IAAJ,CAAS,CAAC,EAAD,EAAK,CAAL,EAAQ,CAAR,EAAW,CAAX,CAAT,CAAD,EAA0B,CAA1B,CADO,EAEP,CAAC,IAAIA,IAAJ,CAAS,CAAC,GAAD,EAAM,EAAN,EAAU,CAAV,EAAa,CAAb,CAAT,CAAD,EAA4B,EAA5B,CAFO,EAGP,CAAC,IAAIA,IAAJ,CAAS,CAAC,GAAD,EAAM,GAAN,EAAW,CAAX,EAAc,CAAd,CAAT,CAAD,EAA6B,EAA7B,CAHO,CAZgB;MAiB3B;MACAW,QAAQ,EAAE,CACN,CAAC,IAAIX,IAAJ,CAAS,CAAC,GAAD,EAAM,CAAN,EAAS,CAAT,EAAY,CAAZ,CAAT,CAAD,EAA2B,EAA3B,CADM,EAEN,CAAC,IAAIA,IAAJ,CAAS,CAAC,GAAD,EAAM,CAAN,EAAS,CAAT,EAAY,CAAZ,CAAT,CAAD,EAA2B,EAA3B,CAFM,EAGN,CAAC,IAAIA,IAAJ,CAAS,CAAC,GAAD,EAAM,EAAN,EAAU,EAAV,EAAc,CAAd,CAAT,CAAD,EAA6B,EAA7B,CAHM,EAIN,CAAC,IAAIA,IAAJ,CAAS,CAAC,GAAD,EAAM,EAAN,EAAU,GAAV,EAAe,CAAf,CAAT,CAAD,EAA8B,EAA9B,CAJM,EAKN,CAAC,IAAIA,IAAJ,CAAS,CAAC,GAAD,EAAM,CAAN,EAAS,GAAT,EAAc,CAAd,CAAT,CAAD,EAA6B,EAA7B,CALM,EAMN,CAAC,IAAIA,IAAJ,CAAS,CAAC,GAAD,EAAM,CAAN,EAAS,CAAT,EAAY,CAAZ,CAAT,CAAD,EAA2B,CAA3B,CANM;IAlBiB,CAA/B,CAvBuB,CAmDvB;;IACAA,IAAI,CAACG,SAAL,CAAeS,IAAf,GAAsB,YAAY;MAC9B,OAAO,MAAP;IACH,CAFD,CApDuB,CAwDvB;;;IACAZ,IAAI,CAACG,SAAL,CAAe9B,KAAf,GAAuB,UAAUwC,KAAV,EAAiBC,SAAjB,EAA4B;MAC/C,IAAIjC,GAAJ;;MACA,IAAIiC,SAAS,KAAKC,SAAlB,EAA6B;QACzBlC,GAAG,GAAGgC,KAAN;QACAA,KAAK,GAAGhC,GAAG,CAAC,CAAD,CAAX;QACAiC,SAAS,GAAGjC,GAAG,CAAC,CAAD,CAAf;MACH;;MAED,IAAIgC,KAAK,CAACD,IAAN,OAAiB,MAArB,EAA6B;QACzB,MAAM,IAAIpB,KAAJ,CAAU,qDAAV,CAAN;MACH;;MAED,OAAOL,SAAS,CAAC,KAAKc,MAAN,EAAcY,KAAK,CAACZ,MAApB,EAA4B,CAA5B,EAA+Ba,SAA/B,CAAhB;IACH,CAbD,CAzDuB,CAwEvB;IACA;IACA;;;IACAd,IAAI,CAACG,SAAL,CAAea,0BAAf,GAA4C,YAAY;MACpD,IAAIC,IAAI,GAAG,CAAX,CADoD,CAEpD;;MACA,IAAIC,IAAI,GAAG,KAAX,CAHoD,CAIpD;;MACA,IAAMC,SAAS,GAAG;QACd,GAAG,CADW;QAEd,KAAK,CAFS;QAGd,KAAK,CAHS;QAId,KAAK,CAJS;QAKd,KAAK,CALS;QAMd,KAAK,CANS;QAOd,KAAK,CAPS;QAQd,KAAK,CARS;QASd,KAAK;MATS,CAAlB;MAWA,IAAInC,CAAJ,EAAOkB,KAAP,EAAckB,KAAd;;MAEA,KAAKpC,CAAC,GAAG,CAAT,EAAYA,CAAC,IAAI,CAAjB,EAAoBA,CAAC,IAAI,CAAzB,EAA4B;QACxBkB,KAAK,GAAG,KAAKD,MAAL,CAAYjB,CAAZ,CAAR;;QACA,IAAIkB,KAAK,IAAIiB,SAAb,EAAwB;UACpBC,KAAK,GAAGD,SAAS,CAACjB,KAAD,CAAjB;;UACA,IAAIgB,IAAI,IAAIE,KAAK,KAAK,CAAtB,EAAyB;YACrB,OAAO,IAAP;UACH;;UAED,IAAIA,KAAK,KAAK,CAAd,EAAiB;YACbF,IAAI,GAAG,IAAP;UACH;;UAEDD,IAAI,IAAIG,KAAR;QACH,CAXD,MAWO;UACH,OAAO,IAAP;QACH;MACJ;;MAED,OAAO,KAAKH,IAAZ;IACH,CArCD,CA3EuB,CAkHvB;;;IACAjB,IAAI,CAACG,SAAL,CAAekB,KAAf,GAAuB,YAAY;MAC/B,OAAOtB,MAAM,CAACuB,WAAP,CAAmB,IAAnB,EAAyB,KAAKlB,aAA9B,CAAP;IACH,CAFD,CAnHuB,CAuHvB;;;IACAJ,IAAI,CAACG,SAAL,CAAeoB,WAAf,GAA6B,YAAY;MACrC,OAAO,KAAKtB,MAAL,CAAYtB,KAAZ,CAAkB,CAAlB,CAAP;IACH,CAFD,CAxHuB,CA4HvB;;;IACAqB,IAAI,CAACG,SAAL,CAAeqB,mBAAf,GAAqC,YAAY;MAC7C,OAAOzB,MAAM,CAAC0B,IAAP,CAAYC,KAAZ,kBAA4B,KAAKC,QAAL,EAA5B,EAAP;IACH,CAFD,CA7HuB,CAiIvB;;;IACA3B,IAAI,CAACG,SAAL,CAAeyB,kBAAf,GAAoC,YAAY;MAC5C,OAAO,KAAKD,QAAL,EAAP;IACH,CAFD,CAlIuB,CAsIvB;;;IACA3B,IAAI,CAACG,SAAL,CAAewB,QAAf,GAA0B,YAAY;MAClC,OAAO,KAAK1B,MAAL,CAAY4B,IAAZ,CAAiB,GAAjB,CAAP;IACH,CAFD;;IAIA,OAAO7B,IAAP;EACH,CA5Ia,EAAd,CAhKa,CA8Sb;;;EACAD,MAAM,CAACC,IAAP,CAAY8B,wBAAZ,GAAuC,UAAUhE,MAAV,EAAkB;IAErD,IAAI;MACA,IAAMmD,IAAI,GAAG,KAAKc,SAAL,CAAejE,MAAf,CAAb;MACA,IAAMkE,iBAAiB,GAAGf,IAAI,CAAC,CAAD,CAAJ,CAAQM,WAAR,EAA1B;MACA,IAAMU,gBAAgB,GAAG,KAAKC,0BAAL,CAAgCjB,IAAI,CAAC,CAAD,CAApC,EAAyCM,WAAzC,EAAzB;MACA,IAAMtB,MAAM,GAAG,EAAf;MACA,IAAIjB,CAAC,GAAG,CAAR;;MACA,OAAOA,CAAC,GAAG,CAAX,EAAc;QACV;QACAiB,MAAM,CAAChB,IAAP,CAAYC,QAAQ,CAAC8C,iBAAiB,CAAChD,CAAD,CAAlB,EAAuB,EAAvB,CAAR,GAAqCE,QAAQ,CAAC+C,gBAAgB,CAACjD,CAAD,CAAjB,EAAsB,EAAtB,CAAR,GAAoC,GAArF;QACAA,CAAC;MACJ;;MAED,OAAO,IAAI,IAAJ,CAASiB,MAAT,CAAP;IACH,CAbD,CAaE,OAAOkC,CAAP,EAAU;MACR,MAAM,IAAI3C,KAAJ,CAAU,oDAAV,CAAN;IACH;EACJ,CAlBD,CA/Sa,CAmUb;;;EACAO,MAAM,CAACC,IAAP,CAAYoC,MAAZ,GAAqB,UAAUtE,MAAV,EAAkB;IACnC,OAAO,KAAKuE,MAAL,CAAYvE,MAAZ,MAAwB,IAA/B;EACH,CAFD,CApUa,CAwUb;;;EACAiC,MAAM,CAACC,IAAP,CAAYsC,OAAZ,GAAsB,UAAUxE,MAAV,EAAkB;IACpC,IAAI;MACA,IAAI,IAAJ,CAAS,KAAKuE,MAAL,CAAYvE,MAAZ,CAAT;MACA,OAAO,IAAP;IACH,CAHD,CAGE,OAAOqE,CAAP,EAAU;MACR,OAAO,KAAP;IACH;EACJ,CAPD,CAzUa,CAkVb;;;EACApC,MAAM,CAACC,IAAP,CAAYuC,sBAAZ,GAAqC,UAAUzE,MAAV,EAAkB;IACnD,IAAIiC,MAAM,CAACC,IAAP,CAAYsC,OAAZ,CAAoBxE,MAApB,KAA+BA,MAAM,CAACO,KAAP,CAAa,mCAAb,CAAnC,EAAsF;MAClF,OAAO,IAAP;IACH,CAFD,MAEO;MACH,OAAO,KAAP;IACH;EACJ,CAND,CAnVa,CA2Vb;;;EACA0B,MAAM,CAACC,IAAP,CAAYwC,sBAAZ,GAAqC,UAAU1E,MAAV,EAAkB;IACnD,IAAImD,IAAJ,EAAUjC,CAAV,EAAagD,iBAAb,EAAgC/B,MAAhC,EAAwCgC,gBAAxC;;IAEA,IAAI;MACAhB,IAAI,GAAG,KAAKc,SAAL,CAAejE,MAAf,CAAP;MACAkE,iBAAiB,GAAGf,IAAI,CAAC,CAAD,CAAJ,CAAQM,WAAR,EAApB;MACAU,gBAAgB,GAAG,KAAKC,0BAAL,CAAgCjB,IAAI,CAAC,CAAD,CAApC,EAAyCM,WAAzC,EAAnB;MACAtB,MAAM,GAAG,EAAT;MACAjB,CAAC,GAAG,CAAJ;;MACA,OAAOA,CAAC,GAAG,CAAX,EAAc;QACV;QACAiB,MAAM,CAAChB,IAAP,CAAYC,QAAQ,CAAC8C,iBAAiB,CAAChD,CAAD,CAAlB,EAAuB,EAAvB,CAAR,GAAqCE,QAAQ,CAAC+C,gBAAgB,CAACjD,CAAD,CAAjB,EAAsB,EAAtB,CAAzD;QACAA,CAAC;MACJ;;MAED,OAAO,IAAI,IAAJ,CAASiB,MAAT,CAAP;IACH,CAbD,CAaE,OAAOkC,CAAP,EAAU;MACR,MAAM,IAAI3C,KAAJ,CAAU,oDAAV,CAAN;IACH;EACJ,CAnBD,CA5Va,CAiXb;EACA;;;EACAO,MAAM,CAACC,IAAP,CAAY0B,KAAZ,GAAoB,UAAU5D,MAAV,EAAkB;IAClC,IAAMC,KAAK,GAAG,KAAKsE,MAAL,CAAYvE,MAAZ,CAAd;;IAEA,IAAIC,KAAK,KAAK,IAAd,EAAoB;MAChB,MAAM,IAAIyB,KAAJ,CAAU,sDAAV,CAAN;IACH;;IAED,OAAO,IAAI,IAAJ,CAASzB,KAAT,CAAP;EACH,CARD,CAnXa,CA6Xb;;;EACAgC,MAAM,CAACC,IAAP,CAAY+B,SAAZ,GAAwB,UAAUjE,MAAV,EAAkB;IACtC,IAAIO,KAAJ;;IAEA,IAAKA,KAAK,GAAGP,MAAM,CAACO,KAAP,CAAa,eAAb,CAAb,EAA6C;MACzC,IAAMoE,UAAU,GAAGvD,QAAQ,CAACb,KAAK,CAAC,CAAD,CAAN,CAA3B;;MACA,IAAIoE,UAAU,IAAI,CAAd,IAAmBA,UAAU,IAAI,EAArC,EAAyC;QACrC,IAAMC,MAAM,GAAG,CAAC,KAAKhB,KAAL,CAAWrD,KAAK,CAAC,CAAD,CAAhB,CAAD,EAAuBoE,UAAvB,CAAf;QACAE,MAAM,CAACC,cAAP,CAAsBF,MAAtB,EAA8B,UAA9B,EAA0C;UACtCG,KAAK,EAAE,iBAAY;YACf,OAAO,KAAKhB,IAAL,CAAU,GAAV,CAAP;UACH;QAHqC,CAA1C;QAKA,OAAOa,MAAP;MACH;IACJ;;IAED,MAAM,IAAIlD,KAAJ,CAAU,yDAAV,CAAN;EACH,CAjBD,CA9Xa,CAiZb;EACA;EACA;;;EACAO,MAAM,CAACC,IAAP,CAAYqC,MAAZ,GAAqB,UAAUvE,MAAV,EAAkB;IACnC,IAAIO,KAAJ,EAAWoB,IAAX,EAAiBoD,KAAjB,CADmC,CAGnC;;IACA,IAAKxE,KAAK,GAAGP,MAAM,CAACO,KAAP,CAAarB,WAAW,CAACC,SAAzB,CAAb,EAAmD;MAC/C,OAAQ,YAAY;QAChB,IAAM4B,GAAG,GAAGR,KAAK,CAACM,KAAN,CAAY,CAAZ,EAAe,CAAf,CAAZ;QACA,IAAMI,OAAO,GAAG,EAAhB;;QAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,GAAG,CAACD,MAAxB,EAAgCI,CAAC,EAAjC,EAAqC;UACjCS,IAAI,GAAGZ,GAAG,CAACG,CAAD,CAAV;UACAD,OAAO,CAACE,IAAR,CAAaU,YAAY,CAACF,IAAD,CAAzB;QACH;;QAED,OAAOV,OAAP;MACH,CAVM,EAAP;IAWH,CAZD,MAYO,IAAKV,KAAK,GAAGP,MAAM,CAACO,KAAP,CAAarB,WAAW,CAACK,SAAzB,CAAb,EAAmD;MACtDwF,KAAK,GAAGlD,YAAY,CAACtB,KAAK,CAAC,CAAD,CAAN,CAApB;;MACA,IAAIwE,KAAK,GAAG,UAAR,IAAsBA,KAAK,GAAG,CAAlC,EAAqC;QACjC,MAAM,IAAIrD,KAAJ,CAAU,uCAAV,CAAN;MACH;;MAED,OAAS,YAAY;QACjB,IAAMT,OAAO,GAAG,EAAhB;QACA,IAAIW,KAAJ;;QAEA,KAAKA,KAAK,GAAG,CAAb,EAAgBA,KAAK,IAAI,EAAzB,EAA6BA,KAAK,IAAI,CAAtC,EAAyC;UACrCX,OAAO,CAACE,IAAR,CAAc4D,KAAK,IAAInD,KAAV,GAAmB,IAAhC;QACH;;QAED,OAAOX,OAAP;MACH,CATO,EAAD,CASD+D,OATC,EAAP;IAUH,CAhBM,MAgBA,IAAKzE,KAAK,GAAGP,MAAM,CAACO,KAAP,CAAarB,WAAW,CAACI,QAAzB,CAAb,EAAkD;MACrD,OAAQ,YAAY;QAChB,IAAMyB,GAAG,GAAGR,KAAK,CAACM,KAAN,CAAY,CAAZ,EAAe,CAAf,CAAZ;QACA,IAAMI,OAAO,GAAG,EAAhB;QAEA8D,KAAK,GAAGlD,YAAY,CAACd,GAAG,CAAC,CAAD,CAAJ,CAApB;;QACA,IAAIgE,KAAK,GAAG,QAAR,IAAoBA,KAAK,GAAG,CAAhC,EAAmC;UAC/B,MAAM,IAAIrD,KAAJ,CAAU,uCAAV,CAAN;QACH;;QAEDT,OAAO,CAACE,IAAR,CAAaU,YAAY,CAACd,GAAG,CAAC,CAAD,CAAJ,CAAzB;QACAE,OAAO,CAACE,IAAR,CAAc4D,KAAK,IAAI,EAAV,GAAgB,IAA7B;QACA9D,OAAO,CAACE,IAAR,CAAc4D,KAAK,IAAK,CAAX,GAAgB,IAA7B;QACA9D,OAAO,CAACE,IAAR,CAAc4D,KAAK,GAAU,IAA7B;QAEA,OAAO9D,OAAP;MACH,CAfM,EAAP;IAgBH,CAjBM,MAiBA,IAAKV,KAAK,GAAGP,MAAM,CAACO,KAAP,CAAarB,WAAW,CAACG,UAAzB,CAAb,EAAoD;MACvD,OAAQ,YAAY;QAChB,IAAM0B,GAAG,GAAGR,KAAK,CAACM,KAAN,CAAY,CAAZ,EAAe,CAAf,CAAZ;QACA,IAAMI,OAAO,GAAG,EAAhB;QAEA8D,KAAK,GAAGlD,YAAY,CAACd,GAAG,CAAC,CAAD,CAAJ,CAApB;;QACA,IAAIgE,KAAK,GAAG,MAAR,IAAkBA,KAAK,GAAG,CAA9B,EAAiC;UAC7B,MAAM,IAAIrD,KAAJ,CAAU,uCAAV,CAAN;QACH;;QAEDT,OAAO,CAACE,IAAR,CAAaU,YAAY,CAACd,GAAG,CAAC,CAAD,CAAJ,CAAzB;QACAE,OAAO,CAACE,IAAR,CAAaU,YAAY,CAACd,GAAG,CAAC,CAAD,CAAJ,CAAzB;QACAE,OAAO,CAACE,IAAR,CAAc4D,KAAK,IAAI,CAAV,GAAe,IAA5B;QACA9D,OAAO,CAACE,IAAR,CAAc4D,KAAK,GAAS,IAA5B;QAEA,OAAO9D,OAAP;MACH,CAfM,EAAP;IAgBH,CAjBM,MAiBA;MACH,OAAO,IAAP;IACH;EACJ,CArED,CApZa,CA2db;;;EACAgB,MAAM,CAACC,IAAP,CAAYkC,0BAAZ,GAAyC,UAAUa,MAAV,EAAkB;IACvDA,MAAM,GAAG7D,QAAQ,CAAC6D,MAAD,CAAjB;;IACA,IAAIA,MAAM,GAAG,CAAT,IAAcA,MAAM,GAAG,EAA3B,EAA+B;MAC3B,MAAM,IAAIvD,KAAJ,CAAU,oCAAV,CAAN;IACH;;IAED,IAAMS,MAAM,GAAG,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,CAAf;IACA,IAAI+C,CAAC,GAAG,CAAR;IACA,IAAMC,gBAAgB,GAAGC,IAAI,CAACC,KAAL,CAAWJ,MAAM,GAAG,CAApB,CAAzB;;IAEA,OAAOC,CAAC,GAAGC,gBAAX,EAA6B;MACzBhD,MAAM,CAAC+C,CAAD,CAAN,GAAY,GAAZ;MACAA,CAAC;IACJ;;IAED,IAAIC,gBAAgB,GAAG,CAAvB,EAA0B;MACtBhD,MAAM,CAACgD,gBAAD,CAAN,GAA2BC,IAAI,CAACE,GAAL,CAAS,CAAT,EAAYL,MAAM,GAAG,CAArB,IAA0B,CAA1B,IAA+B,IAAKA,MAAM,GAAG,CAAxE;IACH;;IAED,OAAO,IAAI,IAAJ,CAAS9C,MAAT,CAAP;EACH,CApBD,CA5da,CAkfb;;;EACAF,MAAM,CAAC0B,IAAP,GAAe,YAAY;IACvB;IACA;IACA;IACA,SAASA,IAAT,CAAe1D,KAAf,EAAsBK,MAAtB,EAA8B;MAC1B,IAAIY,CAAJ,EAAOS,IAAP;;MAEA,IAAI1B,KAAK,CAACa,MAAN,KAAiB,EAArB,EAAyB;QACrB,KAAKb,KAAL,GAAa,EAAb;;QACA,KAAKiB,CAAC,GAAG,CAAT,EAAYA,CAAC,IAAI,EAAjB,EAAqBA,CAAC,IAAI,CAA1B,EAA6B;UACzB,KAAKjB,KAAL,CAAWkB,IAAX,CAAiBlB,KAAK,CAACiB,CAAD,CAAL,IAAY,CAAb,GAAkBjB,KAAK,CAACiB,CAAC,GAAG,CAAL,CAAvC;QACH;MACJ,CALD,MAKO,IAAIjB,KAAK,CAACa,MAAN,KAAiB,CAArB,EAAwB;QAC3B,KAAKb,KAAL,GAAaA,KAAb;MACH,CAFM,MAEA;QACH,MAAM,IAAIyB,KAAJ,CAAU,2CAAV,CAAN;MACH;;MAED,KAAKR,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG,KAAKjB,KAAL,CAAWa,MAA3B,EAAmCI,CAAC,EAApC,EAAwC;QACpCS,IAAI,GAAG,KAAK1B,KAAL,CAAWiB,CAAX,CAAP;;QACA,IAAI,EAAG,KAAKS,IAAL,IAAaA,IAAI,IAAI,MAAxB,CAAJ,EAAsC;UAClC,MAAM,IAAID,KAAJ,CAAU,yCAAV,CAAN;QACH;MACJ;;MAED,IAAIpB,MAAJ,EAAY;QACR,KAAKA,MAAL,GAAcA,MAAd;MACH;IACJ,CA5BsB,CA8BvB;;;IACAqD,IAAI,CAACtB,SAAL,CAAeC,aAAf,GAA+B;MAC3B;MACAC,WAAW,EAAE,CAAC,IAAIoB,IAAJ,CAAS,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,EAAgB,CAAhB,EAAmB,CAAnB,EAAsB,CAAtB,CAAT,CAAD,EAAqC,GAArC,CAFc;MAG3BjB,SAAS,EAAE,CAAC,IAAIiB,IAAJ,CAAS,CAAC,MAAD,EAAS,CAAT,EAAY,CAAZ,EAAe,CAAf,EAAkB,CAAlB,EAAqB,CAArB,EAAwB,CAAxB,EAA2B,CAA3B,CAAT,CAAD,EAA0C,EAA1C,CAHgB;MAI3BlB,SAAS,EAAE,CAAC,IAAIkB,IAAJ,CAAS,CAAC,MAAD,EAAS,CAAT,EAAY,CAAZ,EAAe,CAAf,EAAkB,CAAlB,EAAqB,CAArB,EAAwB,CAAxB,EAA2B,CAA3B,CAAT,CAAD,EAA0C,CAA1C,CAJgB;MAK3BhB,QAAQ,EAAE,CAAC,IAAIgB,IAAJ,CAAS,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,EAAgB,CAAhB,EAAmB,CAAnB,EAAsB,CAAtB,CAAT,CAAD,EAAqC,GAArC,CALiB;MAM3B4B,WAAW,EAAE,CAAC,IAAI5B,IAAJ,CAAS,CAAC,MAAD,EAAS,CAAT,EAAY,CAAZ,EAAe,CAAf,EAAkB,CAAlB,EAAqB,CAArB,EAAwB,CAAxB,EAA2B,CAA3B,CAAT,CAAD,EAA0C,CAA1C,CANc;MAO3B6B,UAAU,EAAE,CAAC,IAAI7B,IAAJ,CAAS,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,EAAgB,MAAhB,EAAwB,CAAxB,EAA2B,CAA3B,CAAT,CAAD,EAA0C,EAA1C,CAPe;MAQ3B;MACA8B,OAAO,EAAE,CAAC,IAAI9B,IAAJ,CAAS,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,MAAb,EAAqB,CAArB,EAAwB,CAAxB,EAA2B,CAA3B,CAAT,CAAD,EAA0C,EAA1C,CATkB;MAU3B;MACA+B,OAAO,EAAE,CAAC,IAAI/B,IAAJ,CAAS,CAAC,IAAD,EAAO,MAAP,EAAe,CAAf,EAAkB,CAAlB,EAAqB,CAArB,EAAwB,CAAxB,EAA2B,CAA3B,EAA8B,CAA9B,CAAT,CAAD,EAA6C,EAA7C,CAXkB;MAY3B;MACA,QAAQ,CAAC,IAAIA,IAAJ,CAAS,CAAC,MAAD,EAAS,CAAT,EAAY,CAAZ,EAAe,CAAf,EAAkB,CAAlB,EAAqB,CAArB,EAAwB,CAAxB,EAA2B,CAA3B,CAAT,CAAD,EAA0C,EAA1C,CAbmB;MAc3B;MACAgC,MAAM,EAAE,CAAC,IAAIhC,IAAJ,CAAS,CAAC,MAAD,EAAS,CAAT,EAAY,CAAZ,EAAe,CAAf,EAAkB,CAAlB,EAAqB,CAArB,EAAwB,CAAxB,EAA2B,CAA3B,CAAT,CAAD,EAA0C,EAA1C,CAfmB;MAgB3B;MACAd,QAAQ,EAAE,CAAC,CAAC,IAAIc,IAAJ,CAAS,CAAC,MAAD,EAAS,KAAT,EAAgB,CAAhB,EAAmB,CAAnB,EAAsB,CAAtB,EAAyB,CAAzB,EAA4B,CAA5B,EAA+B,CAA/B,CAAT,CAAD,EAA8C,EAA9C,CAAD;IAjBiB,CAA/B,CA/BuB,CAmDvB;;IACAA,IAAI,CAACtB,SAAL,CAAeuD,mBAAf,GAAqC,YAAY;MAC7C,OAAO,KAAKrC,KAAL,OAAiB,YAAxB;IACH,CAFD,CApDuB,CAwDvB;;;IACAI,IAAI,CAACtB,SAAL,CAAeS,IAAf,GAAsB,YAAY;MAC9B,OAAO,MAAP;IACH,CAFD,CAzDuB,CA6DvB;;;IACAa,IAAI,CAACtB,SAAL,CAAe9B,KAAf,GAAuB,UAAUwC,KAAV,EAAiBC,SAAjB,EAA4B;MAC/C,IAAIjC,GAAJ;;MAEA,IAAIiC,SAAS,KAAKC,SAAlB,EAA6B;QACzBlC,GAAG,GAAGgC,KAAN;QACAA,KAAK,GAAGhC,GAAG,CAAC,CAAD,CAAX;QACAiC,SAAS,GAAGjC,GAAG,CAAC,CAAD,CAAf;MACH;;MAED,IAAIgC,KAAK,CAACD,IAAN,OAAiB,MAArB,EAA6B;QACzB,MAAM,IAAIpB,KAAJ,CAAU,qDAAV,CAAN;MACH;;MAED,OAAOL,SAAS,CAAC,KAAKpB,KAAN,EAAa8C,KAAK,CAAC9C,KAAnB,EAA0B,EAA1B,EAA8B+C,SAA9B,CAAhB;IACH,CAdD,CA9DuB,CA8EvB;IACA;IACA;;;IACAW,IAAI,CAACtB,SAAL,CAAea,0BAAf,GAA4C,YAAY;MACpD,IAAIC,IAAI,GAAG,CAAX,CADoD,CAEpD;;MACA,IAAIC,IAAI,GAAG,KAAX,CAHoD,CAIpD;;MACA,IAAMC,SAAS,GAAG;QACd,GAAG,EADW;QAEd,OAAO,EAFO;QAGd,OAAO,EAHO;QAId,OAAO,EAJO;QAKd,OAAO,EALO;QAMd,OAAO,EANO;QAOd,OAAO,EAPO;QAQd,OAAO,CARO;QASd,OAAO,CATO;QAUd,OAAO,CAVO;QAWd,OAAO,CAXO;QAYd,OAAO,CAZO;QAad,OAAO,CAbO;QAcd,OAAO,CAdO;QAed,OAAO,CAfO;QAgBd,OAAO,CAhBO;QAiBd,OAAO;MAjBO,CAAlB;MAmBA,IAAI1B,IAAJ,EAAU2B,KAAV;;MAEA,KAAK,IAAIpC,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAI,CAArB,EAAwBA,CAAC,IAAI,CAA7B,EAAgC;QAC5BS,IAAI,GAAG,KAAK1B,KAAL,CAAWiB,CAAX,CAAP;;QACA,IAAIS,IAAI,IAAI0B,SAAZ,EAAuB;UACnBC,KAAK,GAAGD,SAAS,CAAC1B,IAAD,CAAjB;;UACA,IAAIyB,IAAI,IAAIE,KAAK,KAAK,CAAtB,EAAyB;YACrB,OAAO,IAAP;UACH;;UAED,IAAIA,KAAK,KAAK,EAAd,EAAkB;YACdF,IAAI,GAAG,IAAP;UACH;;UAEDD,IAAI,IAAIG,KAAR;QACH,CAXD,MAWO;UACH,OAAO,IAAP;QACH;MACJ;;MAED,OAAO,MAAMH,IAAb;IACH,CA7CD,CAjFuB,CAiIvB;;;IACAQ,IAAI,CAACtB,SAAL,CAAekB,KAAf,GAAuB,YAAY;MAC/B,OAAOtB,MAAM,CAACuB,WAAP,CAAmB,IAAnB,EAAyB,KAAKlB,aAA9B,CAAP;IACH,CAFD,CAlIuB,CAsIvB;;;IACAqB,IAAI,CAACtB,SAAL,CAAeoB,WAAf,GAA6B,YAAY;MACrC,IAAI9B,IAAJ;MACA,IAAMkE,KAAK,GAAG,EAAd;MACA,IAAM9E,GAAG,GAAG,KAAKd,KAAjB;;MACA,KAAK,IAAIiB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,GAAG,CAACD,MAAxB,EAAgCI,CAAC,EAAjC,EAAqC;QACjCS,IAAI,GAAGZ,GAAG,CAACG,CAAD,CAAV;QACA2E,KAAK,CAAC1E,IAAN,CAAWQ,IAAI,IAAI,CAAnB;QACAkE,KAAK,CAAC1E,IAAN,CAAWQ,IAAI,GAAG,IAAlB;MACH;;MAED,OAAOkE,KAAP;IACH,CAXD,CAvIuB,CAoJvB;IACA;;;IACAlC,IAAI,CAACtB,SAAL,CAAeyD,mBAAf,GAAqC,YAAY;MAC7C,IAAMC,IAAI,GAAK,YAAY;QACvB,IAAM9E,OAAO,GAAG,EAAhB;;QACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKjB,KAAL,CAAWa,MAA/B,EAAuCI,CAAC,EAAxC,EAA4C;UACxCD,OAAO,CAACE,IAAR,CAAaa,OAAO,CAAC,KAAK/B,KAAL,CAAWiB,CAAX,EAAc2C,QAAd,CAAuB,EAAvB,CAAD,EAA6B,CAA7B,CAApB;QACH;;QAED,OAAO5C,OAAP;MACH,CAPa,CAOX+E,IAPW,CAON,IAPM,CAAD,CAOEjC,IAPF,CAOO,GAPP,CAAb;;MASA,IAAIkC,MAAM,GAAG,EAAb;;MAEA,IAAI,KAAK3F,MAAT,EAAiB;QACb2F,MAAM,cAAO,KAAK3F,MAAZ,CAAN;MACH;;MAED,OAAOyF,IAAI,GAAGE,MAAd;IACH,CAjBD,CAtJuB,CAyKvB;IACA;;;IACAtC,IAAI,CAACtB,SAAL,CAAe6D,aAAf,GAA+B,YAAY;MACvC,IAAI,CAAC,KAAKN,mBAAL,EAAL,EAAiC;QAC7B,MAAM,IAAIlE,KAAJ,CAAU,0DAAV,CAAN;MACH;;MAED,IAAMX,GAAG,GAAG,KAAKd,KAAL,CAAWY,KAAX,CAAiB,CAAC,CAAlB,CAAZ;MACA,IAAMsF,IAAI,GAAGpF,GAAG,CAAC,CAAD,CAAhB;MACA,IAAMqF,GAAG,GAAGrF,GAAG,CAAC,CAAD,CAAf;MAEA,OAAO,IAAIkB,MAAM,CAACC,IAAX,CAAgB,CAACiE,IAAI,IAAI,CAAT,EAAYA,IAAI,GAAG,IAAnB,EAAyBC,GAAG,IAAI,CAAhC,EAAmCA,GAAG,GAAG,IAAzC,CAAhB,CAAP;IACH,CAVD,CA3KuB,CAuLvB;IACA;IACA;IACA;;;IACAzC,IAAI,CAACtB,SAAL,CAAeyB,kBAAf,GAAoC,YAAY;MAC5C,IAAMiC,IAAI,GAAK,YAAY;QACvB,IAAM9E,OAAO,GAAG,EAAhB;;QAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKjB,KAAL,CAAWa,MAA/B,EAAuCI,CAAC,EAAxC,EAA4C;UACxCD,OAAO,CAACE,IAAR,CAAa,KAAKlB,KAAL,CAAWiB,CAAX,EAAc2C,QAAd,CAAuB,EAAvB,CAAb;QACH;;QAED,OAAO5C,OAAP;MACH,CARa,CAQX+E,IARW,CAQN,IARM,CAAD,CAQEjC,IARF,CAQO,GARP,CAAb;;MAUA,IAAIkC,MAAM,GAAG,EAAb;;MAEA,IAAI,KAAK3F,MAAT,EAAiB;QACb2F,MAAM,cAAO,KAAK3F,MAAZ,CAAN;MACH;;MAED,OAAOyF,IAAI,GAAGE,MAAd;IACH,CAlBD,CA3LuB,CA+MvB;IACA;IACA;;;IACAtC,IAAI,CAACtB,SAAL,CAAegE,eAAf,GAAiC,YAAY;MACzC,IAAMC,KAAK,GAAG,sBAAd;MACA,IAAMtG,MAAM,GAAG,KAAK8D,kBAAL,EAAf;MACA,IAAIyC,cAAc,GAAG,CAArB;MACA,IAAIC,eAAe,GAAG,CAAC,CAAvB;MACA,IAAIjG,KAAJ;;MAEA,OAAQA,KAAK,GAAG+F,KAAK,CAACG,IAAN,CAAWzG,MAAX,CAAhB,EAAqC;QACjC,IAAIO,KAAK,CAAC,CAAD,CAAL,CAASO,MAAT,GAAkB0F,eAAtB,EAAuC;UACnCD,cAAc,GAAGhG,KAAK,CAACmG,KAAvB;UACAF,eAAe,GAAGjG,KAAK,CAAC,CAAD,CAAL,CAASO,MAA3B;QACH;MACJ;;MAED,IAAI0F,eAAe,GAAG,CAAtB,EAAyB;QACrB,OAAOxG,MAAP;MACH;;MAED,iBAAUA,MAAM,CAACU,SAAP,CAAiB,CAAjB,EAAoB6F,cAApB,CAAV,eAAkDvG,MAAM,CAACU,SAAP,CAAiB6F,cAAc,GAAGC,eAAlC,CAAlD;IACH,CAnBD,CAlNuB,CAuOvB;IACA;IACA;IACA;;;IACA7C,IAAI,CAACtB,SAAL,CAAewB,QAAf,GAA0B,YAAY;MAClC;MACA,OAAO,KAAKC,kBAAL,GAA0BnD,OAA1B,CAAkC,kBAAlC,EAAsD,IAAtD,CAAP;IACH,CAHD;;IAKA,OAAOgD,IAAP;EAEH,CAlPa,EAAd,CAnfa,CAuuBb;;;EACA1B,MAAM,CAAC0B,IAAP,CAAYK,wBAAZ,GAAuC,UAAUhE,MAAV,EAAkB;IACrD,IAAI;MACA,IAAMmD,IAAI,GAAG,KAAKc,SAAL,CAAejE,MAAf,CAAb;MACA,IAAMkE,iBAAiB,GAAGf,IAAI,CAAC,CAAD,CAAJ,CAAQM,WAAR,EAA1B;MACA,IAAMU,gBAAgB,GAAG,KAAKC,0BAAL,CAAgCjB,IAAI,CAAC,CAAD,CAApC,EAAyCM,WAAzC,EAAzB;MACA,IAAMtB,MAAM,GAAG,EAAf;MACA,IAAIjB,CAAC,GAAG,CAAR;;MACA,OAAOA,CAAC,GAAG,EAAX,EAAe;QACX;QACAiB,MAAM,CAAChB,IAAP,CAAYC,QAAQ,CAAC8C,iBAAiB,CAAChD,CAAD,CAAlB,EAAuB,EAAvB,CAAR,GAAqCE,QAAQ,CAAC+C,gBAAgB,CAACjD,CAAD,CAAjB,EAAsB,EAAtB,CAAR,GAAoC,GAArF;QACAA,CAAC;MACJ;;MAED,OAAO,IAAI,IAAJ,CAASiB,MAAT,CAAP;IACH,CAbD,CAaE,OAAOkC,CAAP,EAAU;MACR,MAAM,IAAI3C,KAAJ,+DAAiE2C,CAAjE,OAAN;IACH;EACJ,CAjBD,CAxuBa,CA2vBb;;;EACApC,MAAM,CAAC0B,IAAP,CAAYgD,MAAZ,GAAqB,UAAU3G,MAAV,EAAkB;IACnC,OAAO,KAAKuE,MAAL,CAAYvE,MAAZ,MAAwB,IAA/B;EACH,CAFD,CA5vBa,CAgwBb;;;EACAiC,MAAM,CAAC0B,IAAP,CAAYa,OAAZ,GAAsB,UAAUxE,MAAV,EAAkB;IAEpC;IACA;IACA,IAAI,OAAOA,MAAP,KAAkB,QAAlB,IAA8BA,MAAM,CAACE,OAAP,CAAe,GAAf,MAAwB,CAAC,CAA3D,EAA8D;MAC1D,OAAO,KAAP;IACH;;IAED,IAAI;MACA,IAAM6F,IAAI,GAAG,KAAKxB,MAAL,CAAYvE,MAAZ,CAAb;MACA,IAAI,IAAJ,CAAS+F,IAAI,CAAC9F,KAAd,EAAqB8F,IAAI,CAACzF,MAA1B;MACA,OAAO,IAAP;IACH,CAJD,CAIE,OAAO+D,CAAP,EAAU;MACR,OAAO,KAAP;IACH;EACJ,CAfD,CAjwBa,CAkxBb;;;EACApC,MAAM,CAAC0B,IAAP,CAAYe,sBAAZ,GAAqC,UAAU1E,MAAV,EAAkB;IACnD,IAAImD,IAAJ,EAAUjC,CAAV,EAAagD,iBAAb,EAAgC/B,MAAhC,EAAwCgC,gBAAxC;;IAEA,IAAI;MACAhB,IAAI,GAAG,KAAKc,SAAL,CAAejE,MAAf,CAAP;MACAkE,iBAAiB,GAAGf,IAAI,CAAC,CAAD,CAAJ,CAAQM,WAAR,EAApB;MACAU,gBAAgB,GAAG,KAAKC,0BAAL,CAAgCjB,IAAI,CAAC,CAAD,CAApC,EAAyCM,WAAzC,EAAnB;MACAtB,MAAM,GAAG,EAAT;MACAjB,CAAC,GAAG,CAAJ;;MACA,OAAOA,CAAC,GAAG,EAAX,EAAe;QACX;QACAiB,MAAM,CAAChB,IAAP,CAAYC,QAAQ,CAAC8C,iBAAiB,CAAChD,CAAD,CAAlB,EAAuB,EAAvB,CAAR,GAAqCE,QAAQ,CAAC+C,gBAAgB,CAACjD,CAAD,CAAjB,EAAsB,EAAtB,CAAzD;QACAA,CAAC;MACJ;;MAED,OAAO,IAAI,IAAJ,CAASiB,MAAT,CAAP;IACH,CAbD,CAaE,OAAOkC,CAAP,EAAU;MACR,MAAM,IAAI3C,KAAJ,+DAAiE2C,CAAjE,OAAN;IACH;EACJ,CAnBD,CAnxBa,CAwyBb;EACA;;;EACApC,MAAM,CAAC0B,IAAP,CAAYC,KAAZ,GAAoB,UAAU5D,MAAV,EAAkB;IAClC,IAAM+F,IAAI,GAAG,KAAKxB,MAAL,CAAYvE,MAAZ,CAAb;;IAEA,IAAI+F,IAAI,CAAC9F,KAAL,KAAe,IAAnB,EAAyB;MACrB,MAAM,IAAIyB,KAAJ,CAAU,sDAAV,CAAN;IACH;;IAED,OAAO,IAAI,IAAJ,CAASqE,IAAI,CAAC9F,KAAd,EAAqB8F,IAAI,CAACzF,MAA1B,CAAP;EACH,CARD;;EAUA2B,MAAM,CAAC0B,IAAP,CAAYM,SAAZ,GAAwB,UAAUjE,MAAV,EAAkB;IACtC,IAAI2E,UAAJ,EAAgBpE,KAAhB,EAAuBqE,MAAvB;;IAEA,IAAKrE,KAAK,GAAGP,MAAM,CAACO,KAAP,CAAa,eAAb,CAAb,EAA6C;MACzCoE,UAAU,GAAGvD,QAAQ,CAACb,KAAK,CAAC,CAAD,CAAN,CAArB;;MACA,IAAIoE,UAAU,IAAI,CAAd,IAAmBA,UAAU,IAAI,GAArC,EAA0C;QACtCC,MAAM,GAAG,CAAC,KAAKhB,KAAL,CAAWrD,KAAK,CAAC,CAAD,CAAhB,CAAD,EAAuBoE,UAAvB,CAAT;QACAE,MAAM,CAACC,cAAP,CAAsBF,MAAtB,EAA8B,UAA9B,EAA0C;UACtCG,KAAK,EAAE,iBAAY;YACf,OAAO,KAAKhB,IAAL,CAAU,GAAV,CAAP;UACH;QAHqC,CAA1C;QAKA,OAAOa,MAAP;MACH;IACJ;;IAED,MAAM,IAAIlD,KAAJ,CAAU,yDAAV,CAAN;EACH,CAjBD,CApzBa,CAu0Bb;;;EACAO,MAAM,CAAC0B,IAAP,CAAYY,MAAZ,GAAqB,UAAUvE,MAAV,EAAkB;IACnC,IAAI+F,IAAJ,EAAU7E,CAAV,EAAaX,KAAb,EAAoB6B,KAApB,EAA2BD,MAA3B,EAAmC7B,MAAnC;;IAEA,IAAKC,KAAK,GAAGP,MAAM,CAACO,KAAP,CAAaX,WAAW,CAACC,sBAAzB,CAAb,EAAgE;MAC5D,OAAO,KAAK0E,MAAL,kBAAsBhE,KAAK,CAAC,CAAD,CAA3B,EAAP;IACH;;IACD,IAAIX,WAAW,CAACgH,MAAZ,CAAmB9E,IAAnB,CAAwB9B,MAAxB,CAAJ,EAAqC;MACjC,OAAOD,UAAU,CAACC,MAAD,EAAS,CAAT,CAAjB;IACH;;IACD,IAAKO,KAAK,GAAGP,MAAM,CAACO,KAAP,CAAaX,WAAW,CAACE,YAAzB,CAAb,EAAsD;MAClDQ,MAAM,GAAGC,KAAK,CAAC,CAAD,CAAL,IAAY,EAArB;MACAwF,IAAI,GAAGhG,UAAU,CAACQ,KAAK,CAAC,CAAD,CAAL,CAASM,KAAT,CAAe,CAAf,EAAkB,CAAC,CAAnB,IAAwBP,MAAzB,EAAiC,CAAjC,CAAjB;;MACA,IAAIyF,IAAI,CAAC9F,KAAT,EAAgB;QACZkC,MAAM,GAAG,CACLf,QAAQ,CAACb,KAAK,CAAC,CAAD,CAAN,CADH,EAELa,QAAQ,CAACb,KAAK,CAAC,CAAD,CAAN,CAFH,EAGLa,QAAQ,CAACb,KAAK,CAAC,CAAD,CAAN,CAHH,EAILa,QAAQ,CAACb,KAAK,CAAC,CAAD,CAAN,CAJH,CAAT;;QAMA,KAAKW,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGiB,MAAM,CAACrB,MAAvB,EAA+BI,CAAC,EAAhC,EAAoC;UAChCkB,KAAK,GAAGD,MAAM,CAACjB,CAAD,CAAd;;UACA,IAAI,EAAG,KAAKkB,KAAL,IAAcA,KAAK,IAAI,GAA1B,CAAJ,EAAqC;YACjC,OAAO,IAAP;UACH;QACJ;;QAED2D,IAAI,CAAC9F,KAAL,CAAWkB,IAAX,CAAgBgB,MAAM,CAAC,CAAD,CAAN,IAAa,CAAb,GAAiBA,MAAM,CAAC,CAAD,CAAvC;QACA4D,IAAI,CAAC9F,KAAL,CAAWkB,IAAX,CAAgBgB,MAAM,CAAC,CAAD,CAAN,IAAa,CAAb,GAAiBA,MAAM,CAAC,CAAD,CAAvC;QACA,OAAO;UACHlC,KAAK,EAAE8F,IAAI,CAAC9F,KADT;UAEHK,MAAM,EAAEyF,IAAI,CAACzF;QAFV,CAAP;MAIH;IACJ;;IAED,OAAO,IAAP;EACH,CApCD,CAx0Ba,CA82Bb;;;EACA2B,MAAM,CAAC0B,IAAP,CAAYS,0BAAZ,GAAyC,UAAUa,MAAV,EAAkB;IACvDA,MAAM,GAAG7D,QAAQ,CAAC6D,MAAD,CAAjB;;IACA,IAAIA,MAAM,GAAG,CAAT,IAAcA,MAAM,GAAG,GAA3B,EAAgC;MAC5B,MAAM,IAAIvD,KAAJ,CAAU,oCAAV,CAAN;IACH;;IAED,IAAMS,MAAM,GAAG,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,EAAgB,CAAhB,EAAmB,CAAnB,EAAsB,CAAtB,EAAyB,CAAzB,EAA4B,CAA5B,EAA+B,CAA/B,EAAkC,CAAlC,EAAqC,CAArC,EAAwC,CAAxC,EAA2C,CAA3C,EAA8C,CAA9C,CAAf;IACA,IAAI+C,CAAC,GAAG,CAAR;IACA,IAAMC,gBAAgB,GAAGC,IAAI,CAACC,KAAL,CAAWJ,MAAM,GAAG,CAApB,CAAzB;;IAEA,OAAOC,CAAC,GAAGC,gBAAX,EAA6B;MACzBhD,MAAM,CAAC+C,CAAD,CAAN,GAAY,GAAZ;MACAA,CAAC;IACJ;;IAED,IAAIC,gBAAgB,GAAG,EAAvB,EAA2B;MACvBhD,MAAM,CAACgD,gBAAD,CAAN,GAA2BC,IAAI,CAACE,GAAL,CAAS,CAAT,EAAYL,MAAM,GAAG,CAArB,IAA0B,CAA1B,IAA+B,IAAKA,MAAM,GAAG,CAAxE;IACH;;IAED,OAAO,IAAI,IAAJ,CAAS9C,MAAT,CAAP;EACH,CApBD,CA/2Ba,CAq4Bb;;;EACAF,MAAM,CAAC4E,aAAP,GAAuB,UAAUhB,KAAV,EAAiB;IACpC,IAAM/E,MAAM,GAAG+E,KAAK,CAAC/E,MAArB;;IAEA,IAAIA,MAAM,KAAK,CAAf,EAAkB;MACd,OAAO,IAAImB,MAAM,CAACC,IAAX,CAAgB2D,KAAhB,CAAP;IACH,CAFD,MAEO,IAAI/E,MAAM,KAAK,EAAf,EAAmB;MACtB,OAAO,IAAImB,MAAM,CAAC0B,IAAX,CAAgBkC,KAAhB,CAAP;IACH,CAFM,MAEA;MACH,MAAM,IAAInE,KAAJ,CAAU,8DAAV,CAAN;IACH;EACJ,CAVD,CAt4Ba,CAk5Bb;;;EACAO,MAAM,CAACuC,OAAP,GAAiB,UAAUxE,MAAV,EAAkB;IAC/B,OAAOiC,MAAM,CAAC0B,IAAP,CAAYa,OAAZ,CAAoBxE,MAApB,KAA+BiC,MAAM,CAACC,IAAP,CAAYsC,OAAZ,CAAoBxE,MAApB,CAAtC;EACH,CAFD,CAn5Ba,CAw5Bb;EACA;;;EACAiC,MAAM,CAAC2B,KAAP,GAAe,UAAU5D,MAAV,EAAkB;IAC7B,IAAIiC,MAAM,CAAC0B,IAAP,CAAYa,OAAZ,CAAoBxE,MAApB,CAAJ,EAAiC;MAC7B,OAAOiC,MAAM,CAAC0B,IAAP,CAAYC,KAAZ,CAAkB5D,MAAlB,CAAP;IACH,CAFD,MAEO,IAAIiC,MAAM,CAACC,IAAP,CAAYsC,OAAZ,CAAoBxE,MAApB,CAAJ,EAAiC;MACpC,OAAOiC,MAAM,CAACC,IAAP,CAAY0B,KAAZ,CAAkB5D,MAAlB,CAAP;IACH,CAFM,MAEA;MACH,MAAM,IAAI0B,KAAJ,CAAU,sDAAV,CAAN;IACH;EACJ,CARD,CA15Ba,CAo6Bb;EACA;;;EACAO,MAAM,CAACgC,SAAP,GAAmB,UAAUjE,MAAV,EAAkB;IACjC,IAAI;MACA,OAAOiC,MAAM,CAAC0B,IAAP,CAAYM,SAAZ,CAAsBjE,MAAtB,CAAP;IACH,CAFD,CAEE,OAAOqE,CAAP,EAAU;MACR,IAAI;QACA,OAAOpC,MAAM,CAACC,IAAP,CAAY+B,SAAZ,CAAsBjE,MAAtB,CAAP;MACH,CAFD,CAEE,OAAO8G,EAAP,EAAW;QACT,MAAM,IAAIpF,KAAJ,CAAU,2DAAV,CAAN;MACH;IACJ;EACJ,CAVD,CAt6Ba,CAk7Bb;;;EACAO,MAAM,CAAC8E,OAAP,GAAiB,UAAU/G,MAAV,EAAkB;IAC/B,IAAM+F,IAAI,GAAG,KAAKnC,KAAL,CAAW5D,MAAX,CAAb;;IAEA,IAAI+F,IAAI,CAACjD,IAAL,OAAgB,MAAhB,IAA0BiD,IAAI,CAACH,mBAAL,EAA9B,EAA0D;MACtD,OAAOG,IAAI,CAACG,aAAL,EAAP;IACH,CAFD,MAEO;MACH,OAAOH,IAAP;IACH;EACJ,CARD,CAn7Ba,CA67Bb;EACA;EACA;;;EACA9D,MAAM,CAACuB,WAAP,GAAqB,UAAUwD,OAAV,EAAmBC,SAAnB,EAA8BC,WAA9B,EAA2C;IAC5D,IAAIhG,CAAJ,EAAOiG,SAAP,EAAkBC,YAAlB,EAAgCC,MAAhC;;IAEA,IAAIH,WAAW,KAAKjE,SAAhB,IAA6BiE,WAAW,KAAK,IAAjD,EAAuD;MACnDA,WAAW,GAAG,SAAd;IACH;;IAED,KAAKC,SAAL,IAAkBF,SAAlB,EAA6B;MACzB,IAAIpC,MAAM,CAACxC,SAAP,CAAiBiF,cAAjB,CAAgCtB,IAAhC,CAAqCiB,SAArC,EAAgDE,SAAhD,CAAJ,EAAgE;QAC5DC,YAAY,GAAGH,SAAS,CAACE,SAAD,CAAxB,CAD4D,CAE5D;;QACA,IAAIC,YAAY,CAAC,CAAD,CAAZ,IAAmB,EAAEA,YAAY,CAAC,CAAD,CAAZ,YAA2BG,KAA7B,CAAvB,EAA4D;UACxDH,YAAY,GAAG,CAACA,YAAD,CAAf;QACH;;QAED,KAAKlG,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGkG,YAAY,CAACtG,MAA7B,EAAqCI,CAAC,EAAtC,EAA0C;UACtCmG,MAAM,GAAGD,YAAY,CAAClG,CAAD,CAArB;;UACA,IAAI8F,OAAO,CAAClE,IAAR,OAAmBuE,MAAM,CAAC,CAAD,CAAN,CAAUvE,IAAV,EAAnB,IAAuCkE,OAAO,CAACzG,KAAR,CAAciH,KAAd,CAAoBR,OAApB,EAA6BK,MAA7B,CAA3C,EAAiF;YAC7E,OAAOF,SAAP;UACH;QACJ;MACJ;IACJ;;IAED,OAAOD,WAAP;EACH,CAzBD,CAh8Ba,CA29Bb;;;EACA,IAAI,OAAOO,MAAP,KAAkB,WAAlB,IAAiCA,MAAM,CAACC,OAA5C,EAAqD;IACjDD,MAAM,CAACC,OAAP,GAAiBzF,MAAjB;EAEH,CAHD,MAGO;IACHjD,IAAI,CAACiD,MAAL,GAAcA,MAAd;EACH;AAEJ,CAn+BA,EAm+BC,IAn+BD,CAAD"},"metadata":{},"sourceType":"script"}