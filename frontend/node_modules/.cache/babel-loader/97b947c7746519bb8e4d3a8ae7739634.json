{"ast":null,"code":"// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n// Slim Highlighting for CodeMirror copyright (c) HicknHack Software Gmbh\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../htmlmixed/htmlmixed\"), require(\"../ruby/ruby\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../htmlmixed/htmlmixed\", \"../ruby/ruby\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"slim\", function (config) {\n    var htmlMode = CodeMirror.getMode(config, {\n      name: \"htmlmixed\"\n    });\n    var rubyMode = CodeMirror.getMode(config, \"ruby\");\n    var modes = {\n      html: htmlMode,\n      ruby: rubyMode\n    };\n    var embedded = {\n      ruby: \"ruby\",\n      javascript: \"javascript\",\n      css: \"text/css\",\n      sass: \"text/x-sass\",\n      scss: \"text/x-scss\",\n      less: \"text/x-less\",\n      styl: \"text/x-styl\",\n      // no highlighting so far\n      coffee: \"coffeescript\",\n      asciidoc: \"text/x-asciidoc\",\n      markdown: \"text/x-markdown\",\n      textile: \"text/x-textile\",\n      // no highlighting so far\n      creole: \"text/x-creole\",\n      // no highlighting so far\n      wiki: \"text/x-wiki\",\n      // no highlighting so far\n      mediawiki: \"text/x-mediawiki\",\n      // no highlighting so far\n      rdoc: \"text/x-rdoc\",\n      // no highlighting so far\n      builder: \"text/x-builder\",\n      // no highlighting so far\n      nokogiri: \"text/x-nokogiri\",\n      // no highlighting so far\n      erb: \"application/x-erb\"\n    };\n\n    var embeddedRegexp = function (map) {\n      var arr = [];\n\n      for (var key in map) {\n        arr.push(key);\n      }\n\n      return new RegExp(\"^(\" + arr.join('|') + \"):\");\n    }(embedded);\n\n    var styleMap = {\n      \"commentLine\": \"comment\",\n      \"slimSwitch\": \"operator special\",\n      \"slimTag\": \"tag\",\n      \"slimId\": \"attribute def\",\n      \"slimClass\": \"attribute qualifier\",\n      \"slimAttribute\": \"attribute\",\n      \"slimSubmode\": \"keyword special\",\n      \"closeAttributeTag\": null,\n      \"slimDoctype\": null,\n      \"lineContinuation\": null\n    };\n    var closing = {\n      \"{\": \"}\",\n      \"[\": \"]\",\n      \"(\": \")\"\n    };\n    var nameStartChar = \"_a-zA-Z\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\";\n    var nameChar = nameStartChar + \"\\\\-0-9\\xB7\\u0300-\\u036F\\u203F-\\u2040\";\n    var nameRegexp = new RegExp(\"^[:\" + nameStartChar + \"](?::[\" + nameChar + \"]|[\" + nameChar + \"]*)\");\n    var attributeNameRegexp = new RegExp(\"^[:\" + nameStartChar + \"][:\\\\.\" + nameChar + \"]*(?=\\\\s*=)\");\n    var wrappedAttributeNameRegexp = new RegExp(\"^[:\" + nameStartChar + \"][:\\\\.\" + nameChar + \"]*\");\n    var classNameRegexp = /^\\.-?[_a-zA-Z]+[\\w\\-]*/;\n    var classIdRegexp = /^#[_a-zA-Z]+[\\w\\-]*/;\n\n    function backup(pos, tokenize, style) {\n      var restore = function restore(stream, state) {\n        state.tokenize = tokenize;\n\n        if (stream.pos < pos) {\n          stream.pos = pos;\n          return style;\n        }\n\n        return state.tokenize(stream, state);\n      };\n\n      return function (stream, state) {\n        state.tokenize = restore;\n        return tokenize(stream, state);\n      };\n    }\n\n    function maybeBackup(stream, state, pat, offset, style) {\n      var cur = stream.current();\n      var idx = cur.search(pat);\n\n      if (idx > -1) {\n        state.tokenize = backup(stream.pos, state.tokenize, style);\n        stream.backUp(cur.length - idx - offset);\n      }\n\n      return style;\n    }\n\n    function continueLine(state, column) {\n      state.stack = {\n        parent: state.stack,\n        style: \"continuation\",\n        indented: column,\n        tokenize: state.line\n      };\n      state.line = state.tokenize;\n    }\n\n    function finishContinue(state) {\n      if (state.line == state.tokenize) {\n        state.line = state.stack.tokenize;\n        state.stack = state.stack.parent;\n      }\n    }\n\n    function lineContinuable(column, tokenize) {\n      return function (stream, state) {\n        finishContinue(state);\n\n        if (stream.match(/^\\\\$/)) {\n          continueLine(state, column);\n          return \"lineContinuation\";\n        }\n\n        var style = tokenize(stream, state);\n\n        if (stream.eol() && stream.current().match(/(?:^|[^\\\\])(?:\\\\\\\\)*\\\\$/)) {\n          stream.backUp(1);\n        }\n\n        return style;\n      };\n    }\n\n    function commaContinuable(column, tokenize) {\n      return function (stream, state) {\n        finishContinue(state);\n        var style = tokenize(stream, state);\n\n        if (stream.eol() && stream.current().match(/,$/)) {\n          continueLine(state, column);\n        }\n\n        return style;\n      };\n    }\n\n    function rubyInQuote(endQuote, tokenize) {\n      // TODO: add multi line support\n      return function (stream, state) {\n        var ch = stream.peek();\n\n        if (ch == endQuote && state.rubyState.tokenize.length == 1) {\n          // step out of ruby context as it seems to complete processing all the braces\n          stream.next();\n          state.tokenize = tokenize;\n          return \"closeAttributeTag\";\n        } else {\n          return ruby(stream, state);\n        }\n      };\n    }\n\n    function startRubySplat(tokenize) {\n      var rubyState;\n\n      var runSplat = function runSplat(stream, state) {\n        if (state.rubyState.tokenize.length == 1 && !state.rubyState.context.prev) {\n          stream.backUp(1);\n\n          if (stream.eatSpace()) {\n            state.rubyState = rubyState;\n            state.tokenize = tokenize;\n            return tokenize(stream, state);\n          }\n\n          stream.next();\n        }\n\n        return ruby(stream, state);\n      };\n\n      return function (stream, state) {\n        rubyState = state.rubyState;\n        state.rubyState = CodeMirror.startState(rubyMode);\n        state.tokenize = runSplat;\n        return ruby(stream, state);\n      };\n    }\n\n    function ruby(stream, state) {\n      return rubyMode.token(stream, state.rubyState);\n    }\n\n    function htmlLine(stream, state) {\n      if (stream.match(/^\\\\$/)) {\n        return \"lineContinuation\";\n      }\n\n      return html(stream, state);\n    }\n\n    function html(stream, state) {\n      if (stream.match(/^#\\{/)) {\n        state.tokenize = rubyInQuote(\"}\", state.tokenize);\n        return null;\n      }\n\n      return maybeBackup(stream, state, /[^\\\\]#\\{/, 1, htmlMode.token(stream, state.htmlState));\n    }\n\n    function startHtmlLine(lastTokenize) {\n      return function (stream, state) {\n        var style = htmlLine(stream, state);\n        if (stream.eol()) state.tokenize = lastTokenize;\n        return style;\n      };\n    }\n\n    function startHtmlMode(stream, state, offset) {\n      state.stack = {\n        parent: state.stack,\n        style: \"html\",\n        indented: stream.column() + offset,\n        // pipe + space\n        tokenize: state.line\n      };\n      state.line = state.tokenize = html;\n      return null;\n    }\n\n    function comment(stream, state) {\n      stream.skipToEnd();\n      return state.stack.style;\n    }\n\n    function commentMode(stream, state) {\n      state.stack = {\n        parent: state.stack,\n        style: \"comment\",\n        indented: state.indented + 1,\n        tokenize: state.line\n      };\n      state.line = comment;\n      return comment(stream, state);\n    }\n\n    function attributeWrapper(stream, state) {\n      if (stream.eat(state.stack.endQuote)) {\n        state.line = state.stack.line;\n        state.tokenize = state.stack.tokenize;\n        state.stack = state.stack.parent;\n        return null;\n      }\n\n      if (stream.match(wrappedAttributeNameRegexp)) {\n        state.tokenize = attributeWrapperAssign;\n        return \"slimAttribute\";\n      }\n\n      stream.next();\n      return null;\n    }\n\n    function attributeWrapperAssign(stream, state) {\n      if (stream.match(/^==?/)) {\n        state.tokenize = attributeWrapperValue;\n        return null;\n      }\n\n      return attributeWrapper(stream, state);\n    }\n\n    function attributeWrapperValue(stream, state) {\n      var ch = stream.peek();\n\n      if (ch == '\"' || ch == \"\\'\") {\n        state.tokenize = readQuoted(ch, \"string\", true, false, attributeWrapper);\n        stream.next();\n        return state.tokenize(stream, state);\n      }\n\n      if (ch == '[') {\n        return startRubySplat(attributeWrapper)(stream, state);\n      }\n\n      if (stream.match(/^(true|false|nil)\\b/)) {\n        state.tokenize = attributeWrapper;\n        return \"keyword\";\n      }\n\n      return startRubySplat(attributeWrapper)(stream, state);\n    }\n\n    function startAttributeWrapperMode(state, endQuote, tokenize) {\n      state.stack = {\n        parent: state.stack,\n        style: \"wrapper\",\n        indented: state.indented + 1,\n        tokenize: tokenize,\n        line: state.line,\n        endQuote: endQuote\n      };\n      state.line = state.tokenize = attributeWrapper;\n      return null;\n    }\n\n    function sub(stream, state) {\n      if (stream.match(/^#\\{/)) {\n        state.tokenize = rubyInQuote(\"}\", state.tokenize);\n        return null;\n      }\n\n      var subStream = new CodeMirror.StringStream(stream.string.slice(state.stack.indented), stream.tabSize);\n      subStream.pos = stream.pos - state.stack.indented;\n      subStream.start = stream.start - state.stack.indented;\n      subStream.lastColumnPos = stream.lastColumnPos - state.stack.indented;\n      subStream.lastColumnValue = stream.lastColumnValue - state.stack.indented;\n      var style = state.subMode.token(subStream, state.subState);\n      stream.pos = subStream.pos + state.stack.indented;\n      return style;\n    }\n\n    function firstSub(stream, state) {\n      state.stack.indented = stream.column();\n      state.line = state.tokenize = sub;\n      return state.tokenize(stream, state);\n    }\n\n    function createMode(mode) {\n      var query = embedded[mode];\n      var spec = CodeMirror.mimeModes[query];\n\n      if (spec) {\n        return CodeMirror.getMode(config, spec);\n      }\n\n      var factory = CodeMirror.modes[query];\n\n      if (factory) {\n        return factory(config, {\n          name: query\n        });\n      }\n\n      return CodeMirror.getMode(config, \"null\");\n    }\n\n    function getMode(mode) {\n      if (!modes.hasOwnProperty(mode)) {\n        return modes[mode] = createMode(mode);\n      }\n\n      return modes[mode];\n    }\n\n    function startSubMode(mode, state) {\n      var subMode = getMode(mode);\n      var subState = CodeMirror.startState(subMode);\n      state.subMode = subMode;\n      state.subState = subState;\n      state.stack = {\n        parent: state.stack,\n        style: \"sub\",\n        indented: state.indented + 1,\n        tokenize: state.line\n      };\n      state.line = state.tokenize = firstSub;\n      return \"slimSubmode\";\n    }\n\n    function doctypeLine(stream, _state) {\n      stream.skipToEnd();\n      return \"slimDoctype\";\n    }\n\n    function startLine(stream, state) {\n      var ch = stream.peek();\n\n      if (ch == '<') {\n        return (state.tokenize = startHtmlLine(state.tokenize))(stream, state);\n      }\n\n      if (stream.match(/^[|']/)) {\n        return startHtmlMode(stream, state, 1);\n      }\n\n      if (stream.match(/^\\/(!|\\[\\w+])?/)) {\n        return commentMode(stream, state);\n      }\n\n      if (stream.match(/^(-|==?[<>]?)/)) {\n        state.tokenize = lineContinuable(stream.column(), commaContinuable(stream.column(), ruby));\n        return \"slimSwitch\";\n      }\n\n      if (stream.match(/^doctype\\b/)) {\n        state.tokenize = doctypeLine;\n        return \"keyword\";\n      }\n\n      var m = stream.match(embeddedRegexp);\n\n      if (m) {\n        return startSubMode(m[1], state);\n      }\n\n      return slimTag(stream, state);\n    }\n\n    function slim(stream, state) {\n      if (state.startOfLine) {\n        return startLine(stream, state);\n      }\n\n      return slimTag(stream, state);\n    }\n\n    function slimTag(stream, state) {\n      if (stream.eat('*')) {\n        state.tokenize = startRubySplat(slimTagExtras);\n        return null;\n      }\n\n      if (stream.match(nameRegexp)) {\n        state.tokenize = slimTagExtras;\n        return \"slimTag\";\n      }\n\n      return slimClass(stream, state);\n    }\n\n    function slimTagExtras(stream, state) {\n      if (stream.match(/^(<>?|><?)/)) {\n        state.tokenize = slimClass;\n        return null;\n      }\n\n      return slimClass(stream, state);\n    }\n\n    function slimClass(stream, state) {\n      if (stream.match(classIdRegexp)) {\n        state.tokenize = slimClass;\n        return \"slimId\";\n      }\n\n      if (stream.match(classNameRegexp)) {\n        state.tokenize = slimClass;\n        return \"slimClass\";\n      }\n\n      return slimAttribute(stream, state);\n    }\n\n    function slimAttribute(stream, state) {\n      if (stream.match(/^([\\[\\{\\(])/)) {\n        return startAttributeWrapperMode(state, closing[RegExp.$1], slimAttribute);\n      }\n\n      if (stream.match(attributeNameRegexp)) {\n        state.tokenize = slimAttributeAssign;\n        return \"slimAttribute\";\n      }\n\n      if (stream.peek() == '*') {\n        stream.next();\n        state.tokenize = startRubySplat(slimContent);\n        return null;\n      }\n\n      return slimContent(stream, state);\n    }\n\n    function slimAttributeAssign(stream, state) {\n      if (stream.match(/^==?/)) {\n        state.tokenize = slimAttributeValue;\n        return null;\n      } // should never happen, because of forward lookup\n\n\n      return slimAttribute(stream, state);\n    }\n\n    function slimAttributeValue(stream, state) {\n      var ch = stream.peek();\n\n      if (ch == '\"' || ch == \"\\'\") {\n        state.tokenize = readQuoted(ch, \"string\", true, false, slimAttribute);\n        stream.next();\n        return state.tokenize(stream, state);\n      }\n\n      if (ch == '[') {\n        return startRubySplat(slimAttribute)(stream, state);\n      }\n\n      if (ch == ':') {\n        return startRubySplat(slimAttributeSymbols)(stream, state);\n      }\n\n      if (stream.match(/^(true|false|nil)\\b/)) {\n        state.tokenize = slimAttribute;\n        return \"keyword\";\n      }\n\n      return startRubySplat(slimAttribute)(stream, state);\n    }\n\n    function slimAttributeSymbols(stream, state) {\n      stream.backUp(1);\n\n      if (stream.match(/^[^\\s],(?=:)/)) {\n        state.tokenize = startRubySplat(slimAttributeSymbols);\n        return null;\n      }\n\n      stream.next();\n      return slimAttribute(stream, state);\n    }\n\n    function readQuoted(quote, style, embed, unescaped, nextTokenize) {\n      return function (stream, state) {\n        finishContinue(state);\n        var fresh = stream.current().length == 0;\n\n        if (stream.match(/^\\\\$/, fresh)) {\n          if (!fresh) return style;\n          continueLine(state, state.indented);\n          return \"lineContinuation\";\n        }\n\n        if (stream.match(/^#\\{/, fresh)) {\n          if (!fresh) return style;\n          state.tokenize = rubyInQuote(\"}\", state.tokenize);\n          return null;\n        }\n\n        var escaped = false,\n            ch;\n\n        while ((ch = stream.next()) != null) {\n          if (ch == quote && (unescaped || !escaped)) {\n            state.tokenize = nextTokenize;\n            break;\n          }\n\n          if (embed && ch == \"#\" && !escaped) {\n            if (stream.eat(\"{\")) {\n              stream.backUp(2);\n              break;\n            }\n          }\n\n          escaped = !escaped && ch == \"\\\\\";\n        }\n\n        if (stream.eol() && escaped) {\n          stream.backUp(1);\n        }\n\n        return style;\n      };\n    }\n\n    function slimContent(stream, state) {\n      if (stream.match(/^==?/)) {\n        state.tokenize = ruby;\n        return \"slimSwitch\";\n      }\n\n      if (stream.match(/^\\/$/)) {\n        // tag close hint\n        state.tokenize = slim;\n        return null;\n      }\n\n      if (stream.match(/^:/)) {\n        // inline tag\n        state.tokenize = slimTag;\n        return \"slimSwitch\";\n      }\n\n      startHtmlMode(stream, state, 0);\n      return state.tokenize(stream, state);\n    }\n\n    var mode = {\n      // default to html mode\n      startState: function startState() {\n        var htmlState = CodeMirror.startState(htmlMode);\n        var rubyState = CodeMirror.startState(rubyMode);\n        return {\n          htmlState: htmlState,\n          rubyState: rubyState,\n          stack: null,\n          last: null,\n          tokenize: slim,\n          line: slim,\n          indented: 0\n        };\n      },\n      copyState: function copyState(state) {\n        return {\n          htmlState: CodeMirror.copyState(htmlMode, state.htmlState),\n          rubyState: CodeMirror.copyState(rubyMode, state.rubyState),\n          subMode: state.subMode,\n          subState: state.subMode && CodeMirror.copyState(state.subMode, state.subState),\n          stack: state.stack,\n          last: state.last,\n          tokenize: state.tokenize,\n          line: state.line\n        };\n      },\n      token: function token(stream, state) {\n        if (stream.sol()) {\n          state.indented = stream.indentation();\n          state.startOfLine = true;\n          state.tokenize = state.line;\n\n          while (state.stack && state.stack.indented > state.indented && state.last != \"slimSubmode\") {\n            state.line = state.tokenize = state.stack.tokenize;\n            state.stack = state.stack.parent;\n            state.subMode = null;\n            state.subState = null;\n          }\n        }\n\n        if (stream.eatSpace()) return null;\n        var style = state.tokenize(stream, state);\n        state.startOfLine = false;\n        if (style) state.last = style;\n        return styleMap.hasOwnProperty(style) ? styleMap[style] : style;\n      },\n      blankLine: function blankLine(state) {\n        if (state.subMode && state.subMode.blankLine) {\n          return state.subMode.blankLine(state.subState);\n        }\n      },\n      innerMode: function innerMode(state) {\n        if (state.subMode) return {\n          state: state.subState,\n          mode: state.subMode\n        };\n        return {\n          state: state,\n          mode: mode\n        };\n      } //indent: function(state) {\n      //  return state.indented;\n      //}\n\n    };\n    return mode;\n  }, \"htmlmixed\", \"ruby\");\n  CodeMirror.defineMIME(\"text/x-slim\", \"slim\");\n  CodeMirror.defineMIME(\"application/x-slim\", \"slim\");\n});","map":{"version":3,"names":["mod","exports","module","require","define","amd","CodeMirror","defineMode","config","htmlMode","getMode","name","rubyMode","modes","html","ruby","embedded","javascript","css","sass","scss","less","styl","coffee","asciidoc","markdown","textile","creole","wiki","mediawiki","rdoc","builder","nokogiri","erb","embeddedRegexp","map","arr","key","push","RegExp","join","styleMap","closing","nameStartChar","nameChar","nameRegexp","attributeNameRegexp","wrappedAttributeNameRegexp","classNameRegexp","classIdRegexp","backup","pos","tokenize","style","restore","stream","state","maybeBackup","pat","offset","cur","current","idx","search","backUp","length","continueLine","column","stack","parent","indented","line","finishContinue","lineContinuable","match","eol","commaContinuable","rubyInQuote","endQuote","ch","peek","rubyState","next","startRubySplat","runSplat","context","prev","eatSpace","startState","token","htmlLine","htmlState","startHtmlLine","lastTokenize","startHtmlMode","comment","skipToEnd","commentMode","attributeWrapper","eat","attributeWrapperAssign","attributeWrapperValue","readQuoted","startAttributeWrapperMode","sub","subStream","StringStream","string","slice","tabSize","start","lastColumnPos","lastColumnValue","subMode","subState","firstSub","createMode","mode","query","spec","mimeModes","factory","hasOwnProperty","startSubMode","doctypeLine","_state","startLine","m","slimTag","slim","startOfLine","slimTagExtras","slimClass","slimAttribute","$1","slimAttributeAssign","slimContent","slimAttributeValue","slimAttributeSymbols","quote","embed","unescaped","nextTokenize","fresh","escaped","last","copyState","sol","indentation","blankLine","innerMode","defineMIME"],"sources":["/mnt/Datengrab/python/Zero-tier/frontend/node_modules/codemirror/mode/slim/slim.js"],"sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n// Slim Highlighting for CodeMirror copyright (c) HicknHack Software Gmbh\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../htmlmixed/htmlmixed\"), require(\"../ruby/ruby\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../htmlmixed/htmlmixed\", \"../ruby/ruby\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\n  CodeMirror.defineMode(\"slim\", function(config) {\n    var htmlMode = CodeMirror.getMode(config, {name: \"htmlmixed\"});\n    var rubyMode = CodeMirror.getMode(config, \"ruby\");\n    var modes = { html: htmlMode, ruby: rubyMode };\n    var embedded = {\n      ruby: \"ruby\",\n      javascript: \"javascript\",\n      css: \"text/css\",\n      sass: \"text/x-sass\",\n      scss: \"text/x-scss\",\n      less: \"text/x-less\",\n      styl: \"text/x-styl\", // no highlighting so far\n      coffee: \"coffeescript\",\n      asciidoc: \"text/x-asciidoc\",\n      markdown: \"text/x-markdown\",\n      textile: \"text/x-textile\", // no highlighting so far\n      creole: \"text/x-creole\", // no highlighting so far\n      wiki: \"text/x-wiki\", // no highlighting so far\n      mediawiki: \"text/x-mediawiki\", // no highlighting so far\n      rdoc: \"text/x-rdoc\", // no highlighting so far\n      builder: \"text/x-builder\", // no highlighting so far\n      nokogiri: \"text/x-nokogiri\", // no highlighting so far\n      erb: \"application/x-erb\"\n    };\n    var embeddedRegexp = function(map){\n      var arr = [];\n      for(var key in map) arr.push(key);\n      return new RegExp(\"^(\"+arr.join('|')+\"):\");\n    }(embedded);\n\n    var styleMap = {\n      \"commentLine\": \"comment\",\n      \"slimSwitch\": \"operator special\",\n      \"slimTag\": \"tag\",\n      \"slimId\": \"attribute def\",\n      \"slimClass\": \"attribute qualifier\",\n      \"slimAttribute\": \"attribute\",\n      \"slimSubmode\": \"keyword special\",\n      \"closeAttributeTag\": null,\n      \"slimDoctype\": null,\n      \"lineContinuation\": null\n    };\n    var closing = {\n      \"{\": \"}\",\n      \"[\": \"]\",\n      \"(\": \")\"\n    };\n\n    var nameStartChar = \"_a-zA-Z\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\";\n    var nameChar = nameStartChar + \"\\\\-0-9\\xB7\\u0300-\\u036F\\u203F-\\u2040\";\n    var nameRegexp = new RegExp(\"^[:\"+nameStartChar+\"](?::[\"+nameChar+\"]|[\"+nameChar+\"]*)\");\n    var attributeNameRegexp = new RegExp(\"^[:\"+nameStartChar+\"][:\\\\.\"+nameChar+\"]*(?=\\\\s*=)\");\n    var wrappedAttributeNameRegexp = new RegExp(\"^[:\"+nameStartChar+\"][:\\\\.\"+nameChar+\"]*\");\n    var classNameRegexp = /^\\.-?[_a-zA-Z]+[\\w\\-]*/;\n    var classIdRegexp = /^#[_a-zA-Z]+[\\w\\-]*/;\n\n    function backup(pos, tokenize, style) {\n      var restore = function(stream, state) {\n        state.tokenize = tokenize;\n        if (stream.pos < pos) {\n          stream.pos = pos;\n          return style;\n        }\n        return state.tokenize(stream, state);\n      };\n      return function(stream, state) {\n        state.tokenize = restore;\n        return tokenize(stream, state);\n      };\n    }\n\n    function maybeBackup(stream, state, pat, offset, style) {\n      var cur = stream.current();\n      var idx = cur.search(pat);\n      if (idx > -1) {\n        state.tokenize = backup(stream.pos, state.tokenize, style);\n        stream.backUp(cur.length - idx - offset);\n      }\n      return style;\n    }\n\n    function continueLine(state, column) {\n      state.stack = {\n        parent: state.stack,\n        style: \"continuation\",\n        indented: column,\n        tokenize: state.line\n      };\n      state.line = state.tokenize;\n    }\n    function finishContinue(state) {\n      if (state.line == state.tokenize) {\n        state.line = state.stack.tokenize;\n        state.stack = state.stack.parent;\n      }\n    }\n\n    function lineContinuable(column, tokenize) {\n      return function(stream, state) {\n        finishContinue(state);\n        if (stream.match(/^\\\\$/)) {\n          continueLine(state, column);\n          return \"lineContinuation\";\n        }\n        var style = tokenize(stream, state);\n        if (stream.eol() && stream.current().match(/(?:^|[^\\\\])(?:\\\\\\\\)*\\\\$/)) {\n          stream.backUp(1);\n        }\n        return style;\n      };\n    }\n    function commaContinuable(column, tokenize) {\n      return function(stream, state) {\n        finishContinue(state);\n        var style = tokenize(stream, state);\n        if (stream.eol() && stream.current().match(/,$/)) {\n          continueLine(state, column);\n        }\n        return style;\n      };\n    }\n\n    function rubyInQuote(endQuote, tokenize) {\n      // TODO: add multi line support\n      return function(stream, state) {\n        var ch = stream.peek();\n        if (ch == endQuote && state.rubyState.tokenize.length == 1) {\n          // step out of ruby context as it seems to complete processing all the braces\n          stream.next();\n          state.tokenize = tokenize;\n          return \"closeAttributeTag\";\n        } else {\n          return ruby(stream, state);\n        }\n      };\n    }\n    function startRubySplat(tokenize) {\n      var rubyState;\n      var runSplat = function(stream, state) {\n        if (state.rubyState.tokenize.length == 1 && !state.rubyState.context.prev) {\n          stream.backUp(1);\n          if (stream.eatSpace()) {\n            state.rubyState = rubyState;\n            state.tokenize = tokenize;\n            return tokenize(stream, state);\n          }\n          stream.next();\n        }\n        return ruby(stream, state);\n      };\n      return function(stream, state) {\n        rubyState = state.rubyState;\n        state.rubyState = CodeMirror.startState(rubyMode);\n        state.tokenize = runSplat;\n        return ruby(stream, state);\n      };\n    }\n\n    function ruby(stream, state) {\n      return rubyMode.token(stream, state.rubyState);\n    }\n\n    function htmlLine(stream, state) {\n      if (stream.match(/^\\\\$/)) {\n        return \"lineContinuation\";\n      }\n      return html(stream, state);\n    }\n    function html(stream, state) {\n      if (stream.match(/^#\\{/)) {\n        state.tokenize = rubyInQuote(\"}\", state.tokenize);\n        return null;\n      }\n      return maybeBackup(stream, state, /[^\\\\]#\\{/, 1, htmlMode.token(stream, state.htmlState));\n    }\n\n    function startHtmlLine(lastTokenize) {\n      return function(stream, state) {\n        var style = htmlLine(stream, state);\n        if (stream.eol()) state.tokenize = lastTokenize;\n        return style;\n      };\n    }\n\n    function startHtmlMode(stream, state, offset) {\n      state.stack = {\n        parent: state.stack,\n        style: \"html\",\n        indented: stream.column() + offset, // pipe + space\n        tokenize: state.line\n      };\n      state.line = state.tokenize = html;\n      return null;\n    }\n\n    function comment(stream, state) {\n      stream.skipToEnd();\n      return state.stack.style;\n    }\n\n    function commentMode(stream, state) {\n      state.stack = {\n        parent: state.stack,\n        style: \"comment\",\n        indented: state.indented + 1,\n        tokenize: state.line\n      };\n      state.line = comment;\n      return comment(stream, state);\n    }\n\n    function attributeWrapper(stream, state) {\n      if (stream.eat(state.stack.endQuote)) {\n        state.line = state.stack.line;\n        state.tokenize = state.stack.tokenize;\n        state.stack = state.stack.parent;\n        return null;\n      }\n      if (stream.match(wrappedAttributeNameRegexp)) {\n        state.tokenize = attributeWrapperAssign;\n        return \"slimAttribute\";\n      }\n      stream.next();\n      return null;\n    }\n    function attributeWrapperAssign(stream, state) {\n      if (stream.match(/^==?/)) {\n        state.tokenize = attributeWrapperValue;\n        return null;\n      }\n      return attributeWrapper(stream, state);\n    }\n    function attributeWrapperValue(stream, state) {\n      var ch = stream.peek();\n      if (ch == '\"' || ch == \"\\'\") {\n        state.tokenize = readQuoted(ch, \"string\", true, false, attributeWrapper);\n        stream.next();\n        return state.tokenize(stream, state);\n      }\n      if (ch == '[') {\n        return startRubySplat(attributeWrapper)(stream, state);\n      }\n      if (stream.match(/^(true|false|nil)\\b/)) {\n        state.tokenize = attributeWrapper;\n        return \"keyword\";\n      }\n      return startRubySplat(attributeWrapper)(stream, state);\n    }\n\n    function startAttributeWrapperMode(state, endQuote, tokenize) {\n      state.stack = {\n        parent: state.stack,\n        style: \"wrapper\",\n        indented: state.indented + 1,\n        tokenize: tokenize,\n        line: state.line,\n        endQuote: endQuote\n      };\n      state.line = state.tokenize = attributeWrapper;\n      return null;\n    }\n\n    function sub(stream, state) {\n      if (stream.match(/^#\\{/)) {\n        state.tokenize = rubyInQuote(\"}\", state.tokenize);\n        return null;\n      }\n      var subStream = new CodeMirror.StringStream(stream.string.slice(state.stack.indented), stream.tabSize);\n      subStream.pos = stream.pos - state.stack.indented;\n      subStream.start = stream.start - state.stack.indented;\n      subStream.lastColumnPos = stream.lastColumnPos - state.stack.indented;\n      subStream.lastColumnValue = stream.lastColumnValue - state.stack.indented;\n      var style = state.subMode.token(subStream, state.subState);\n      stream.pos = subStream.pos + state.stack.indented;\n      return style;\n    }\n    function firstSub(stream, state) {\n      state.stack.indented = stream.column();\n      state.line = state.tokenize = sub;\n      return state.tokenize(stream, state);\n    }\n\n    function createMode(mode) {\n      var query = embedded[mode];\n      var spec = CodeMirror.mimeModes[query];\n      if (spec) {\n        return CodeMirror.getMode(config, spec);\n      }\n      var factory = CodeMirror.modes[query];\n      if (factory) {\n        return factory(config, {name: query});\n      }\n      return CodeMirror.getMode(config, \"null\");\n    }\n\n    function getMode(mode) {\n      if (!modes.hasOwnProperty(mode)) {\n        return modes[mode] = createMode(mode);\n      }\n      return modes[mode];\n    }\n\n    function startSubMode(mode, state) {\n      var subMode = getMode(mode);\n      var subState = CodeMirror.startState(subMode);\n\n      state.subMode = subMode;\n      state.subState = subState;\n\n      state.stack = {\n        parent: state.stack,\n        style: \"sub\",\n        indented: state.indented + 1,\n        tokenize: state.line\n      };\n      state.line = state.tokenize = firstSub;\n      return \"slimSubmode\";\n    }\n\n    function doctypeLine(stream, _state) {\n      stream.skipToEnd();\n      return \"slimDoctype\";\n    }\n\n    function startLine(stream, state) {\n      var ch = stream.peek();\n      if (ch == '<') {\n        return (state.tokenize = startHtmlLine(state.tokenize))(stream, state);\n      }\n      if (stream.match(/^[|']/)) {\n        return startHtmlMode(stream, state, 1);\n      }\n      if (stream.match(/^\\/(!|\\[\\w+])?/)) {\n        return commentMode(stream, state);\n      }\n      if (stream.match(/^(-|==?[<>]?)/)) {\n        state.tokenize = lineContinuable(stream.column(), commaContinuable(stream.column(), ruby));\n        return \"slimSwitch\";\n      }\n      if (stream.match(/^doctype\\b/)) {\n        state.tokenize = doctypeLine;\n        return \"keyword\";\n      }\n\n      var m = stream.match(embeddedRegexp);\n      if (m) {\n        return startSubMode(m[1], state);\n      }\n\n      return slimTag(stream, state);\n    }\n\n    function slim(stream, state) {\n      if (state.startOfLine) {\n        return startLine(stream, state);\n      }\n      return slimTag(stream, state);\n    }\n\n    function slimTag(stream, state) {\n      if (stream.eat('*')) {\n        state.tokenize = startRubySplat(slimTagExtras);\n        return null;\n      }\n      if (stream.match(nameRegexp)) {\n        state.tokenize = slimTagExtras;\n        return \"slimTag\";\n      }\n      return slimClass(stream, state);\n    }\n    function slimTagExtras(stream, state) {\n      if (stream.match(/^(<>?|><?)/)) {\n        state.tokenize = slimClass;\n        return null;\n      }\n      return slimClass(stream, state);\n    }\n    function slimClass(stream, state) {\n      if (stream.match(classIdRegexp)) {\n        state.tokenize = slimClass;\n        return \"slimId\";\n      }\n      if (stream.match(classNameRegexp)) {\n        state.tokenize = slimClass;\n        return \"slimClass\";\n      }\n      return slimAttribute(stream, state);\n    }\n    function slimAttribute(stream, state) {\n      if (stream.match(/^([\\[\\{\\(])/)) {\n        return startAttributeWrapperMode(state, closing[RegExp.$1], slimAttribute);\n      }\n      if (stream.match(attributeNameRegexp)) {\n        state.tokenize = slimAttributeAssign;\n        return \"slimAttribute\";\n      }\n      if (stream.peek() == '*') {\n        stream.next();\n        state.tokenize = startRubySplat(slimContent);\n        return null;\n      }\n      return slimContent(stream, state);\n    }\n    function slimAttributeAssign(stream, state) {\n      if (stream.match(/^==?/)) {\n        state.tokenize = slimAttributeValue;\n        return null;\n      }\n      // should never happen, because of forward lookup\n      return slimAttribute(stream, state);\n    }\n\n    function slimAttributeValue(stream, state) {\n      var ch = stream.peek();\n      if (ch == '\"' || ch == \"\\'\") {\n        state.tokenize = readQuoted(ch, \"string\", true, false, slimAttribute);\n        stream.next();\n        return state.tokenize(stream, state);\n      }\n      if (ch == '[') {\n        return startRubySplat(slimAttribute)(stream, state);\n      }\n      if (ch == ':') {\n        return startRubySplat(slimAttributeSymbols)(stream, state);\n      }\n      if (stream.match(/^(true|false|nil)\\b/)) {\n        state.tokenize = slimAttribute;\n        return \"keyword\";\n      }\n      return startRubySplat(slimAttribute)(stream, state);\n    }\n    function slimAttributeSymbols(stream, state) {\n      stream.backUp(1);\n      if (stream.match(/^[^\\s],(?=:)/)) {\n        state.tokenize = startRubySplat(slimAttributeSymbols);\n        return null;\n      }\n      stream.next();\n      return slimAttribute(stream, state);\n    }\n    function readQuoted(quote, style, embed, unescaped, nextTokenize) {\n      return function(stream, state) {\n        finishContinue(state);\n        var fresh = stream.current().length == 0;\n        if (stream.match(/^\\\\$/, fresh)) {\n          if (!fresh) return style;\n          continueLine(state, state.indented);\n          return \"lineContinuation\";\n        }\n        if (stream.match(/^#\\{/, fresh)) {\n          if (!fresh) return style;\n          state.tokenize = rubyInQuote(\"}\", state.tokenize);\n          return null;\n        }\n        var escaped = false, ch;\n        while ((ch = stream.next()) != null) {\n          if (ch == quote && (unescaped || !escaped)) {\n            state.tokenize = nextTokenize;\n            break;\n          }\n          if (embed && ch == \"#\" && !escaped) {\n            if (stream.eat(\"{\")) {\n              stream.backUp(2);\n              break;\n            }\n          }\n          escaped = !escaped && ch == \"\\\\\";\n        }\n        if (stream.eol() && escaped) {\n          stream.backUp(1);\n        }\n        return style;\n      };\n    }\n    function slimContent(stream, state) {\n      if (stream.match(/^==?/)) {\n        state.tokenize = ruby;\n        return \"slimSwitch\";\n      }\n      if (stream.match(/^\\/$/)) { // tag close hint\n        state.tokenize = slim;\n        return null;\n      }\n      if (stream.match(/^:/)) { // inline tag\n        state.tokenize = slimTag;\n        return \"slimSwitch\";\n      }\n      startHtmlMode(stream, state, 0);\n      return state.tokenize(stream, state);\n    }\n\n    var mode = {\n      // default to html mode\n      startState: function() {\n        var htmlState = CodeMirror.startState(htmlMode);\n        var rubyState = CodeMirror.startState(rubyMode);\n        return {\n          htmlState: htmlState,\n          rubyState: rubyState,\n          stack: null,\n          last: null,\n          tokenize: slim,\n          line: slim,\n          indented: 0\n        };\n      },\n\n      copyState: function(state) {\n        return {\n          htmlState : CodeMirror.copyState(htmlMode, state.htmlState),\n          rubyState: CodeMirror.copyState(rubyMode, state.rubyState),\n          subMode: state.subMode,\n          subState: state.subMode && CodeMirror.copyState(state.subMode, state.subState),\n          stack: state.stack,\n          last: state.last,\n          tokenize: state.tokenize,\n          line: state.line\n        };\n      },\n\n      token: function(stream, state) {\n        if (stream.sol()) {\n          state.indented = stream.indentation();\n          state.startOfLine = true;\n          state.tokenize = state.line;\n          while (state.stack && state.stack.indented > state.indented && state.last != \"slimSubmode\") {\n            state.line = state.tokenize = state.stack.tokenize;\n            state.stack = state.stack.parent;\n            state.subMode = null;\n            state.subState = null;\n          }\n        }\n        if (stream.eatSpace()) return null;\n        var style = state.tokenize(stream, state);\n        state.startOfLine = false;\n        if (style) state.last = style;\n        return styleMap.hasOwnProperty(style) ? styleMap[style] : style;\n      },\n\n      blankLine: function(state) {\n        if (state.subMode && state.subMode.blankLine) {\n          return state.subMode.blankLine(state.subState);\n        }\n      },\n\n      innerMode: function(state) {\n        if (state.subMode) return {state: state.subState, mode: state.subMode};\n        return {state: state, mode: mode};\n      }\n\n      //indent: function(state) {\n      //  return state.indented;\n      //}\n    };\n    return mode;\n  }, \"htmlmixed\", \"ruby\");\n\n  CodeMirror.defineMIME(\"text/x-slim\", \"slim\");\n  CodeMirror.defineMIME(\"application/x-slim\", \"slim\");\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}